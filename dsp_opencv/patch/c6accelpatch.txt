diff -uNr c6accel_1_00_00_04_async0/config.bld c6accel_1_00_00_04_async/config.bld
--- c6accel_1_00_00_04_async0/config.bld	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/config.bld	2010-08-14 17:17:19.000000000 -0500
@@ -1,81 +1,81 @@
-/* --COPYRIGHT--,BSD
- * Copyright (c) 2010, Texas Instruments Incorporated
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * *  Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * *  Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * *  Neither the name of Texas Instruments Incorporated nor the names of
- *    its contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * --/COPYRIGHT--*/
-
-/* location of your C6000 codegen tools */
-var codegen = "" + java.lang.System.getenv("CODEGEN_INSTALL_DIR");
-
-/* Verify that PLATFORM_XDC was set as an environment variable */
-var xdcplat = "" + java.lang.System.getenv("PLATFORM_XDC");
-if (xdcplat=="null" || xdcplat==""){
-    print("Warning: XDC_PLATFORM not found. Verify that PLATFORM_XDC "
-        + "is set correctly in Platform.xdc.");
-}
-
-var C64P = xdc.useModule('ti.targets.C64P');
-C64P.rootDir = codegen;
-C64P.platform = xdcplat;
-
-var C674 = xdc.useModule('ti.targets.C674');
-C674.rootDir = codegen;
-C674.platform = xdcplat;
-
-/* User passes in $(CROSS_COMPILE) where $(CROSS_COMPILE)gcc is their compiler
-   Then the TOOLDIR and LONGNAME are derived based on a regex of CROSS_COMPILE
-*/
-var crosscompile = "" + java.lang.System.getenv("CROSS_COMPILE");
-
-var tooldir = "";
-var longName = "";
-
-/* Search CROSS_COMPILE for bin/ If only 1 bin/ is found, set the tooldir to
-   the path prior to bin/ and the prefix to "bin/" + remainder of path,
-   else leave the tooldir as "" and set the LONGNAME to the full CROSS_COMPILE
-   path
-*/
-var regex = new RegExp("bin/");
-var find = crosscompile.split( regex );
-
-if (find[0]!=crosscompile && find.length==2) {
-    tooldir = find[0];
-    longName = "bin/" + find[1] + "gcc";
-} else {
-    longName = crosscompile + "gcc";
-}
-
-/* location of the GCC Arm9 tools */
-var GCArmv5T = xdc.useModule('gnu.targets.arm.GCArmv5T');
-GCArmv5T.LONGNAME = longName;
-GCArmv5T.platform = java.lang.System.getenv("PLATFORM_XDC");
-GCArmv5T.rootDir = tooldir;
-
-Build.targets = [
-];
+/* --COPYRIGHT--,BSD
+ * Copyright (c) 2010, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--*/
+
+/* location of your C6000 codegen tools */
+var codegen = "" + java.lang.System.getenv("CODEGEN_INSTALL_DIR");
+
+/* Verify that PLATFORM_XDC was set as an environment variable */
+var xdcplat = "" + java.lang.System.getenv("PLATFORM_XDC");
+if (xdcplat=="null" || xdcplat==""){
+    print("Warning: XDC_PLATFORM not found. Verify that PLATFORM_XDC "
+        + "is set correctly in Platform.xdc.");
+}
+
+var C64P = xdc.useModule('ti.targets.C64P');
+C64P.rootDir = codegen;
+C64P.platform = xdcplat;
+
+var C674 = xdc.useModule('ti.targets.C674');
+C674.rootDir = codegen;
+C674.platform = xdcplat;
+
+/* User passes in $(CROSS_COMPILE) where $(CROSS_COMPILE)gcc is their compiler
+   Then the TOOLDIR and LONGNAME are derived based on a regex of CROSS_COMPILE
+*/
+var crosscompile = "" + java.lang.System.getenv("CROSS_COMPILE");
+
+var tooldir = "";
+var longName = "";
+
+/* Search CROSS_COMPILE for bin/ If only 1 bin/ is found, set the tooldir to
+   the path prior to bin/ and the prefix to "bin/" + remainder of path,
+   else leave the tooldir as "" and set the LONGNAME to the full CROSS_COMPILE
+   path
+*/
+var regex = new RegExp("bin/");
+var find = crosscompile.split( regex );
+
+if (find[0]!=crosscompile && find.length==2) {
+    tooldir = find[0];
+    longName = "bin/" + find[1] + "gcc";
+} else {
+    longName = crosscompile + "gcc";
+}
+
+/* location of the GCC Arm9 tools */
+var GCArmv5T = xdc.useModule('gnu.targets.arm.GCArmv5T');
+GCArmv5T.LONGNAME = longName;
+GCArmv5T.platform = java.lang.System.getenv("PLATFORM_XDC");
+GCArmv5T.rootDir = tooldir;
+
+Build.targets = [
+];
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/include/C6Accel.h c6accel_1_00_00_04_async/dsp/alg/include/C6Accel.h
--- c6accel_1_00_00_04_async0/dsp/alg/include/C6Accel.h	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/dsp/alg/include/C6Accel.h	2010-08-14 17:17:16.000000000 -0500
@@ -16,7 +16,9 @@
 /*Include files for the DSP SW Libraries*/
 #include "dsplib64plus.h"
 #include "imglib64plus.h"
-#include "C64PLIBPLUS.h" 
+#include "C64PLIBPLUS.h" 
+/* Added by Pramod */
+#include "VLIB_prototypes.h"
 
 /* Defining INLINE_C to activate inlining for fastrts functions */
 #define INLINE_C
@@ -45,7 +47,8 @@
 /*        04 : ANALYTICS Library                                                   */
 /*        05 : MEDICAL Library                                                     */
 /*        06 : POWER CONTROL Library                                               */
-/*        07 : AUDIO SPEECH Library                                                */
+/*        07 : AUDIO SPEECH Library                                                */
+/*        08 : VISION Library       (Added by Pramod)                              */
 /*   15-0: bits indicate function specific ID within the library                   */
 /*                                                                                 */
 /*                                                                                 */
@@ -66,7 +69,8 @@
 #define ANALYTICSLIB_FXN_ID                 0x00000004
 #define MEDICALLIB_FXN_ID                   0x00000005
 #define PWRCNTRLLIB_FXN_ID                  0x00000006
-#define AUDSPECHLIB_FXN_ID                  0x00000007
+#define AUDSPECHLIB_FXN_ID                  0x00000007
+#define VLIB_FXN_ID                         0x00000008   /* Added by Pramod */
 
 /* Function type describes the nature of function */
 #define FXNTYP_TAG_SHIFT                    0x00000010
@@ -231,7 +235,8 @@
 /*Additional Image Lib kernels*/
 #define YUV420PL_TO_RGB565_FXN_ID           0x00000057
 #define YCBCR422PL16_RGB565_FXN_ID          0x00000058
-#define YUV420PL16_TO_RGB565_FXN_ID         0x00000059
+#define YUV420PL16_TO_RGB565_FXN_ID         0x00000059
+
 
 /* Optimized versions of kernels in standard TI libraries */
 #define MEDIAN_3X3_8_FRAME_FXN_ID           0x0000005A
@@ -244,7 +249,10 @@
 #define CORR_3X3_I8_C8_FRAME_FXN_ID         0x00000061
 #define YCBCR422SP_TO_YCBCR420PL_FXN_ID     0x00000062
 #define YCBCR422SP_TO_YCBCR422ILE_FXN_ID    0x00000063
-#define YCBCR422PL_TO_YCBCR422SP_FXN_ID     0x00000064
+#define YCBCR422PL_TO_YCBCR422SP_FXN_ID     0x00000064
+
+/*New added kernel of sobel */
+#define SOBEL_3X3_8_16_FXN_ID               0x00000065  /*Added by Pramod */
 
 /**********************************************************
 *MATHLIB kernels for C64X devices
@@ -324,7 +332,17 @@
 #define SINDP_FXN_ID                        0x00000219
 #define SINSP_FXN_ID                        0x0000021A
 #define SQRTDP_FXN_ID                       0x0000021B
-#define SQRT_FXN_ID                         0x0000021C 
+#define SQRT_FXN_ID                         0x0000021C 
+
+/* VLIB function ids */
+#define INTEGRALIMAGE_8_FXN_ID              0x00000001    /* Added by Pramod */
+
+/*  Other IMGLIB fxn IDs  */
+#define RGB_TO_Y_FXN_ID			    0x00000001    /* Added by Pramod */
+
+/*  Other DSPLIB fxn IDs  */
+#define DFT_F_FXN_ID			    0x00000001    /* Added by Pramod */
+
 /****************************************************************************
 **                        END OF FILE                                      ** 
 *****************************************************************************/
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/include/iC6Accel_ti.h c6accel_1_00_00_04_async/dsp/alg/include/iC6Accel_ti.h
--- c6accel_1_00_00_04_async0/dsp/alg/include/iC6Accel_ti.h	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/dsp/alg/include/iC6Accel_ti.h	2010-08-15 23:48:17.000000000 -0500
@@ -13,7 +13,11 @@
 *******************************************************************************/
 /* Include files */
 #include <ti/xdais/xdas.h>
-#include <ti/xdais/dm/iuniversal.h>
+#include <ti/xdais/dm/iuniversal.h>
+
+#include "cxtypes.h" 
+
+
 
 #ifndef ti_sdo_codecs_C6Accel_C6ACCEL_TI_
 #define ti_sdo_codecs_C6Accel_C6ACCEL_TI_
@@ -39,7 +43,8 @@
 *         ** 0x04 : ANALYTICS Library                                                       *       
 *         ** 0x05 : MEDICAL Library                                                         *
 *         ** 0x06 : POWER CONTROL Library                                                   *
-*         ** 0x07 : AUDIO SPEECH Library                                                    *
+*         ** 0x07 : AUDIO SPEECH Library                                                    *
+*         ** 0x08 : VISION Library       (Added by Pramod)                                  *
 *    * 15-0 bits are used to identify the function within the library                       *
 *                                                                                           *
 *********************************************************************************************/
@@ -231,7 +236,10 @@
 #define IMG_CORR_3X3_I8_C8_FRAME_FXN_ID         0x01020061
 #define IMG_YCBCR422SP_TO_YCBCR420PL_FXN_ID     0x01020062
 #define IMG_YCBCR422SP_TO_YCBCR422ILE_FXN_ID    0x01020063
-#define IMG_YCBCR422PL_TO_YCBCR422SP_FXN_ID     0x01020064
+#define IMG_YCBCR422PL_TO_YCBCR422SP_FXN_ID     0x01020064
+
+/* Additional sobel kernel */
+#define IMG_SOBEL_3X3_8_16_FXN_ID         0x01020065  /* Added by Pramod */
 
 /************************************************************************/  
 /*                                                                      */
@@ -349,7 +357,34 @@
 /*     23-16 bits   Function type/Library ID : 0x07 (AUDSPECHLIB)      */  
 /*     15-0 bits are used to identify the function within the library  */        
 /**********************************************************************/
-/* To be added in Future Releases */
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                     */
+/*           VISION Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)               */           
+/*     23-16 bits   Function type/Library ID : 0x08 (VLIB)             */  
+/*     15-0 bits are used to identify the function within the library  */        
+/**********************************************************************/
+#define VLIB_INTEGRALIMAGE_8_FXN_ID       0x01080001  /* Added by Pramod */
+
+/**********************************************************************/  
+/*                                                                    */
+/*     Other Image Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x02 (OTHER)           */           
+/*     23-16 bits   Function type/Library ID : 0x02 (IMGLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define IMG_RGB_TO_Y_FXN_ID  		  0x02020001 /*Added by Pramod */
+
+/**********************************************************************/  
+/*                                                                    */
+/*     Other DSP Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x02 (OTHER)           */           
+/*     23-16 bits   Function type/Library ID : 0x01 (DSPLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define DSP_DFT_F_FXN_ID  		  0x02010001 /*Added by Pramod */
 
 /******************************************************************
 *  Constants to be shared by the codec and the application code   *
@@ -401,7 +436,34 @@
 *                                                                       *
 *************************************************************************/
 #define IUNIVERSAL_EPARAMFAIL IUNIVERSAL_EFAIL-5
-#define IUNIVERSAL_EFXNIDFAIL IUNIVERSAL_EFAIL-6
+#define IUNIVERSAL_EFXNIDFAIL IUNIVERSAL_EFAIL-6
+
+/************************************************************************
+* Defines Matrix type and number of channels for OpenCV Matrix.         *
+* Also defines method to extract type and cnannels of matrix of image   *
+*									*
+*************************************************************************/
+#define CN_MAX     64
+#define CN_SHIFT   3
+#define DEPTH_MAX  (1 << CN_SHIFT)
+#define MAT_CN_MASK          ((CN_MAX - 1) << CN_SHIFT)
+#define MAT_CN(flags)        ((((flags) & MAT_CN_MASK) >> CN_SHIFT) + 1)
+#define MAT_TYPE_MASK        (DEPTH_MAX*CN_MAX - 1)
+#define MAT_TYPE(flags)      ((flags) & MAT_TYPE_MASK)
+
+/************************************************************************
+* Defines different DFT Types for OpenCV                                *
+* Also defines method to extract type and cnannels of matrix of image   *
+*									*
+*************************************************************************/
+#define DXT_FORWARD  0
+#define DXT_INVERSE  1
+#define DXT_SCALE    2 /* divide result by size of array */
+#define DXT_INV_SCALE (CV_DXT_INVERSE + CV_DXT_SCALE)
+#define DXT_INVERSE_SCALE CV_DXT_INV_SCALE
+#define DXT_ROWS     4 /* transform each row individually */
+#define DXT_MUL_CONJ 8 /* conjugate the second argument of cvMulSpectrums */
+#define DXT_INVERSE_ROWS 16
     
 /************************* Common input structures ********************************************
 *  Fxn_struct:
@@ -410,7 +472,8 @@
 *  Every function in the API call will be contained in a seperate 
 *  fxn_struct. Multiple function calls are made using a single API call 
 *  by passing an array of Fxn_stuct in the extended Input Argument structure (IC6Accel_InArgs) 
-************************************************************************************************/
+************************************************************************************************/
+
 typedef struct{
                 int FxnID;
                 int  Param_ptr_offset;                       // This is the offset of the param structure within overall inArgs
@@ -958,7 +1021,15 @@
                                       unsigned int outdata_OutArrID1; 
                                       int Col;
                                       int Row;
-                                     }IMG_sobel_3x3_8_Params;
+                                     }IMG_sobel_3x3_8_Params;
+/* This struct is added by Pramod */
+/* Function call : void IMG_sobel_3x3_8_16(const unsigned char *in_data, unsigned short *out_data, short cols, short rows)*/
+typedef struct IMG_sobel_3x3_8_16_Params{
+                                      unsigned int indata_InArrID1;
+                                      unsigned int outdata_OutArrID1; 
+                                      int Col;
+                                      int Row;
+                                     }IMG_sobel_3x3_8_16_Params;
 
 /* Function call : void IMG_sobel_3x3_16s (const short *restrict in, const short *restrict out, short cols,
                                            short rows)*/
@@ -1907,8 +1978,66 @@
                             unsigned int z_InArrID1;
                             unsigned int OutArrID1;
                             unsigned int   n;
-                           }sqrtsp_Params;
-
+                           }sqrtsp_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Vision Library functions                    */
+/*                     Added by Pramod                                               */
+/*************************************************************************************/
+
+/* Function Call: int VLIB_integralImage8(unsigned char* restrict pIn,unsigned short  inCols,unsigned short  inRows,unsigned int* restrict pLastLine,   
+															unsigned int* restrict pOut)*/
+typedef struct VLIB_integralImage8_Params{
+                                         unsigned int pIn_InArrID1;         /* Input Image inCols x inRows */
+                                         unsigned short  inCols;            /* Number of inCols */
+					 unsigned short  inRows;            /* Number of inRowss */
+                                         unsigned int pLastLine_InArrID2;   /* 32-bit carry-over buffer */
+                                         unsigned int pOut_OutArrID1;       /* 32-bit output buffer */
+                                         }VLIB_integralImage8_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Other IMG Library functions                */
+/*                 Functionality Added by Pramod                                     */
+/*		   Kernel Provided by Gagan					     */
+/*************************************************************************************/
+
+/* Function Call: int IMG_RGB_To_Y(unsigned char* restrict src, unsigned char * restrict dst, unsigned int count)*/
+
+typedef struct IMG_RGB_To_Y_Params{
+				  unsigned int src_InArrID1;              /* Input RGB image         */
+				  unsigned int dst_OutArrID1;             /* Output greyscale image  */
+				  unsigned int count;			  /* Total Pixels	     */
+				  }IMG_RGB_To_Y_Params;
+
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Other DSP Library functions                */
+/*                 Functionality Added by Pramod                                     */
+/*		   								     */
+/*************************************************************************************/
+
+/* Function Call: int C6accel_DSP_dft_f(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_src,       
+                          unsigned char * restrict ptr_dst,       
+			  int cols, int rows,                     
+			  int srcMatFlag,		         
+			  int dstMatFlag,			  
+			  int dxtType,				 
+			  int nonZeroRows, 			  
+			  unsigned char *restrict pWorkingBuf,    
+                          unsigned char *restrict pWorkingBuf2)                         */
+
+typedef struct DSP_dft_f_Params{
+				  unsigned int src_InArrID1;              /* Pointer to input image */
+				  unsigned int dst_OutArrID1;             /* Pointer to Greyscale output image    */
+				  int dxtType;				  /* Type of action to take */ 
+				  int nonZeroRows; 			  /* Count of non-zero rows */
+				  IplImage src;
+				  IplImage dst;
+				  }DSP_dft_f_Params;
+
+			  
+			  
 /******************************************************************************
  *  ======== C6ACCEL_TI_IC6ACCEL ========
  *  Our implementation of the IUNIVERSAL interface
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/include/iC6Accel_ti.h~ c6accel_1_00_00_04_async/dsp/alg/include/iC6Accel_ti.h~
--- c6accel_1_00_00_04_async0/dsp/alg/include/iC6Accel_ti.h~	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/alg/include/iC6Accel_ti.h~	2010-08-15 02:05:05.000000000 -0500
@@ -0,0 +1,2061 @@
+/*******************************************************************************
+**+--------------------------------------------------------------------------+**
+ *                                                                            **
+ * Copyright (c) 2010, Texas Instruments Incorporated                         **
+ * All rights reserved.                                                       **
+ *                                                                            **
+**+--------------------------------------------------------------------------+**/
+/*******************************************************************************
+ *  ======== iC6Accel_ti.h ========                                           **
+ *   Application-Codec interface header file                                  **
+ *   Defines Function IDs, Input arguments and parameter structures           **
+ *   for kernels in C6Accel                                                   **
+*******************************************************************************/
+/* Include files */
+#include <ti/xdais/xdas.h>
+#include <ti/xdais/dm/iuniversal.h>
+
+#include "cxtypes.h" 
+
+#include "cxerror.h"
+
+#include "cxcore.h"
+#include "cvver.h"
+
+
+#ifndef ti_sdo_codecs_C6Accel_C6ACCEL_TI_
+#define ti_sdo_codecs_C6Accel_C6ACCEL_TI_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Codec engine allows passing 16 inbut and output buffers
+limiting the number of function call in C6Accel to 16 in each universal
+process call*/ 
+#define   MAX_FXN_CALLS 16
+
+/********************************************************************************************
+*    Function IDs for library functions                                                     *
+*                                                                                           *
+*    Format of the function Id uses                                                         *
+*    * 31-24 bits are used to identify the vendor (Default vendor TI with vendor code:0x01) *
+*    * 23-16 bits are used to identify the type of function                                 * 
+*         ** 0x01 : DSP library                                                             *
+*         ** 0x02 : IMAGE Library                                                           *
+*         ** 0x03 : MATH Library                                                            *
+*         ** 0x04 : ANALYTICS Library                                                       *       
+*         ** 0x05 : MEDICAL Library                                                         *
+*         ** 0x06 : POWER CONTROL Library                                                   *
+*         ** 0x07 : AUDIO SPEECH Library                                                    *
+*         ** 0x08 : VISION Library       (Added by Pramod)                                  *
+*    * 15-0 bits are used to identify the function within the library                       *
+*                                                                                           *
+*********************************************************************************************/
+/* Common Null ID */
+#define NULL_INDEX                        0x00000000
+
+/****************************************************************************/  
+/*                                                                    */
+/*           DSP Library functions                                    */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)              */           
+/*     23-16 bits   Function type/Library ID : 0x01 (DSPLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define DSP_FFT16x16_FXN_ID               0x01010000
+#define DSP_IFFT16x16_FXN_ID              0x01010001
+#define DSP_MAT_MUL_FXN_ID                0x01010002
+#define DSP_FIR_GEN_FXN_ID                0x01010003
+#define DSP_AUTOCOR_FXN_ID                0x01010004
+#define DSP_FIRLMS2_FXN_ID                0x01010005
+#define DSP_FFT16x16_IMRE_FXN_ID          0x01010006
+#define DSP_FFT16x16R_FXN_ID              0x01010007
+#define DSP_FFT16x32_FXN_ID               0x01010008
+#define DSP_FFT32x32_FXN_ID               0x01010009
+#define DSP_FFT32x32S_FXN_ID              0x0101000A
+#define DSP_IFFT16x16_IMRE_FXN_ID         0x0101000B
+#define DSP_IFFT16x32_FXN_ID              0x0101000C
+#define DSP_IFFT32x32_FXN_ID              0x0101000D
+#define DSP_FIR_CPLX_FXN_ID               0x0101000E
+#define DSP_FIR_CPLX_HM4X4_FXN_ID         0x0101000F
+#define DSP_FIR_GEN_HM17_RA8X8_FXN_ID     0x01010010
+#define DSP_FIR_R4_FXN_ID                 0x01010011
+#define DSP_FIR_R8_FXN_ID                 0x01010012
+#define DSP_FIR_R8_HM16_RM8A8X8_FXN_ID    0x01010013
+#define DSP_FIR_SYM_FXN_ID                0x01010014
+#define DSP_IIR_FXN_ID                    0x01010015
+#define DSP_IIR_LAT_FXN_ID                0x01010016
+#define DSP_DOTP_SQR_FXN_ID               0x01010017
+#define DSP_DOTPROD_FXN_ID                0x01010018
+#define DSP_MAXVAL_FXN_ID                 0x01010019
+#define DSP_MAXIDX_FXN_ID                 0x0101001A
+#define DSP_MINVAL_FXN_ID                 0x0101001B
+#define DSP_MUL32_FXN_ID                  0x0101001C
+#define DSP_NEG32_FXN_ID                  0x0101001D
+#define DSP_RECIP16_FXN_ID                0x0101001E
+#define DSP_VECSUMSQ_FXN_ID               0x0101001F
+#define DSP_W_VEC_FXN_ID                  0x01010020
+#define DSP_MAT_TRANS_FXN_ID              0x01010021
+#define DSP_BEXP_FXN_ID                   0x01010022
+#define DSP_BLK_ESWAP16_FXN_ID            0x01010023
+#define DSP_BLK_ESWAP32_FXN_ID            0x01010024
+#define DSP_BLK_ESWAP64_FXN_ID            0x01010025
+#define DSP_BLK_MOVE_FXN_ID               0x01010026
+#define DSP_FLTOQ15_FXN_ID                0x01010027
+#define DSP_MINERROR_FXN_ID               0x01010028
+#define DSP_Q15tOFL_FXN_ID                0x01010029
+
+
+/* Floating point DSPLIB kernels */
+#define DSPF_SP_FFTSPXSP_FXN_ID           0x01010400
+#define DSPF_SP_IFFTSPXSP_FXN_ID          0x01010401
+#define DSPF_SP_DOTPROD_FXN_ID            0x01010402
+#define DSPF_SP_AUTOCOR_FXN_ID            0x01010403
+#define DSPF_SP_FIR_GEN_FXN_ID            0x01010404
+#define DSPF_SP_FIR_CPLX_FXN_ID           0x01010405
+#define DSPF_SP_MAT_MUL_FXN_ID            0x01010406
+#define DSPF_SP_MAT_TRANS_FXN_ID          0x01010407
+#define DSPF_SP_IIR_FXN_ID                0x01010408
+#define DSPF_SP_CONV_FXN_ID               0x01010409
+#define DSPF_SP_VECMUL_FXN_ID             0x0101040A
+#define DSPF_SP_VECRECIP_FXN_ID           0x0101040B
+#define DSPF_SP_VECSUM_SQ_FXN_ID          0x0101040C
+#define DSPF_SP_W_VEC_FXN_ID              0x0101040D
+#define DSPF_SP_BIQUAD_FXN_ID             0x0101040E
+#define DSPF_SP_MAT_MUL_CPLX_FXN_ID       0x0101040F
+
+/**********************************************************************/  
+/*                                                                    */
+/*           Image Library functions                                  */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)              */           
+/*     23-16 bits   Function type/Library ID : 0x02 (IMGLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define IMG_BOUNDARY_8_FXN_ID             0x01020000
+#define IMG_BOUNDARY_16S_FXN_ID           0x01020001
+#define IMG_CLIPPING_16S_FXN_ID           0x01020002
+#define IMG_YC_DEMUX_BE16_16_FXN_ID       0x01020003
+#define IMG_YC_DEMUX_LE16_16_FXN_ID       0x01020004
+#define IMG_DILATE_BIN_FXN_ID             0x01020005
+#define IMG_ERODE_BIN_FXN_ID              0x01020006
+#define IMG_ERRDIF_BIN_8_FXN_ID           0x01020007
+#define IMG_ERRDIF_BIN_16_FXN_ID          0x01020008
+#define IMG_HISTOGRAM_8_FXN_ID            0x01020009
+#define IMG_HISTOGRAM_16_FXN_ID           0x0102000A
+#define IMG_MEDIAN_3X3_8_FXN_ID           0x0102000B
+#define IMG_PERIMETER_8_FXN_ID            0x0102000C
+#define IMG_PERIMETER_16_FXN_ID           0x0102000D
+#define IMG_PIX_EXPAND_FXN_ID             0x0102000E
+#define IMG_PIX_SAT_FXN_ID                0x0102000F
+#define IMG_SOBEL_3X3_8_FXN_ID            0x01020010
+#define IMG_SOBEL_3X3_16S_FXN_ID          0x01020011
+#define IMG_SOBEL_3X3_16_FXN_ID           0x01020012
+#define IMG_SOBEL_5X5_16S_FXN_ID          0x01020013
+#define IMG_SOBEL_7X7_16S_FXN_ID          0x01020014
+#define IMG_THR_GT2MAX_8_FXN_ID           0x01020015
+#define IMG_THR_GT2MAX_16_FXN_ID          0x01020016
+#define IMG_THR_GT2THR_8_FXN_ID           0x01020017
+#define IMG_THR_GT2THR_16_FXN_ID          0x01020018
+#define IMG_THR_LE2MIN_8_FXN_ID           0x01020019
+#define IMG_THR_LE2MIN_16_FXN_ID          0x0102001A
+#define IMG_THR_LE2THR_8_FXN_ID           0x0102001B
+#define IMG_THR_LE2THR_16_FXN_ID          0x0102001C
+#define IMG_YCBCR422P_RGB565_FXN_ID       0x0102001D
+#define IMG_CONV_3X3_I8_C8S_FXN_ID        0x0102001E
+#define IMG_CONV_3X3_I16S_C16S_FXN_ID     0x0102001F
+#define IMG_CONV_3X3_I16_C16S_FXN_ID      0x01020020
+#define IMG_CONV_5X5_I8_C8S_FXN_ID        0x01020021
+#define IMG_CONV_5X5_I16S_C16S_FXN_ID     0x01020022
+#define IMG_CONV_5X5_I8_C16S_FXN_ID       0x01020023
+#define IMG_CONV_7X7_I8_C8S_FXN_ID        0x01020024
+#define IMG_CONV_7X7_I16S_C16S_FXN_ID     0x01020025
+#define IMG_CONV_7X7_I8_C16S_FXN_ID       0x01020026
+#define IMG_CONV_11X11_I8_C8S_FXN_ID      0x01020027
+#define IMG_CONV_11X11_I16S_C16S_FXN_ID   0x01020028
+#define IMG_CORR_3X3_I8_C16S_FXN_ID       0x01020029
+#define IMG_CORR_3X3_I16S_C16S_FXN_ID     0x0102002A
+#define IMG_CORR_3X3_I8_C8_FXN_ID         0x0102002B
+#define IMG_CORR_3X3_I16_C16S_FXN_ID      0x0102002C
+#define IMG_CORR_5X5_I16S_C16S_FXN_ID     0x0102002D
+#define IMG_CORR_11X11_I16S_C16S_FXN_ID   0x0102002E
+#define IMG_CORR_11X11_I8_C16S_FXN_ID     0x0102002F
+#define IMG_CORR_GEN_I16S_C16S_FXN_ID     0x01020030
+#define IMG_CORR_GEN_IQ_FXN_ID            0x01020031
+#define IMG_MEDIAN_3X3_16S_FXN_ID         0x01020032
+#define IMG_MEDIAN_3X3_16_FXN_ID          0x01020033
+#define IMG_YC_DEMUX_BE16_8_FXN_ID        0x01020034
+#define IMG_YC_DEMUX_LE8_C_FXN_ID         0x01020035
+#define IMG_FDCT_8X8_FXN_ID               0x01020036
+#define IMG_IDCT_8X8_12Q4_FXN_ID          0x01020037
+#define IMG_MAD_8X8_FXN_ID                0x01020038
+#define IMG_MAD_16X16_FXN_ID              0x01020039
+#define IMG_MPEG2_VLD_INTRA_FXN_ID        0x0102003A
+#define IMG_MPEG2_VLD_INTER_FXN_ID        0x0102003B
+#define IMG_QUANTIZE_FXN_ID               0x0102003C
+#define IMG_SAD_8X8_FXN_ID                0x0102003D
+#define IMG_SAD_16X16_FXN_ID              0x0102003E
+#define IMG_WAVE_HORZ_FXN_ID              0x0102003F
+#define IMG_WAVE_VERT_FXN_ID              0x01020040
+
+/*Low level IMGLIB functions*/
+#define IMG_MULS_16S_FXN_ID               0x01020041
+#define IMG_MULS_8_FXN_ID                 0x01020042
+#define IMG_ADDS_16S_FXN_ID               0x01020043
+#define IMG_ADDS_8_FXN_ID                 0x01020044
+#define IMG_SUBS_16S_FXN_ID               0x01020045
+#define IMG_SUBS_8_FXN_ID                 0x01020046
+#define IMG_NOT_16_FXN_ID                 0x01020047
+#define IMG_NOT_8_FXN_ID                  0x01020048
+#define IMG_ANDS_16_FXN_ID                0x01020049
+#define IMG_ANDS_8_FXN_ID                 0x0102004A
+#define IMG_ORS_16_FXN_ID                 0x0102004B
+#define IMG_ORS_8_FXN_ID                  0x0102004C
+#define IMG_AND_16_FXN_ID                 0x0102004D 
+#define IMG_AND_8_FXN_ID                  0x0102004E
+#define IMG_OR_16_FXN_ID                  0x0102004F 
+#define IMG_OR_8_FXN_ID                   0x01020050
+#define IMG_MUL_16S_FXN_ID                0x01020051
+#define IMG_MUL_8_FXN_ID                  0x01020052
+#define IMG_ADD_16S_FXN_ID                0x01020053
+#define IMG_ADD_8_FXN_ID                  0x01020054
+#define IMG_SUB_16S_FXN_ID                0x01020055
+#define IMG_SUB_8_FXN_ID                  0x01020056
+
+/*Additional IMGLIB KERNELS*/
+#define IMG_YUV420PL_RGB565_FXN_ID        0x01020057
+#define IMG_YCBCR422PL16_RGB565_FXN_ID    0x01020058
+#define IMG_YUV420PL16_RGB565_FXN_ID      0x01020059
+
+
+/* Additional Frame based IMG kernels for better performance */
+#define IMG_MEDIAN_3X3_8_FRAME_FXN_ID     0x0102005A
+#define IMG_MEDIAN_3X3_16S_FRAME_FXN_ID   0x0102005B
+#define IMG_MEDIAN_3X3_16_FRAME_FXN_ID    0x0102005C
+
+/* Optimized version of existing IMG lib kernels */
+#define IMG_CONV_3X3_I8_C8S_FRAME_FXN_ID        0x0102005D
+#define IMG_CONV_3X3_I16S_C16S_FRAME_FXN_ID     0x0102005E
+#define IMG_CORR_3X3_I8_C16S_FRAME_FXN_ID       0x0102005F
+#define IMG_CORR_3X3_I16S_C16S_FRAME_FXN_ID     0x01020060
+#define IMG_CORR_3X3_I8_C8_FRAME_FXN_ID         0x01020061
+#define IMG_YCBCR422SP_TO_YCBCR420PL_FXN_ID     0x01020062
+#define IMG_YCBCR422SP_TO_YCBCR422ILE_FXN_ID    0x01020063
+#define IMG_YCBCR422PL_TO_YCBCR422SP_FXN_ID     0x01020064
+
+/* Additional sobel kernel */
+#define IMG_SOBEL_3X3_8_16_FXN_ID         0x01020065  /* Added by Pramod */
+
+/************************************************************************/  
+/*                                                                      */
+/*           MATH Library functions                                     */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)                */           
+/*     23-16 bits   Function type/Library ID : 0x03 (IQMATHLIB)         */  
+/*     15-0 bits are used to identify the function within the library   */        
+/************************************************************************/
+#define MATH_IQNMPY_FXN_ID                0x01030000
+#define MATH_IQNSQRT_FXN_ID               0x01030001
+#define MATH_IQNSIN_FXN_ID                0x01030002
+#define MATH_IQNCOS_FXN_ID                0x01030003
+#define MATH_IQNDIV_FXN_ID                0x01030004
+#define MATH_IQNATAN2_FXN_ID              0x01030005
+#define MATH_IQNEXP_FXN_ID                0x01030006
+#define MATH_IQNLOG_FXN_ID                0x01030007
+#define MATH_IQNRMPY_FXN_ID               0x01030008
+#define MATH_IQNRSMPY_FXN_ID              0x01030009
+#define MATH_IQNASIN_FXN_ID               0x0103000A
+#define MATH_IQNACOS_FXN_ID               0x0103000B
+#define MATH_IQNSINPU_FXN_ID              0x0103000C
+#define MATH_IQNCOSPU_FXN_ID              0x0103000D
+#define MATH_IQNATAN2PU_FXN_ID            0x0103000E
+#define MATH_IQNMPYIQX_FXN_ID             0x0103000F
+#define MATH_IQNMPYI32INT_FXN_ID          0x01030010
+#define MATH_IQNMPYI32FRAC_FXN_ID         0x01030011
+#define MATH_IQNABS_FXN_ID                0x01030012
+#define MATH_IQNTOF_FXN_ID                0x01030013
+#define MATH_IQTOIQN_FXN_ID               0x01030014
+#define MATH_IQNPOW_FXN_ID                0x01030015
+#define MATH_IQNISQRT_FXN_ID              0x01030016
+#define MATH_IQNMAG_FXN_ID                0x01030017
+
+/* FASTRTS LIB kernels for C64x devices */
+#define MATH_ADDSP_FXN_ID                 0x01030018
+#define MATH_SUBSP_FXN_ID                 0x01030019
+#define MATH_MPYSP_FXN_ID                 0x0103001A
+#define MATH_DIVSP_FXN_ID                 0x0103001B
+#define MATH_RECIPSP_FXN_ID               0x0103001C
+#define MATH_INTSP_FXN_ID                 0x0103001D
+#define MATH_SPINT_FXN_ID                 0x0103001E
+#define MATH_SPUINT_FXN_ID                0x0103001F
+#define MATH_SQRTSP_FXN_ID                0x01030020
+#define MATH_UINTSP_FXN_ID                0x01030021
+
+/*Format conversion kernels in IQMATH lib*/
+#define MATH_FTOIQN_FXN_ID                0x01030022
+#define MATH_IQN_FXN_ID                   0x01030023
+#define MATH_IQXTOIQY_FXN_ID              0x01030024
+#define MATH_IQNINT_FXN_ID                0x01030025
+#define MATH_IQNFRAC_FXN_ID               0x01030026
+
+/* Fast RTS functions from 674x math library */
+#define MATH_ATANDP_FXN_ID                0x01030200
+#define MATH_ATANSP_FXN_ID                0x01030201
+#define MATH_ATAN2DP_FXN_ID               0x01030202
+#define MATH_ATAN2SP_FXN_ID               0x01030203
+#define MATH_COSDP_FXN_ID                 0x01030204
+#define MATH_COSSP_FXN_ID                 0x01030205
+#define MATH_DIVDP_FXN_ID                 0x01030206
+#define MATH_EXPDP_FXN_ID                 0x01030207
+#define MATH_EXPSP_FXN_ID                 0x01030208
+#define MATH_EXP2DP_FXN_ID                0x01030209
+#define MATH_EXP2SP_FXN_ID                0x0103020A
+#define MATH_EXP10DP_FXN_ID               0x0103020B
+#define MATH_EXP10SP_FXN_ID               0x0103020C
+#define MATH_LOGDP_FXN_ID                 0x0103020D
+#define MATH_LOGSP_FXN_ID                 0x0103020E
+#define MATH_LOG2DP_FXN_ID                0x0103021F
+#define MATH_LOG2SP_FXN_ID                0x01030220
+#define MATH_LOG10DP_FXN_ID               0x01030211
+#define MATH_LOG10SP_FXN_ID               0x01030212
+#define MATH_POWDP_FXN_ID                 0x01030213
+#define MATH_POWSP_FXN_ID                 0x01030214
+#define MATH_RECIPF_FXN_ID                0x01030215
+#define MATH_RECIPDP_FXN_ID               0x01030216
+#define MATH_RSQRTDP_FXN_ID               0x01030217
+#define MATH_RSQRTSP_FXN_ID               0x01030218
+#define MATH_SINDP_FXN_ID                 0x01030219
+#define MATH_SINSP_FXN_ID                 0x0103021A
+#define MATH_SQRTDP_FXN_ID                0x0103021B
+#define MATH_SQRT_FXN_ID                  0x0103021C
+
+/**********************************************************************/  
+/*                                                                    */
+/*           ANALYTICS Library functions                              */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)              */           
+/*     23-16 bits   Function type/Library ID : 0x04 (ANALYTICSLIB)    */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                    */
+/*           MEDICAL Library functions                              */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)              */           
+/*     23-16 bits   Function type/Library ID : 0x05 (MEDICALLIB)    */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                     */
+/*           POWER CONTROL Library functions                           */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)               */           
+/*     23-16 bits   Function type/Library ID : 0x06 (PWRCNTRLLIB)      */  
+/*     15-0 bits are used to identify the function within the library  */        
+/**********************************************************************/
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                     */
+/*           AUDIO SPEECH Library functions                            */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)               */           
+/*     23-16 bits   Function type/Library ID : 0x07 (AUDSPECHLIB)      */  
+/*     15-0 bits are used to identify the function within the library  */        
+/**********************************************************************/
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                     */
+/*           VISION Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)               */           
+/*     23-16 bits   Function type/Library ID : 0x08 (VLIB)             */  
+/*     15-0 bits are used to identify the function within the library  */        
+/**********************************************************************/
+#define VLIB_INTEGRALIMAGE_8_FXN_ID       0x01080001  /* Added by Pramod */
+
+/**********************************************************************/  
+/*                                                                    */
+/*     Other Image Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x02 (OTHER)           */           
+/*     23-16 bits   Function type/Library ID : 0x02 (IMGLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define IMG_RGB_TO_Y_FXN_ID  		  0x02020001 /*Added by Pramod */
+
+/**********************************************************************/  
+/*                                                                    */
+/*     Other DSP Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x02 (OTHER)           */           
+/*     23-16 bits   Function type/Library ID : 0x01 (DSPLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define DSP_DFT_F_FXN_ID  		  0x02010001 /*Added by Pramod */
+
+/******************************************************************
+*  Constants to be shared by the codec and the application code   *
+*******************************************************************/
+/* Input buffer ID */
+ #define INBUF0  0
+ #define INBUF1  1
+ #define INBUF2  2
+ #define INBUF3  3
+ #define INBUF4  4
+ #define INBUF5  5
+ #define INBUF6  6
+ #define INBUF7  7
+ #define INBUF8  8
+ #define INBUF9  9
+ #define INBUF10 10
+ #define INBUF11 11
+ #define INBUF12 12
+ #define INBUF13 13
+ #define INBUF14 14
+ #define INBUF15 15
+
+
+/* Output buffer ID  */
+ #define OUTBUF0  0
+ #define OUTBUF1  1
+ #define OUTBUF2  2
+ #define OUTBUF3  3
+ #define OUTBUF4  4
+ #define OUTBUF5  5
+ #define OUTBUF6  6
+ #define OUTBUF7  7
+ #define OUTBUF8  8
+ #define OUTBUF9  9
+ #define OUTBUF10 10
+ #define OUTBUF11 11
+ #define OUTBUF12 12
+ #define OUTBUF13 13
+ #define OUTBUF14 14
+ #define OUTBUF15 15
+
+/************************************************************************ 
+* Error check extention is introduced in return type of the Universal   *
+* Process call by defining the following error msg                      *
+* Error codes                                                           *
+*                                                                       *
+*   *  IUNIVERSAL_EPARAMFAIL : Error in parameters passed               *
+*   *  IUNIVERSAL_EFXNIDFAIL : Error on Function ID or NULL ID passed   *
+*                                                                       *
+*************************************************************************/
+#define IUNIVERSAL_EPARAMFAIL IUNIVERSAL_EFAIL-5
+#define IUNIVERSAL_EFXNIDFAIL IUNIVERSAL_EFAIL-6
+
+/************************************************************************
+* Defines Matrix type and number of channels for OpenCV Matrix.         *
+* Also defines method to extract type and cnannels of matrix of image   *
+*									*
+*************************************************************************/
+#define CN_MAX     64
+#define CN_SHIFT   3
+#define DEPTH_MAX  (1 << CN_SHIFT)
+#define MAT_CN_MASK          ((CN_MAX - 1) << CN_SHIFT)
+#define MAT_CN(flags)        ((((flags) & MAT_CN_MASK) >> CN_SHIFT) + 1)
+#define MAT_TYPE_MASK        (DEPTH_MAX*CN_MAX - 1)
+#define MAT_TYPE(flags)      ((flags) & MAT_TYPE_MASK)
+
+/************************************************************************
+* Defines different DFT Types for OpenCV                                *
+* Also defines method to extract type and cnannels of matrix of image   *
+*									*
+*************************************************************************/
+#define DXT_FORWARD  0
+#define DXT_INVERSE  1
+#define DXT_SCALE    2 /* divide result by size of array */
+#define DXT_INV_SCALE (CV_DXT_INVERSE + CV_DXT_SCALE)
+#define DXT_INVERSE_SCALE CV_DXT_INV_SCALE
+#define DXT_ROWS     4 /* transform each row individually */
+#define DXT_MUL_CONJ 8 /* conjugate the second argument of cvMulSpectrums */
+#define DXT_INVERSE_ROWS 16
+    
+/************************* Common input structures ********************************************
+*  Fxn_struct:
+*  Fxn_struct is a structure used to pass the function Id and
+*  the parameters to the function being called in the API call.
+*  Every function in the API call will be contained in a seperate 
+*  fxn_struct. Multiple function calls are made using a single API call 
+*  by passing an array of Fxn_stuct in the extended Input Argument structure (IC6Accel_InArgs) 
+************************************************************************************************/
+
+typedef struct{
+                int FxnID;
+                int  Param_ptr_offset;                       // This is the offset of the param structure within overall inArgs
+               }Fxn_struct;
+
+
+/**********************Extended Input Structure IC6Accel_InArgs****************************************
+* IC6xPP_InArgs is an extended input argumet structure that follows the 
+ structure format as defined in InBufs and OutBufs. It carries with it,
+ the number of function calls defined in the API call and the an Array of Fxn_structs (defined abover)
+ to carry the parameters attributed to the corresponding function call
+*******************************************************************************************************/
+typedef struct {
+                int size;
+                int Num_fxns;
+                Fxn_struct fxn[MAX_FXN_CALLS];
+} IC6Accel_InArgs ;
+
+
+/************************Parameter structure for the DSP Library functions*******************************
+*    
+*  * All input and output arrays/buffers are passed using inBufs abd outBufs in the Iuniversal framework
+*  * Parameter structures carry inBufs IDs and outBuf IDs of parameter arrays and the scalar parameters  
+*  
+*  Naming Convention for Array IDs: [Format:  Prefix_ArrayID]
+*                 
+*                Prefix: parameter name as specified in library documentation
+*                ArrayID#:      InArrID : Input array ID
+*                               OutArrID: Output arrayID
+*                                 # : Order Number in set of arrays in the parameter set 
+*********************************************************************************************************/                            
+
+/* Function Call: void DSP_fft16x16(short * restrict w, int nx, short * restrict x, short * restrict y)*/
+typedef struct DSP_fft16x16_Params{
+                                    unsigned int w_InArrID1;    /* twiddle factor */
+                                    int  nx;                    /* Number of points*/
+                                    unsigned int x_InArrID2;    /* Input signal*/
+                                    unsigned int y_OutArrID1;   /* FFT output */
+                                   }DSP_fft16x16_Params;
+
+/* Function call: void DSP_ifft16x16(short *w, int nx, short *x, short *y)                              */
+typedef struct DSP_ifft16x16_Params{
+                                     unsigned int w_InArrID1;    /* twiddle factor */
+                                     int  nx;                    /* Number of points*/
+                                     unsigned int x_InArrID2;    /* Input signal*/
+                                     unsigned int y_OutArrID1;   /* IFFT output */
+                                   }DSP_ifft16x16_Params;
+
+/* Function call : void DSP_mat_mul(short * restrict x, int r1, int c1, short * restrict y, int c2, short
+* restrict r, int qs)                                                                                   */
+typedef struct DSP_mat_mul_Params{ 
+                                   unsigned int x_InArrID1;
+                                   int  r1;
+                                   int  c1;
+                                   unsigned int y_InArrID2;
+                                   int  c2;
+                                   unsigned int r_OutArrID1;
+                                   int  qs;
+                                  }DSP_mat_mul_Params;
+
+/* Function call : DSP_fir_gen (short * restrict x, short * restrict h, short * restrict r, int nh,int nr)*/
+typedef struct DSP_fir_gen_Params{ 
+                                   unsigned int x_InArrID1;
+                                   unsigned int h_InArrID2;
+                                   unsigned int r_OutArrID1;
+                                   int  nh;
+                                   int  nr;
+                                  }DSP_fir_gen_Params;
+
+/*Function call : DSP_autocor(short * restrict r, short * restrict x, int nx, int nr)*/
+typedef struct DSP_autocor_Params{ 
+                                   unsigned int r_OutArrID1;
+                                   unsigned int x_InArrID1;
+                                   int  nx;
+                                   int  nr;
+                                  }DSP_autocor_Params;
+
+/*Function call : DSP_firlms2(short *h, short *x, short b, int nh)*/
+typedef struct DSP_firlms2_Params{ 
+                                   unsigned int  h_InArrID1;
+                                   unsigned int  x_InArrID2;
+                                   short b;
+                                   int   nh;
+                                   unsigned int  OutArrID1;
+                                  }DSP_firlms2_Params;
+
+/*Function call : void DSP_fft16x16_imre(short *w, int nx, short *x, short *y)  */
+typedef struct DSP_fft16x16_imre_Params{
+                                         unsigned int w_InArrID1;    /* twiddle factor */
+                                         int  nx;                    /* Number of points*/
+                                         unsigned int x_InArrID2;    /* Input signal*/
+                                         unsigned int y_OutArrID1;   /* FFT output */
+                                       }DSP_fft16x16_imre_Params;
+
+/* Function call : void DSP_fft16x16r(int nx, short *x, short *w, unsigned char *brev, short *y, 
+                                                                           int offset, int n_max)*/
+typedef struct DSP_fft16x16r_Params{
+                                     int  nx;
+                                     unsigned int x_InArrID1;
+                                     unsigned int w_InArrID2;
+                                     unsigned int OutArrID1;
+                                     int  radix;
+                                     int  offset;
+                                     int  nmax;
+                                    }DSP_fft16x16r_Params;
+
+/* Function call : void DSP_fft16x32(short *w, int nx, int *x, int *y)*/
+typedef struct DSP_fft16x32_Params{
+                                    unsigned int w_InArrID1;
+                                    int  nx;
+                                    unsigned int x_InArrID2;
+                                    unsigned int y_OutArrID1;
+                                   }DSP_fft16x32_Params;
+
+/* Function call : DSP_fft32x32(short *w, int nx, short *x, short *y) */
+typedef struct DSP_fft32x32_Params{
+                                    unsigned int w_InArrID1;
+                                    int  nx;
+                                    unsigned int x_InArrID2;
+                                    unsigned int y_OutArrID1;
+                                   }DSP_fft32x32_Params;
+
+/* Function call : void DSP_fft32x32s(int *w, int nx, int *x, int *y)*/
+typedef struct DSP_fft32x32s_Params{
+                                     unsigned int w_InArrID1;
+                                     int  nx;
+                                     unsigned int x_InArrID2;
+                                     unsigned int y_OutArrID1;
+                                    }DSP_fft32x32s_Params;
+
+/* Function call : void DSP_ifft16x16_imre(short * restrict w, int nx, short * restrict x, short * restrict y)*/
+typedef struct DSP_ifft16x16_imre_Params{
+                                         unsigned int w_InArrID1; /* twiddle factor */
+                                         int  nx;                 /* Number of points*/
+                                         unsigned int x_InArrID2; /* Input signal*/
+                                         unsigned int Y_OutArrID1;/* FFT output */
+                                        }DSP_ifft16x16_imre_Params;
+
+/* Function call : void DSP_ifft16x32(short * restrict w, int nx, int * restrict x, int * restrict y)*/
+typedef struct DSP_ifft16x32_Params{
+                                     unsigned int w_InArrID1;
+                                     int  nx;
+                                     unsigned int x_InArrID2;
+                                     unsigned int y_OutArrID1;
+                                    }DSP_ifft16x32_Params;
+
+/* Function call : DSP_ifft32x32(short *w, int nx, short *x, short *y) */
+typedef struct DSP_ifft32x32_Params{
+                                     unsigned int w_InArrID1;
+                                     int  nx;
+                                     unsigned int x_InArrID2;
+                                     unsigned int y_OutArrID1;
+                                    }DSP_ifft32x32_Params;
+
+/* Function call : void DSP_fir_cplx (short * restrict x, short * restrict h, short * restrict r, int nh, int nr)*/
+typedef struct DSP_fir_cplx_Params{
+                                    unsigned int x_InArrID1;
+                                    unsigned int h_InArrID2;
+                                    unsigned int r_OutArrID1;
+                                    int  nh;
+                                    int  nr;
+                                   }DSP_fir_cplx_Params;
+
+/* Function call : DSP_fir_cplx _hM4X4(short * restrict x, short * restrict h, short * restrict r, int nh, int nr) */
+typedef struct DSP_fir_cplx_hM4X4_Params{
+                                          unsigned int x_InArrID1;
+                                          unsigned int h_InArrID2;
+                                          unsigned int r_OutArrID1;
+                                          int  nh;
+                                          int  nr;
+                                         }DSP_fir_cplx_hM4X4_Params;
+
+/* Function call : void DSP_fir_gen_hM17_rA8X8 (short * restrict x, short * restrict h, short * restrict r,
+                                                                                        int nh, int nr)*/
+typedef struct DSP_fir_gen_hM17_rA8X8_Params{
+                                              unsigned int InArrID1;
+                                              unsigned int InArrID2;
+                                              unsigned int OutArrID1;
+                                              int nh;
+                                              int nr;
+                                             }DSP_fir_gen_hM17_rA8X8_Params;
+
+/* Function call : void DSP_fir_r4 (short * restrict x, short * restrict h, short * restrict r, int nh,
+                                                                                               int nr)*/
+typedef struct DSP_fir_r4_Params{
+                                  unsigned int x_InArrID1;
+                                  unsigned int h_InArrID2;
+                                  unsigned int r_OutArrID1;
+                                  int  nh;
+                                  int  nr;
+                                 }DSP_fir_r4_Params;
+
+/* Function call : void DSP_fir_r8 (short * restrict x, short * h, short * restrict r, int nh, int nr)*/
+typedef struct DSP_fir_r8_Params{
+                                  unsigned int x_InArrID1;
+                                  unsigned int h_InArrID2;
+                                  unsigned int r_OutArrID1;
+                                  int  nh;
+                                  int  nr;
+                                 }DSP_fir_r8_Params;
+
+/* Function call : void DSP_fir_r8_hM16_rM8A8X8 (short * restrict x, short * h, short * restrict r,
+                                                                                 int nh, int nr)*/
+typedef struct DSP_fir_r8_hM16_rM8A8X8_Params{
+                                               unsigned int InArrID1;
+                                               unsigned int InArrID2;
+                                               unsigned int OutArrID1;
+                                               int  nh;
+                                               int  nr;
+                                              }DSP_fir_r8_hM16_rM8A8X8_Params;
+
+/* Function call : void DSP_fir_sym (short * restrict x, short * restrict h, short * restrict r, int nh,
+                                                                                        int nr, int s)*/
+typedef struct DSP_fir_sym_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int InArrID2;
+                                   unsigned int OutArrID1;
+                                   int  nh;
+                                   int  nr;
+                                   int  s;
+                                  }DSP_fir_sym_Params;
+
+/* Function call : short DSP_iir(short x, short * restrict h, int nh, short * restrict b) */
+/* function modified to work on multiple samples of input*/
+typedef struct DSP_iir_Params{
+                                unsigned int  x_InArrID1;
+                                unsigned int  h_InArrID2;
+                                int   nh;
+                                unsigned int  b_InArrID3;
+                                unsigned int  Ret_OutArrID1;
+                                int   n;
+                               }DSP_iir_Params;
+
+/* Function call : DSP_iir_lat(short * restrict x, int nx, short * restrict k, int nk, int * restrict b,
+                              short * restrict r)*/
+typedef struct DSP_iir_lat_Params{
+                                   unsigned int InArrID1;
+                                   int  nx;
+                                   unsigned int InArrID2;
+                                   int  nk;
+                                   unsigned int InArrID3;
+                                   unsigned int OutArrID1;
+                                  }DSP_iir_lat_Params;
+
+/* Function call : int DSP_dotp_sqr(int G, short * restrict x, short * restrict y, int * restrict r, int nx)*/
+typedef struct DSP_dotp_sqr_Params{
+                                    int  G;
+                                    unsigned int x_InArrID1;
+                                    unsigned int y_InArrID2;
+                                    unsigned int r_OutArrID1;
+                                    int  nx;
+                                    unsigned int Ret_outArrID2;
+                                   }DSP_dotp_sqr_Params;
+
+/* Function call : int DSP_dotprod(short * restrict x, short * restrict y, int nx)*/
+typedef struct DSP_dotprod_Params{
+                                    unsigned int x_InArrID1;
+                                    unsigned int y_InArrID2;
+                                    int  nx;
+                                    unsigned int Ret_outArrID1;
+                                   }DSP_dotprod_Params;
+
+/* Function call : short DSP_maxval (short *x, int nx)*/
+typedef struct DSP_maxval_Params{
+                                  unsigned int x_InArrID1;
+                                  int nx;
+                                  unsigned int OutArrID1;
+                                 }DSP_maxval_Params;
+
+/* Function call : int DSP_maxidx (short *x, int nx)*/
+typedef struct DSP_maxidx_Params{
+                                  unsigned int InArrID1;
+                                  int nx;
+                                  unsigned int OutArrID1;
+                                 }DSP_maxidx_Params;
+
+/* Function call : short DSP_minval (short *x, int nx)*/
+typedef struct DSP_minval_Params{
+                                  unsigned int InArrID1;
+                                  int nx;
+                                  unsigned int OutArrID1;
+                                 }DSP_minval_Params;
+
+/* Function call : void DSP_mul32(int * restrict x, int * restrict y, int * restrict r, short nx)*/
+typedef struct DSP_mul32_Params{
+                                 unsigned int InArrID1;
+                                 int nx;
+                                 unsigned int OutArrID1;
+                                }DSP_mul32_Params;
+
+/* Function call : void DSP_neg32(int * restrict x, int * restrict r, short nx)*/
+typedef struct DSP_neg32_Params{
+                                 unsigned int InArrID1;
+                                 int nx;
+                                 unsigned int OutArrID1;
+                                }DSP_neg32_Params;
+
+/* Function call : void DSP_recip16(short * restrict x, short * restrict rfrac, short * restrict rexp,
+                                    short nx)*/
+typedef struct DSP_recip16_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int InArrID2;
+                                   unsigned int OutArrID1;
+                                   short nx;                                     
+                                  }DSP_recip16_Params;
+
+/* Function call : int DSP_vecsumsq (short *x, int nx)*/
+typedef struct DSP_vecsumsq_Params{
+                                    unsigned int InArrID1;
+                                    int nx;
+                                    unsigned int OutArrID1;
+                                   }DSP_vecsumsq_Params;
+
+/* Function call : void DSP_w_vec(short * restrict x, short * restrict y, short m, short * restrict r,
+                                  short nr)*/
+typedef struct DSP_w_vec_Params{
+                                 unsigned int  x_InArrID1;
+                                 unsigned int  y_InArrID2;
+                                 short m;
+                                 unsigned int  r_OutArrID1;
+                                 int   nr;
+                                }DSP_w_vec_Params;
+
+/* Function call : void DSP_mat_trans(short * restrict x, short rows, short columns, short * restrict r)*/
+typedef struct DSP_mat_trans_Params{
+                                     unsigned int  x_InArrID1;
+                                     short r1;
+                                     short c1;
+                                     unsigned int  OutArrID1;
+                                    }DSP_mat_trans_Params;
+
+/* Function call : short DSP_bexp(const int *x, short nx)*/
+typedef struct DSP_bexp_Params{
+                                unsigned int x_InArrID1;
+                                short nx;
+                                unsigned int OutArrID1;
+                               }DSP_bexp_Params;
+
+/* Function call : void blk_eswap16(void * restrict x, void * restrict r, int nx)*/
+typedef struct blk_eswap16_Params{
+                                   unsigned int x_InArrID1;
+                                   unsigned int r_OutArrID1;
+                                   int  nx;
+                                  }blk_eswap16_Params;
+
+/* Function call : void blk_eswap32(void * restrict x, void * restrict r, int nx)*/
+typedef struct blk_eswap32_Params{
+                                    unsigned int InArrID1;
+                                    unsigned int OutArrID1;
+                                    int  nx;
+                                   }blk_eswap32_Params;
+
+/* Function call : void blk_eswap64(void * restrict x, void * restrict r, int nx)*/
+typedef struct blk_eswap64_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int OutArrID1;
+                                   int  nx;
+                                  }blk_eswap64_Params;
+
+/* Function call : void DSP_blk_move(short * restrict x, short * restrict r, int nx)*/
+typedef struct DSP_blk_move_Params{
+                                    unsigned int InArrID1;
+                                    unsigned int OutArrID1;
+                                    int  nx;
+                                   }DSP_blk_move_Params;
+
+/* Function call : void DSP_fltoq15(float * restrict x, short * restrict r, short nx)*/
+typedef struct DSP_fltoq15_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int OutArrID1;
+                                   int  nx;
+                                  }DSP_fltoq15_Params;
+
+/* Function call : int minerror (short * restrict GSP0_TABLE, short * restrict errCoefs, int * restrict max_index)*/
+typedef struct minerror_Params{
+                                unsigned int GSP0TABLE_InArrID1;
+                                unsigned int errCoefs_InArrID2;
+                                int  max_index;
+                                unsigned int OutArrID1;
+                               }minerror_Params;
+
+/* Function call : void DSP_q15tofl(short * restrict x, float * restrict r, short nx)*/
+typedef struct DSP_q15tofl_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int OutArrID1;
+                                   int nx;
+                                  }DSP_q15tofl_Params;
+
+/*************************************************************************************/
+/* Floating point DSP library for C67+ devices                                       */
+/*************************************************************************************/
+
+/*Function call: void DSPF_sp_autocor(float *restrict r, float *restrict x, const int nx, const int nr) */
+typedef struct DSPF_sp_autocor_Params{ 
+                                       unsigned int r_OutArrID1;
+                                       unsigned int x_InArrID1;
+                                       int  nx;
+                                       int  nr;
+                                       }DSPF_sp_autocor_Params;
+
+/*Function call: void DSPF_sp_biquad(float *restrict x, float *b, float *a, float *delay, float *restrict y, const int n) */
+typedef struct DSPF_sp_biquad_Params{
+                                        unsigned int x_InArrID1;
+                                        unsigned int b_InArrID2;
+                                        unsigned int a_InArrID3;
+                                        unsigned int delay_InArrID4;
+                                        unsigned int y_OutArrID1;
+                                        int n;
+                                      }DSPF_sp_biquad_Params;
+
+/*Function call: void DSPF_sp_convol(const float *x, const float *h, float *restrict y, const short nh, const short ny)*/
+typedef struct DSPF_sp_convol_Params{
+                                     unsigned int x_InArrID1;
+                                     unsigned int h_InArrID2;
+                                     unsigned int y_OutArrID1;
+                                     short nh;
+                                     short ny;
+                                    }DSPF_sp_convol_Params;
+
+/*Function call: float DSPF_sp_dotprod(const float * x, const float * y, const int n)*/
+typedef struct DSPF_sp_dotprod_Params{
+                                      unsigned int x_InArrID1;
+                                      unsigned int y_InArrID2;
+                                      int n;
+                                      unsigned int RetOut_OutArrID1;
+                                    }DSPF_sp_dotprod_Params;
+
+/*Function call: void DSPF_sp_fftSPxSP(int N, float *ptr_x, float *ptr_w, float *ptr_y, unsigned char *brev, int n_min, int offset, int n_max)*/
+typedef struct DSPF_sp_fftSPxSP_Params{
+                                       int N;
+                                       unsigned int x_InArrID1;
+                                       unsigned int w_InArrID2;
+                                       unsigned int y_OutArrID1;
+                                       unsigned int brev_InArrID3;
+                                       int n_min;
+                                       int offset;
+                                       int n_max;
+                                      }DSPF_sp_fftSPxSP_Params;
+  
+/*Function call: void DSPF_sp_fir_cplx(const float * x, const float * h, float * restrict y, int nh, int ny)*/
+typedef struct DSPF_sp_fir_cplx_Params{
+                                       unsigned int x_InArrID1;
+                                       unsigned int h_InArrID2;
+                                       unsigned int y_OutArrID1;
+                                       int nh;
+                                       int ny;
+                                      }DSPF_sp_fir_cplx_Params;
+
+/*Function call: void DSPF_sp_fir_gen(const float * restrict x, const float * restrict h, float * restrict y, int nh, int ny)*/
+typedef struct DSPF_sp_fir_gen_Params{
+                                      unsigned int x_InArrID1;
+                                      unsigned int h_InArrID2;
+                                      unsigned int y_OutArrID1;
+                                      int nh;
+                                      int ny;
+                                      }DSPF_sp_fir_gen_Params;
+
+/*Function call: void DSPF_sp_ifftSPxSP(int N, float *ptr_x, float *ptr_w, float *ptr_y, unsigned char *brev, int n_min, int offset, int n_max)*/
+typedef struct DSPF_sp_ifftSPxSP_Params{
+                                       int N;
+                                       unsigned int x_InArrID1;
+                                       unsigned int w_InArrID2;
+                                       unsigned int y_OutArrID1;
+                                       unsigned int brev_InArrID3;
+                                       int n_min;
+                                       int offset;
+                                       int n_max;
+                                       }DSPF_sp_ifftSPxSP_Params;
+
+/*Function call: void DSPF_sp_iir(float *restrict y1, const float * x, float *restrict y2, const float * hb, const float * ha, int n)*/
+typedef struct DSPF_sp_iir_Params{
+                                  unsigned int y1_OutArrID1;
+                                  unsigned int x_InArrID1;
+                                  unsigned int y2_OutArrID2;
+                                  unsigned int hb_InArrID2;
+                                  unsigned int ha_InArrID3;
+                                  int n;
+                                  }DSPF_sp_iir_Params;
+
+/*Function call: void DSPF_sp_mat_mul(float *x1, const int r1, const int c1, float *x2, const int c2, float *restrict y)*/
+typedef struct DSPF_sp_mat_mul_Params{
+                                      unsigned int x1_InArrID1;
+                                      int  r1;
+                                      int  c1;
+                                      unsigned int x2_InArrID2;
+                                      int  c2;
+                                      unsigned int y_OutArrID1;
+                                     }DSPF_sp_mat_mul_Params;
+
+/*Function call: void DSPF_sp_mat_mul_cplx(float *x1, const int r1, const int c1, float *x2, const int c2, float *restrict y)*/
+typedef struct DSPF_sp_mat_mul_cplx_Params{
+                                      unsigned int x1_InArrID1;
+                                      int  r1;
+                                      int  c1;
+                                      unsigned int x2_InArrID2;
+                                      int  c2;
+                                      unsigned int y_OutArrID1;
+                                     }DSPF_sp_mat_mul_cplx_Params;
+
+/*Function call: void DSPF_sp_mat_trans(const float *restrict x, const int rows, const int cols, float *restrict y)*/
+typedef struct DSPF_sp_mat_trans_Params{
+                                        unsigned int  x_InArrID1;
+                                        short rows;
+                                        short cols;
+                                        unsigned int  y_OutArrID1;
+                                       } DSPF_sp_mat_trans_Params;
+
+/*Function call: void DSPF_sp_vecmul(const float * x1, const float * x2, float *restrict y, const int n)*/
+typedef struct DSPF_sp_vecmul_Params{
+                                     unsigned int  x1_InArrID1;
+                                     unsigned int  x2_InArrID2;
+                                     unsigned int  y_OutArrID1;
+                                     int n;
+                                     }DSPF_sp_vecmul_Params;
+
+/*Function call: void DSPF_sp_vecrecip(const float * x, float *restrict y, const int n)*/
+typedef struct DSPF_sp_vecrecip_Params{
+                                       unsigned int  x_InArrID1;
+                                       unsigned int  y_OutArrID1;
+                                       int n;
+                                      }DSPF_sp_vecrecip_Params;
+
+/*Function call: float DSPF_sp_vecsum_sq(const float * x, const int n)*/
+typedef struct DSPF_sp_vecsum_sq_Params{
+                                        unsigned int  x_InArrID1;
+                                        int n;
+                                        unsigned int  OutRet_OutArrID1;
+                                        }DSPF_sp_vecsum_sq_Params;
+
+/*Function call: void DSPF_sp_w_vec(const float *x1, const float *x2, const float m, float *restrict y, const int n)*/
+typedef struct DSPF_sp_w_vec_Params{
+                                     unsigned int  x1_InArrID1;
+                                     unsigned int  x2_InArrID2;
+                                     float m;
+                                     unsigned int  y_OutArrID1;
+                                     int n;
+                                    }DSPF_sp_w_vec_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Image Library functions                    */
+/*************************************************************************************/
+/* Function call : void IMG_sobel_3x3_8(const unsigned char *in_data, unsigned char *out_data, short cols, short rows)*/
+typedef struct IMG_sobel_3x3_8_Params{
+                                      unsigned int indata_InArrID1;
+                                      unsigned int outdata_OutArrID1; 
+                                      int Col;
+                                      int Row;
+                                     }IMG_sobel_3x3_8_Params;
+/* This struct is added by Pramod */
+/* Function call : void IMG_sobel_3x3_8_16(const unsigned char *in_data, unsigned short *out_data, short cols, short rows)*/
+typedef struct IMG_sobel_3x3_8_16_Params{
+                                      unsigned int indata_InArrID1;
+                                      unsigned int outdata_OutArrID1; 
+                                      int Col;
+                                      int Row;
+                                     }IMG_sobel_3x3_8_16_Params;
+
+/* Function call : void IMG_sobel_3x3_16s (const short *restrict in, const short *restrict out, short cols,
+                                           short rows)*/
+typedef struct IMG_sobel_3x3_16_Params{
+                                       unsigned int indata_InArrID1;
+                                       unsigned int outdata_OutArrID1; 
+                                       short Col;
+                                       short Row;
+                                     }IMG_sobel_3x3_16_Params;
+
+/* Function call : IMG_histogram_8 (const unsigned char * restrict in_data, int n, short accumulate,
+unsigned short * restrict t_hist, unsigned short * restrict hist)*/
+typedef struct IMG_histogram_8_Params{
+                                      unsigned int  indata_InArrID1;
+                                      int   n;
+                                      short accumulate;
+                                      unsigned int  t_hist_OutArrID1;
+                                      unsigned int  hist_OutArrID2; 
+                                     }IMG_histogram_8_Params;
+
+/* Function call : void IMG_histogram_16(unsigned short *restrict in, short *restrict hist, short *restrict
+t_hist, int n, int accumulate, int img_bits)*/
+typedef struct IMG_histogram_16_Params{
+                                       unsigned int  in_InArrID1;
+                                       int   n;
+                                       short accumulate;
+                                       unsigned int  t_hist_OutArrID1;
+                                       unsigned int  hist_OutArrID2;
+                                       int   img_bits; 
+                                      }IMG_histogram_16_Params;
+
+/* Function call : void IMG_median_3x3_8(const unsigned char * restrict in_data, int cols, unsigned char *restrict out_data)*/
+                                         
+typedef struct IMG_median_3x3_8_Params{
+                                       unsigned int InArrID1;
+                                       int  Col;
+                                       unsigned int OutArrID1; 
+                                      }IMG_median_3x3_8_Params;
+
+/* Function call : void IMG_median_3x3_16 (const short *restrict i_data, int n, short *restrict o_data)*/
+typedef struct IMG_median_3x3_16_Params{
+                                        unsigned int idata_InArrID1;
+                                        int  nwidth;
+                                        unsigned int odata_OutArrID1; 
+                                      }IMG_median_3x3_16_Params;
+
+/* Function call : void IMG_median_3x3_16s (const short *restrict i_data, int n, short *restrict o_data)*/
+typedef struct IMG_median_3x3_16s_Params{
+                                         unsigned int idata_InArrID1;
+                                         int  nwidth;
+                                         unsigned int odata_OutArrID1; 
+                                      }IMG_median_3x3_16s_Params;
+
+/* Additional functions that allow raw and columns to be specified */
+typedef struct IMG_median_3x3_8_Frame_Params{
+                                       unsigned int InArrID1;
+                                       int  Row;
+                                       int  Col;
+                                       unsigned int OutArrID1;
+                                      }IMG_median_3x3_8_Frame_Params;
+
+/* Function call : void IMG_median_3x3_16 (const short *restrict i_data, int n, short *restrict o_data)*/
+typedef struct IMG_median_3x3_16_Frame_Params{
+                                        unsigned int idata_InArrID1;
+                                        int  Row;
+                                        int  nwidth;
+                                        unsigned int odata_OutArrID1;
+                                      }IMG_median_3x3_16_Frame_Params;
+
+/* Function call : void IMG_median_3x3_16s (const short *restrict i_data, int n, short *restrict o_data)*/
+typedef struct IMG_median_3x3_16s_Frame_Params{
+                                         unsigned int idata_InArrID1;
+                                         int  Row;
+                                         int  nwidth;
+                                         unsigned int odata_OutArrID1;
+                                      }IMG_median_3x3_16s_Frame_Params;
+
+
+/* Function call : IMG_ycbcr422p_rgb565(const short * restrict coeff, const unsigned char * restrict
+                                        y_data, const unsigned char * restrict cb_data, 
+                                        const unsigned char * restrict cr_data,
+                                        unsigned short * restrict rgb_data, unsigned num_pixels)*/
+typedef struct IMG_ycbcr422pl_to_rgb565_Params{
+                                               unsigned int     coeff_InArrID1;
+                                               unsigned int     y_data_InArrID2;
+                                               unsigned int     cb_data_InArrID3;
+                                               unsigned int     cr_data_InArrID4;
+                                               unsigned int     rgb_data_OutArrID1;
+                                               unsigned num_pixels;
+                                              }IMG_ycbcr422pl_to_rgb565_Params;
+
+
+/* Function call : IMG_yuv420pl_to_rgb565(const short *coeff,int Height, int Width, unsigned char *pbuf_y,
+                               unsigned char *pbuf_cb,unsigned char *pbuf_cr,unsigned short *pbuf_rgb)*/
+typedef struct IMG_yuv420pl_to_rgb565_Params{
+                                             unsigned int     coeff_InArrID1;
+                                             int      Height;
+                                             int      Width;
+                                             unsigned int     y_data_InArrID2;
+                                             unsigned int     cb_data_InArrID3;
+                                             unsigned int     cr_data_InArrID4;
+                                             unsigned int     rgb_data_OutArrID1;
+                                            }IMG_yuv420pl_to_rgb565_Params;
+
+
+typedef struct IMG_yuv420pl16_to_rgb565_Params{
+                                               unsigned int     coeff_InArrID1;
+                                               int      Height;
+                                               int      Width;
+                                               unsigned int     y_data_InArrID2;
+                                               unsigned int     cb_data_InArrID3;
+                                               unsigned int     cr_data_InArrID4;
+                                               unsigned int     rgb_data_OutArrID1;
+                                              }IMG_yuv420pl16_to_rgb565_Params;
+
+/* Function call : IMG_ycbcr422pl16_rgb565(const short * restrict coeff, const unsigned char * restrict
+                                        y_data, const unsigned char * restrict cb_data, 
+                                        const unsigned char * restrict cr_data,
+                                        unsigned short * restrict rgb_data, unsigned num_pixels)*/
+typedef struct IMG_ycbcr422pl16_to_rgb565_Params{
+                                                 unsigned int     coeff_InArrID1;
+                                                 int      Height;
+                                                 int      Width;
+                                                 unsigned int     y_data_InArrID2;
+                                                 unsigned int     cb_data_InArrID3;
+                                                 unsigned int     cr_data_InArrID4;
+                                                 unsigned int     rgb_data_OutArrID1;
+                                                 unsigned num_pixels;
+                                                }IMG_ycbcr422pl16_to_rgb565_Params;
+
+/* Function call : IMG_conv_33_i8_c8s(const unsigned char * restrict in_data, unsigned char *
+restrict out_data, int cols, const char * restrict mask, int shift)*/
+typedef struct IMG_conv_3x3_i8_c8s_Params{
+                                           unsigned int in_data_InArrID1;
+                                           unsigned int out_data_OutArrID1;
+                                           int  cols;
+                                           unsigned int mask_InArrID2;
+                                           int  shift;
+                                          }IMG_conv_3x3_i8_c8s_Params;
+
+/* Function call : void IMG_conv_3x3_i16s_c16s (const short *restrict imgin_ptr, short *restrict
+imgout_ptr, short width, short pitch, const short *restrict mask_ptr, short shift)*/
+typedef struct IMG_conv_3x3_i16s_c16s_Params{
+                                             unsigned int in_data_InArrID1;
+                                             unsigned int out_data_OutArrID1;
+                                             short width;
+                                             short pitch;
+                                             unsigned int mask_InArrID2;
+                                             short shift;
+                                            }IMG_conv_3x3_i16s_c16s_Params;
+
+/* Function call : IMG_conv_33_i8_c8s(const unsigned char * restrict in_data, unsigned char *
+restrict out_data, int cols, const char * restrict mask, int shift)*/
+typedef struct IMG_conv_3x3_i8_c8s_Frame_Params{
+                                           unsigned int in_data_InArrID1;
+                                           unsigned int out_data_OutArrID1;
+                                           int  rows;
+                                           int  cols;
+                                           unsigned int mask_InArrID2;
+                                           int  shift;
+                                          }IMG_conv_3x3_i8_c8s_Frame_Params;
+
+/* Function call : void IMG_conv_3x3_i16s_c16s (const short *restrict imgin_ptr, short *restrict
+imgout_ptr, short width, short pitch, const short *restrict mask_ptr, short shift)*/
+typedef struct IMG_conv_3x3_i16s_c16s_Frame_Params{
+                                             unsigned int in_data_InArrID1;
+                                             unsigned int out_data_OutArrID1;
+                                             short rows;
+                                             short width;
+                                             short pitch;
+                                             unsigned int mask_InArrID2;
+                                             short shift;
+                                            }IMG_conv_3x3_i16s_c16s_Frame_Params;
+
+
+/* Function call :IMG_corr_3x3_i8_c8(const unsigned char *inptr, int *restrict outptr, int n_out, int
+x_dim, const unsigned char *mask, const short shift, int round)*/
+typedef struct IMG_corr_3x3_i8_c8_Params{
+                                          unsigned int in_InArrID1;
+                                          unsigned int out_OutArrID1;
+                                          int n_out;
+                                          int x_dim;
+                                          unsigned int mask_InArrID2;
+                                          short shift;
+                                          int round;
+                                         }IMG_corr_3x3_i8_c8_Params;
+
+/* Function call : IMG_corr_3x3_i16_c16s (const short *restrict imgin_ptr, int *restrict imgout_ptr,
+short width, short pitch, const short *restrict mask_ptr, short shift, int round)*/
+typedef struct IMG_corr_3x3_i16s_c16s_Params{
+                                              unsigned int   imgin_InArrID1;
+                                              unsigned int   imgout_OutArrID1;
+                                              short  width;
+                                              short  pitch;
+                                              unsigned int   mask_InArrID2;
+                                              short  shift;
+                                              int  round;
+                                             }IMG_corr_3x3_i16s_c16s_Params;
+
+/* Function call : void IMG_corr_3x3_i8_c16s (const unsigned char *restrict imgin_ptr, int *restrict
+                  imgout_ptr, short width, short pitch, const short *restrict mask_ptr, int round)*/
+typedef struct IMG_corr_3x3_i8_c16s_Params{
+                                            unsigned int   imgin_InArrID1;
+                                            unsigned int   imgout_OutArrID1;
+                                            short  width;
+                                            short  pitch;
+                                            unsigned int   mask_InArrID2;
+                                          }IMG_corr_3x3_i8_c16s_Params;
+
+/* Function call :IMG_corr_3x3_i8_c8(const unsigned char *inptr, int *restrict outptr, int n_out, int
+x_dim, const unsigned char *mask, const short shift, int round)*/
+typedef struct IMG_corr_3x3_i8_c8_Frame_Params{
+                                          unsigned int in_InArrID1;
+                                          unsigned int out_OutArrID1;
+                                          int n_out;
+                                          int rows;
+                                          int x_dim;
+                                          unsigned int mask_InArrID2;
+                                          short shift;
+                                          int round;
+                                         }IMG_corr_3x3_i8_c8_Frame_Params;
+
+/* Function call : IMG_corr_3x3_i16_c16s (const short *restrict imgin_ptr, int *restrict imgout_ptr,
+short width, short pitch, const short *restrict mask_ptr, short shift, int round)*/
+typedef struct IMG_corr_3x3_i16s_c16s_Frame_Params{
+                                              unsigned int   imgin_InArrID1;
+                                              unsigned int   imgout_OutArrID1;
+                                              short  rows;
+                                              short  width;
+                                              short  pitch;
+                                              unsigned int   mask_InArrID2;
+                                              short  shift;
+                                              int  round;
+                                             }IMG_corr_3x3_i16s_c16s_Frame_Params;
+
+/* Function call : void IMG_corr_3x3_i8_c16s (const unsigned char *restrict imgin_ptr, int *restrict
+                  imgout_ptr, short width, short pitch, const short *restrict mask_ptr, int round)*/
+typedef struct IMG_corr_3x3_i8_c16s_Frame_Params{
+                                            unsigned int   imgin_InArrID1;
+                                            unsigned int   imgout_OutArrID1;
+                                            short  rows;
+                                            short  width;
+                                            short  pitch;
+                                            unsigned int   mask_InArrID2;
+                                          }IMG_corr_3x3_i8_c16s_Frame_Params;
+
+/* Function call : IMG_fdct_8x8(short *fdct_data, unsigned num_fdcts)*/
+typedef struct IMG_fdct_8x8_Params{
+                                    unsigned int     in_InArrID1;
+                                    unsigned num_fdcts;
+                                   }IMG_fdct_8x8_Params;
+
+/* Function call : void IMG_mulS_8(short * restrict imgR,int * restrict imgW,short constData,int count )*/
+typedef struct IMG_mulS_8_Params{
+                                   unsigned int imgR_InArrID1;
+                                   unsigned int imgW_OutArrID1;
+                                   char constData;
+                                   int  count;
+                                  }IMG_mulS_8_Params;
+
+/* Function call : void IMG_mulS_16s(short * restrict imgR,int * restrict imgW, short constData, int count )*/
+typedef struct IMG_mulS_16s_Params{
+                                   unsigned int imgR_InArrID1;
+                                   unsigned int imgW_OutArrID1;
+                                   short constData;
+                                   int  count;
+                                  }IMG_mulS_16s_Params;
+
+/* Function call : void IMG_addS_8(char * restrict imgR, char * restrict imgW, char constData,int count ) */ 
+typedef struct IMG_addS_8_Params{
+                                  unsigned int imgR_InArrID1;
+                                  unsigned int imgW_OutArrID1;
+                                  char constData;
+                                  int  count;
+                                 }IMG_addS_8_Params;
+
+/* Function call : void IMG_addS_16s(short * restrict imgR,short * restrict imgW, short constData, int count) */              
+typedef struct IMG_addS_16s_Params{
+                                   unsigned int  imgR_InArrID1;
+                                   unsigned int  imgW_OutArrID1;
+                                   short constData;
+                                   int   count;
+                                  }IMG_addS_16s_Params;
+
+/* Function call : void IMG_subS_8(char * restrict imgR,char * restrict imgW, char constData,int count )*/
+typedef struct IMG_subS_8_Params{
+                                  unsigned int imgR_InArrID1;
+                                  unsigned int imgW_OutArrID1;
+                                  char constData;
+                                  int  count;
+                                 }IMG_subS_8_Params;
+
+/* Function call : void IMG_subS_16s(short * restrict imgR, short * restrict imgW, short constData,int count)*/           
+typedef struct IMG_subS_16s_Params{
+                                   unsigned int  imgR_InArrID1;
+                                   unsigned int  imgW_OutArrID1;
+                                   short constData;
+                                   int   count;
+                                  }IMG_subS_16s_Params;
+
+/* Function call : void IMG_yc_demux_le16_16 (int n, const unsigned short * yc, short *restrict y, short
+*restrict cr, short *restrict cb)*/
+typedef struct IMG_yc_demux_le16_16_Params{
+                                           int n;
+                                           unsigned int yc_InArrID1;
+                                           unsigned int y_OutArrID1;
+                                           unsigned int cr_OutArrID2;
+                                           unsigned int cb_OutArrID3; 
+                                          }IMG_yc_demux_le16_16_Params;
+
+/* Function call :  void yc_demux_le8_c(int n, const unsigned char *restrict yc,unsigned char *restrict y, 
+                                       unsigned char *restrict cr, unsigned char *restrict cb     )*/
+typedef struct IMG_yc_demux_le8_c_Params{
+                                           int n;
+                                           unsigned int yc_InArrID1;
+                                           unsigned int y_OutArrID1;
+                                           unsigned int cr_OutArrID2;
+                                           unsigned int cb_OutArrID3; 
+                                          }IMG_yc_demux_le8_c_Params;
+
+/* Function call : void IMG_dilate_bin(const unsigned char * restrict in_data, unsigned char * restrict
+out_data, const char * restrict mask, int cols) */
+typedef struct IMG_dilate_bin_Params{
+                                      unsigned int InArrID1;
+                                      unsigned int OutArrID1;
+                                      unsigned int InArrID2; 
+                                      int  Col;
+                                     }IMG_dilate_bin_Params;
+
+/* Function call : void IMG_erode_bin(const unsigned char * restrict in_data, unsigned char * restrict
+out_data, const char * restrict mask, int cols)*/
+typedef struct IMG_erode_bin_Params{
+                                      unsigned int InArrID1;
+                                      unsigned int OutArrID1;
+                                      unsigned int InArrID2; 
+                                      int  Col;
+                                     }IMG_erode_bin_Params;
+
+/* Function call : void IMG_pix_sat(int n, const short * restrict in_data, unsigned char * restrict out_data) */
+typedef struct IMG_pix_sat_Params{
+                                  int  Col;
+                                  unsigned int InArrID1;
+                                  unsigned int OutArrID1; 
+                                 }IMG_pix_sat_Params;
+
+/* void ycbcr422sp_to_ycbcr420pl(
+    const unsigned char * y_src,    
+    const unsigned char * cbcr_src, 
+    unsigned char * restrict y_dst,
+    unsigned char * restrict cb_dst,
+    unsigned char * restrict cr_dst,
+    unsigned int num_lines, 
+    unsigned int width,
+    unsigned int src_pitch, 
+    unsigned int dst_y_pitch,
+    unsigned int dst_cbcr_pitch
+)
+*/
+typedef struct IMG_ycbcr422sp_to_ycbcr420pl_Params{
+                                            unsigned int y_src_InArrID1;
+                                            unsigned int cbcr_src_InArrID2;
+                                            unsigned int y_dst_OutArrID1;
+                                            unsigned int cb_dst_OutArrID2;
+                                            unsigned int cr_dst_OutArrID3;
+                                            unsigned int num_lines; 
+                                            unsigned int width;
+                                            unsigned int src_pitch; 
+                                            unsigned int dst_y_pitch;
+                                            unsigned int dst_cbcr_pitch;
+                                            }IMG_ycbcr422sp_to_ycbcr420pl_Params;
+                                             
+/* void ycbcr422pl_to_ycbcr422sp 
+(
+    const unsigned char * y_dst,    
+    const unsigned char * cbcr_dst, 
+    unsigned char * restrict y_src,
+    unsigned char * restrict cb_src,
+    unsigned char * restrict cr_src,
+    unsigned int num_lines, 
+    unsigned int width,
+    unsigned int dst_pitch, 
+    unsigned int src_y_pitch,
+    unsigned int src_cbcr_pitch
+)*/
+typedef struct IMG_ycbcr422pl_to_ycbcr422sp_Params{
+                                            unsigned int y_dst_OutArrID1;
+                                            unsigned int cbcr_dst_OutArrID2;
+                                            unsigned int y_src_InArrID1;
+                                            unsigned int cb_src_InArrID2;
+                                            unsigned int cr_src_InArrID3;
+                                            unsigned int num_lines; 
+                                            unsigned int width;
+                                            unsigned int dst_pitch; 
+                                            unsigned int src_y_pitch;
+                                            unsigned int src_cbcr_pitch;
+                                            }IMG_ycbcr422pl_to_ycbcr422sp_Params;
+
+/* void ycbcr422sp_to_ycbcr422ile 
+(
+    const unsigned char * y_src,    
+    const unsigned char * cbcr_src, 
+    unsigned char * restrict ycbcr_dst,
+    unsigned int num_lines, 
+    unsigned int width,
+    unsigned int src_pitch, 
+    unsigned int dst_ycbcr_pitch
+) */
+typedef struct IMG_ycbcr422sp_to_ycbcr422ile_Params{
+                                            unsigned int y_src_InArrID1;
+                                            unsigned int cbcr_src_InArrID2;
+                                            unsigned int ycbcr_dst_OutArrID1;
+                                            unsigned int num_lines; 
+                                            unsigned int width;
+                                            unsigned int src_pitch;
+                                            unsigned int dst_ycbcr_pitch;
+                                            }IMG_ycbcr422sp_to_ycbcr422ile_Params;
+
+/* ***********************************************************************************/
+/* Parameter structure and pointer to the structure for the IQ math Library functions*/
+/*************************************************************************************/
+//#if DEVICE_TYPE == DEVICE_FIXED
+
+/* Function call : I32_IQ _IQNmpy(I32_IQ f1, I32_IQ f2, U32_IQ q_format);*/
+typedef struct IQNmpy_Params{
+                              unsigned int   InArrID1;
+                              unsigned int   InArrID2;
+                              unsigned int qfmt;
+                              unsigned int   OutArrID1;
+                              unsigned int   n;
+                             }IQNmpy_Params;
+
+/* Function call : I32_IQ _IQNrmpy(I32_IQ x, I32_IQ y, Uword32 qfmt); */
+typedef struct IQNrmpy_Params{
+                              unsigned int InArrID1;
+                              unsigned int InArrID2;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNrmpy_Params;
+
+/* Function call : I32_IQ _IQNrsmpy(I32_IQ x, I32_IQ y, U32_IQ qfmt); */
+typedef struct IQNrsmpy_Params{ 
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int qfmt;
+                               unsigned int OutArrID1;
+                               unsigned int   n;
+                              }IQNrsmpy_Params;
+
+/* Function call : I32_IQ _IQNmpyI32int(I32_IQ x, I32_IQ y, U32_IQ qfmt);*/
+typedef struct IQNmpyI32int_Params{
+                                    unsigned int  InArrID1;
+                                    unsigned int     InArrID2;
+                                    unsigned int  qfmt;
+                                    unsigned int  OutArrID1;
+                                    unsigned int   n;
+                                   }IQNmpyI32int_Params;
+
+/* Function call : I32_IQ _IQNmpyI32frac(I32_IQ x, I32_IQ y, U32_IQ qfmt);*/
+typedef struct IQNmpyI32frac_Params{
+                                    unsigned int  InArrID1;
+                                    unsigned int     InArrID2;
+                                    unsigned int  qfmt;
+                                    unsigned int  OutArrID1;
+                                    unsigned int   n;
+                                   }IQNmpyI32frac_Params;
+
+/* Function call : I32_IQ  _IQNmpyIQx(I32_IQ in1, I32_IQ qfmt1,I32_IQ in2, I32_IQ qfmt2, U32_IQ qfmt);*/
+typedef struct IQNmpyIQX_Params{
+                                unsigned int   InArrID1;
+                                int            qfmt1;
+                                unsigned int   InArrID2;
+                                int            qfmt2;
+                                unsigned int   qfmt;
+                                unsigned int   OutArrID1;
+                                unsigned int   n;
+                               }IQNmpyIQX_Params;
+
+/* Function call : I32_IQ _IQNdiv(I32_IQ num, I32_IQ den, Uword32 qfmt);*/
+typedef struct IQNdiv_Params{
+                              unsigned int  num_InArrID1;
+                              unsigned int  den_InArrID2;
+                              unsigned int  qfmt;
+                              unsigned int  OutArrID1;
+                              unsigned int  n;
+                             }IQNdiv_Params;
+
+/* Function call : I32_IQ _IQNmag(I32_IQ x, I32_IQ y, U32_IQ qfmt);*/
+typedef struct IQNmag_Params{
+                              unsigned int  InArrID1;
+                              unsigned int  InArrID2;
+                              unsigned int  qfmt;
+                              unsigned int  OutArrID1;
+                              unsigned int    n;
+                             }IQNmag_Params;
+
+/* Function call : I32_IQ _IQNsqrt(I32_IQ x, U32_IQ qfmt);*/
+typedef struct IQNsqrt_Params{
+                              unsigned int   InArrID1;
+                              unsigned int   qfmt;
+                              unsigned int   OutArrID1;
+                              unsigned int     n;
+                             }IQNsqrt_Params;
+
+/* Function call : I32_IQ _IQNisqrt(I32_IQ x, U32_IQ qfmt); */
+typedef struct IQNisqrt_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int n;
+                             }IQNisqrt_Params;
+
+/* Function call : I32_IQ _IQNsin(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNsin_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int n;
+                             }IQNsin_Params;
+
+/* Function call : I32_IQ _IQNasin(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNasin_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int n;
+                             }IQNasin_Params;
+
+/* Function call : I32_IQ _IQNsinPU(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNsinPU_Params{
+                               unsigned int InArrID1;
+                               unsigned int qfmt;
+                               unsigned int OutArrID1;
+                               unsigned int   n;
+                             }IQNsinPU_Params;
+
+/* Function call : I32_IQ _IQNcos(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNcos_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNcos_Params;
+
+/* Function call : I32_IQ _IQNacos(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNacos_Params{
+                              unsigned int  InArrID1;
+                              unsigned int  qfmt;
+                              unsigned int  OutArrID1;
+                              unsigned int    n;
+                             }IQNacos_Params;
+
+/* Function call : I32_IQ _IQNcosPU(I32_IQ in, U32_IQ qfmt); */
+typedef struct IQNcosPU_Params{
+                               unsigned int InArrID1;
+                               unsigned int qfmt;
+                               unsigned int OutArrID1;
+                               unsigned int    n;
+                              }IQNcosPU_Params;
+
+/* Function call : I32_IQ _IQNatan2(I32_IQ y, I32_IQ x, U32_IQ qfmt); */
+typedef struct IQNatan2_Params{
+                              unsigned int y_InArrID1;
+                              unsigned int x_InArrID2;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNatan2_Params;
+
+/* Function call : I32_IQ _IQNatan2PU(I32_IQ y, I32_IQ x, U32_IQ qfmt);*/
+typedef struct IQNatan2PU_Params{
+                                 unsigned int y_InArrID1;
+                                 unsigned int x_InArrID2;
+                                 unsigned int qfmt;
+                                 unsigned int OutArrID1;
+                                 unsigned int   n;
+                                }IQNatan2PU_Params;
+
+/* Function call : I32_IQ _IQNexp(I32_IQ a, U32_IQ qfmt); */
+typedef struct IQNexp_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNexp_Params;
+
+/* Function call : I32_IQ _IQNlog(I32_IQ a, U32_IQ qfmt);*/
+typedef struct IQNlog_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNlog_Params;
+
+/* Function call : I32_IQ _IQNlog(I32_IQ a, U32_IQ qfmt);*/
+typedef struct IQNabs_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNabs_Params;
+
+/* Function call : I32_IQ _IQNpow(I32_IQ x, I32_IQ y, U32_IQ qfmt);*/
+typedef struct IQNpow_Params{
+                              unsigned int A_InArrID1;
+                              unsigned int B_InArrID2;
+                              unsigned int qfmt;
+                              int OutArrID1;
+                              unsigned int   n;
+                             }IQNpow_Params;
+
+/* Function call : float _IQNtoF(I32_IQ input, U32_IQ qfmt); */
+typedef struct IQNtoF_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int  OutArrID1;
+                              unsigned int   n;
+                             }IQNtoF_Params;
+
+/* Function call : I32_IQ _FtoIQN(float input, U32_IQ qfmt); */
+typedef struct FtoIQN_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }FtoIQN_Params;
+
+typedef struct IQN_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQN_Params;
+
+typedef struct IQNint_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNint_Params;
+
+typedef struct IQNfrac_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNfrac_Params;
+
+typedef struct IQXtoIQY_Params{
+                               unsigned int InArrID1;
+                               int x;
+                               int y;
+                               unsigned int OutArrID1;
+                               unsigned int   n;
+                             }IQXtoIQY_Params;
+
+
+
+/* ***********************************************************************************/
+/* Parameter structure defintiions for the FastRTS library functions                 */
+/* ***********************************************************************************/
+
+/* Function call : float addsp_i(float x, float y) */
+typedef struct addsp_i_Params{
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int OutArrID1;
+                               unsigned int  n;     
+                              }addsp_i_Params;
+
+/* Function call : float subsp_i(float x, float y) */
+typedef struct subsp_i_Params{
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int OutArrID1;
+                               unsigned int  n;     
+                              }subsp_i_Params;
+
+/* Function call : float mpysp_i(float x, float y) */
+typedef struct mpysp_i_Params{
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }mpysp_i_Params;
+
+/* Function call : float recipsp_i(float x)*/
+typedef struct divsp_i_Params{
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }divsp_i_Params;
+
+/* Function call : float recipsp_i(float x)*/
+typedef struct recipsp_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }recipsp_i_Params;
+
+/* Function call : float sqrtsp_i(float x)*/
+typedef struct sqrtsp_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }sqrtsp_i_Params;
+
+/* Function call : Float intsp_i(int x)*/
+typedef struct intsp_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }intsp_i_Params;
+
+/* Function call : int intsp_i(float x) */
+typedef struct spint_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int   OutArrID1;
+                               unsigned int  n;   
+                              }spint_i_Params;
+
+/* Function call : float uintsp_i(unsigned int x)*/
+typedef struct uintsp_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }uintsp_i_Params;
+
+/* Function call : Unsigned int spuint_i(float x)*/
+typedef struct spuint_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;      
+                              }spuint_i_Params;
+
+/* Function call : double atandp(double z) */
+typedef struct atandp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }atandp_Params;
+
+/* Function call : float atansp(float z);*/
+typedef struct atansp_Params{
+                             unsigned int z_InArrID1;
+                             unsigned int OutArrID1;
+                             unsigned int   n;
+                             }atansp_Params;
+
+/* Function call : double atan2dp( double y, double x );*/
+typedef struct  atan2dp_Params{
+                              unsigned int y_InArrID1;
+                              unsigned int x_InArrID2;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }atan2dp_Params;
+
+/* Function call : float atan2sp( float y, float x );*/
+typedef struct atan2sp_Params{
+                              unsigned int y_InArrID1;
+                              unsigned int x_InArrID2;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }atan2sp_Params;
+
+/* Function call : double cosdp( double z );*/
+typedef struct cosdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }cosdp_Params;
+
+
+/* Function call : float cossp( float z );*/
+typedef struct cossp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }cossp_Params;
+
+
+/* Function call : double exp( double z ) ;*/
+typedef struct expdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }expdp_Params; 
+/* Function call : float expf( float z ) ;*/
+typedef struct expsp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }expsp_Params;
+
+/* Function call : double exp10( double z ) ;*/
+typedef struct exp10dp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }exp10dp_Params;
+
+/* Function call : float exp10sp( float z );*/
+typedef struct exp10sp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }exp10sp_Params;
+
+/* Function call : double exp2dp( double z );*/
+typedef struct exp2dp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }exp2dp_Params;
+
+/* Function call : float exp2sp( float z );*/
+typedef struct exp2sp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }exp2sp_Params;
+
+/* Function call : double logdp( double z );*/
+typedef struct logdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }logdp_Params;
+
+/* Function call : float logsp( float z );*/
+typedef struct logsp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }logsp_Params;
+
+/* Function call : double log10dp( double z );*/
+typedef struct log10dp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }log10dp_Params;
+
+/* Function call : float log10sp( float z );*/
+typedef struct log10sp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }log10sp_Params;
+
+/* Function call : double log2dp( double z );*/
+typedef struct log2dp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }log2dp_Params;
+
+/* Function call : float log2sp( float z ) ;*/
+typedef struct log2sp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }log2sp_Params;
+/* Function call : double powdp(double x double y);*/
+typedef struct  powdp_Params{
+                              unsigned int x_InArrID1;
+                              unsigned int y_InArrID2;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }powdp_Params;
+/* Function call : float powsp(float x, float y);*/
+typedef struct  powsp_Params{
+                              unsigned int x_InArrID1;
+                              unsigned int y_InArrID2;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }powsp_Params;
+
+/* Function call : double recipdp( double z ); */
+typedef struct recipdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }recipdp_Params;
+
+/* Function call : float recipsp( float z );*/
+typedef struct recipsp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }recipsp_Params;
+
+/* Function call : double rsqrtdp( double z );*/
+typedef struct rsqrtdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }rsqrtdp_Params;
+
+/* Function call : float rsqrtsp( float z );*/
+typedef struct rsqrtsp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }rsqrtsp_Params;
+
+/* Function call : double sindp( double z);*/
+typedef struct sindp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }sindp_Params;
+
+/* Function call : float sinsp(float x);*/
+typedef struct sinsp_Params{
+                            unsigned int x_InArrID1;
+                            unsigned int OutArrID1;
+                            unsigned int   n;
+                            }sinsp_Params;
+
+/* Function call : double divdp( double x, double y );*/
+typedef struct divdp_Params{
+                             unsigned int x_InArrID1;
+                             unsigned int y_InArrID2;
+                             unsigned int OutArrID1;
+                             unsigned int   n;
+                             }divdp_Params;
+/* Function call : float divsp( float x, float y );*/
+typedef struct divsp_Params{
+                             unsigned int x_InArrID1;
+                             unsigned int y_InArrID2;
+                             unsigned int OutArrID1;
+                             unsigned int   n;
+                             }divsp_Params;
+                                                         
+/* Function call : double sqrtdp( double z );*/
+typedef struct sqrtdp_Params{
+                             unsigned int z_InArrID1;
+                             unsigned int OutArrID1;
+                             unsigned int   n;
+                             }sqrtdp_Params;
+
+/* Function call : float sqrtsp( float z );*/
+typedef struct sqrtsp_Params{
+                            unsigned int z_InArrID1;
+                            unsigned int OutArrID1;
+                            unsigned int   n;
+                           }sqrtsp_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Vision Library functions                    */
+/*                     Added by Pramod                                               */
+/*************************************************************************************/
+
+/* Function Call: int VLIB_integralImage8(unsigned char* restrict pIn,unsigned short  inCols,unsigned short  inRows,unsigned int* restrict pLastLine,   
+															unsigned int* restrict pOut)*/
+typedef struct VLIB_integralImage8_Params{
+                                         unsigned int pIn_InArrID1;         /* Input Image inCols x inRows */
+                                         unsigned short  inCols;            /* Number of inCols */
+					 unsigned short  inRows;            /* Number of inRowss */
+                                         unsigned int pLastLine_InArrID2;   /* 32-bit carry-over buffer */
+                                         unsigned int pOut_OutArrID1;       /* 32-bit output buffer */
+                                         }VLIB_integralImage8_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Other IMG Library functions                */
+/*                 Functionality Added by Pramod                                     */
+/*		   Kernel Provided by Gagan					     */
+/*************************************************************************************/
+
+/* Function Call: int IMG_RGB_To_Y(unsigned char* restrict src, unsigned char * restrict dst, unsigned int count)*/
+
+typedef struct IMG_RGB_To_Y_Params{
+				  unsigned int src_InArrID1;              /* Input RGB image         */
+				  unsigned int dst_OutArrID1;             /* Output greyscale image  */
+				  unsigned int count;			  /* Total Pixels	     */
+				  }IMG_RGB_To_Y_Params;
+
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Other DSP Library functions                */
+/*                 Functionality Added by Pramod                                     */
+/*		   								     */
+/*************************************************************************************/
+
+/* Function Call: int C6accel_DSP_dft_f(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_src,       
+                          unsigned char * restrict ptr_dst,       
+			  int cols, int rows,                     
+			  int srcMatFlag,		         
+			  int dstMatFlag,			  
+			  int dxtType,				 
+			  int nonZeroRows, 			  
+			  unsigned char *restrict pWorkingBuf,    
+                          unsigned char *restrict pWorkingBuf2)                         */
+
+typedef struct DSP_dft_f_Params{
+				  unsigned int src_InArrID1;              /* Pointer to input image */
+				  unsigned int dst_OutArrID1;             /* Pointer to Greyscale output image    */
+				  int dxtType;				  /* Type of action to take */ 
+				  int nonZeroRows; 			  /* Count of non-zero rows */
+				  IplImage src;
+				  IplImage dst;
+				  }DSP_dft_f_Params;
+
+			  
+			  
+/******************************************************************************
+ *  ======== C6ACCEL_TI_IC6ACCEL ========
+ *  Our implementation of the IUNIVERSAL interface
+ *****************************************************************************/
+extern IUNIVERSAL_Fxns C6ACCEL_TI_IC6ACCEL;
+extern IALG_Fxns C6ACCEL_TI_IALG;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/*
+ *  @(#) ti.C6ACCEL; 1, 0, 0,10; 5-7-2010 17:59:00; 
+ */
+
+
Binary files c6accel_1_00_00_04_async0/dsp/alg/pjt/c6accel_c64P_release/C6Accel_DFT.o64P and c6accel_1_00_00_04_async/dsp/alg/pjt/c6accel_c64P_release/C6Accel_DFT.o64P differ
Binary files c6accel_1_00_00_04_async0/dsp/alg/pjt/c6accel_c64P_release/C6Accel_gen_twiddle_fft16x16.o64P and c6accel_1_00_00_04_async/dsp/alg/pjt/c6accel_c64P_release/C6Accel_gen_twiddle_fft16x16.o64P differ
Binary files c6accel_1_00_00_04_async0/dsp/alg/pjt/c6accel_c64P_release/C6Accel_gen_twiddle_ifft16x16.o64P and c6accel_1_00_00_04_async/dsp/alg/pjt/c6accel_c64P_release/C6Accel_gen_twiddle_ifft16x16.o64P differ
Binary files c6accel_1_00_00_04_async0/dsp/alg/pjt/c6accel_c64P_release/C6Accel_integral.o64P and c6accel_1_00_00_04_async/dsp/alg/pjt/c6accel_c64P_release/C6Accel_integral.o64P differ
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/pjt/C6Accel.pjt c6accel_1_00_00_04_async/dsp/alg/pjt/C6Accel.pjt
--- c6accel_1_00_00_04_async0/dsp/alg/pjt/C6Accel.pjt	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/dsp/alg/pjt/C6Accel.pjt	2010-08-14 17:17:16.000000000 -0500
@@ -18,19 +18,19 @@
 Source="..\src\C6Accel.c"
 
 ["c6accel_c64p_debug" Settings]
-FinalBuildCmd=cl6x -z -l lnk.cmd -r -h -g _C6ACCEL_TI_IALG -g _UNIVERSAL_TI_PARAMS -g _C6ACCEL_TI_IC6ACCEL c6accel_c64p_debug\*.obj -o c6accel_c64p_debug\c6accel_c64p_debug.o64P -l"..\..\libs\dsplib64plus.lib" -l="..\..\libs\C64P_LIBPLUS.lib" -l="..\..\libs\fastrts64x.lib" -l"..\..\libs\imglib2.l64P" -l"..\..\libs\IQmath_c64x+.lib" -l"..\..\libs\IQmath_RAM_c64x+.lib" -l"..\..\libs\fastrts64x.lib";Run=Always
+FinalBuildCmd=cl6x -z -l lnk.cmd -r -h -g _C6ACCEL_TI_IALG -g _UNIVERSAL_TI_PARAMS -g _C6ACCEL_TI_IC6ACCEL c6accel_c64p_debug\*.obj -o c6accel_c64p_debug\c6accel_c64p_debug.o64P -l"..\..\libs\dsplib64plus.lib" -l="..\..\libs\C64P_LIBPLUS.lib" -l="..\..\libs\fastrts64x.lib" -l"..\..\libs\imglib2.l64P" -l"..\..\libs\IQmath_c64x+.lib" -l"..\..\libs\IQmath_RAM_c64x+.lib" -l"..\..\libs\fastrts64x.lib" -l"../../libs/vlib.l64p";Run=Always
 FinalBuildCmd=ar6x -rq "..\lib\C6accel_c64p\Debug\C6Accel.l64P" c6accel_c64p_debug\c6accel_c64p_debug.o64P;Run=Always
 
 ["c6accel_c64p_release" Settings]
-FinalBuildCmd=cl6x -z -l lnk.cmd -r -h -g _C6ACCEL_TI_IALG -g _UNIVERSAL_TI_PARAMS -g _C6ACCEL_TI_IC6ACCEL c6accel_c64p_release\*.obj -o c6accel_c64p_release\c6accel_c64p_release.o64P -l"..\..\libs\dsplib64plus.lib" -l="..\..\libs\C64P_LIBPLUS.lib" -l="..\..\libs\fastrts64x.lib" -l"..\..\libs\imglib2.l64P" -l"..\..\libs\IQmath_c64x+.lib" -l"..\..\libs\IQmath_RAM_c64x+.lib" -l"..\..\libs\fastrts64x.lib";Run=Always
+FinalBuildCmd=cl6x -z -l lnk.cmd -r -h -g _C6ACCEL_TI_IALG -g _UNIVERSAL_TI_PARAMS -g _C6ACCEL_TI_IC6ACCEL c6accel_c64p_release\*.obj -o c6accel_c64p_release\c6accel_c64p_release.o64P -l"..\..\libs\dsplib64plus.lib" -l="..\..\libs\C64P_LIBPLUS.lib" -l="..\..\libs\fastrts64x.lib" -l"..\..\libs\imglib2.l64P" -l"..\..\libs\IQmath_c64x+.lib" -l"..\..\libs\IQmath_RAM_c64x+.lib" -l"..\..\libs\fastrts64x.lib" -l"../../libs/vlib.l64p";Run=Always
 FinalBuildCmd=ar6x -rq "..\lib\C6accel_c64p\Release\C6Accel.l64P" c6accel_c64p_release\c6accel_c64p_release.o64P;Run=Always
 
 ["c6accel_c674_debug" Settings]
-FinalBuildCmd=cl6x -z -l lnk.cmd -r -h -g _C6ACCEL_TI_IALG -g _UNIVERSAL_TI_PARAMS -g _C6ACCEL_TI_IC6ACCEL c6accel_c674_debug\*.obj -o c6accel_c674_debug\c6accel_c674_debug.o674 -l"..\..\libs\dsplib64plus.lib" -l="..\..\libs\C64P_LIBPLUS.lib" -l="..\..\libs\fastrts64x.lib" -l"..\..\libs\imglib2.l64P" -l"..\..\libs\IQmath_c64x+.lib" -l"..\..\libs\IQmath_RAM_c64x+.lib" -l"..\..\libs\fastrts67x.lib" -l"..\..\libs\dsplib674x.lib";Run=Always
+FinalBuildCmd=cl6x -z -l lnk.cmd -r -h -g _C6ACCEL_TI_IALG -g _UNIVERSAL_TI_PARAMS -g _C6ACCEL_TI_IC6ACCEL c6accel_c674_debug\*.obj -o c6accel_c674_debug\c6accel_c674_debug.o674 -l"..\..\libs\dsplib64plus.lib" -l="..\..\libs\C64P_LIBPLUS.lib" -l="..\..\libs\fastrts64x.lib" -l"..\..\libs\imglib2.l64P" -l"..\..\libs\IQmath_c64x+.lib" -l"..\..\libs\IQmath_RAM_c64x+.lib" -l"..\..\libs\fastrts67x.lib" -l"..\..\libs\dsplib674x.lib" -l"../../libs/vlib.l64p";Run=Always
 FinalBuildCmd=ar6x -rq "..\lib\C6accel_c674\Debug\C6Accel.l674" c6accel_c674_debug\c6accel_c674_debug.o674;Run=Always
 
 ["c6accel_c674_release" Settings]
-FinalBuildCmd=cl6x -z -l lnk.cmd -r -h -g _C6ACCEL_TI_IALG -g _UNIVERSAL_TI_PARAMS -g _C6ACCEL_TI_IC6ACCEL c6accel_c674_release\*.obj -o c6accel_c674_release\c6accel_c674_release.o674 -l"..\..\libs\dsplib64plus.lib" -l="..\..\libs\C64P_LIBPLUS.lib" -l="..\..\libs\fastrts64x.lib" -l"..\..\libs\imglib2.l64P" -l"..\..\libs\IQmath_c64x+.lib" -l"..\..\libs\IQmath_RAM_c64x+.lib" -l"..\..\libs\fastrts67x.lib" -l"..\..\libs\dsplib674x.lib";Run=Always
+FinalBuildCmd=cl6x -z -l lnk.cmd -r -h -g _C6ACCEL_TI_IALG -g _UNIVERSAL_TI_PARAMS -g _C6ACCEL_TI_IC6ACCEL c6accel_c674_release\*.obj -o c6accel_c674_release\c6accel_c674_release.o674 -l"..\..\libs\dsplib64plus.lib" -l="..\..\libs\C64P_LIBPLUS.lib" -l="..\..\libs\fastrts64x.lib" -l"..\..\libs\imglib2.l64P" -l"..\..\libs\IQmath_c64x+.lib" -l"..\..\libs\IQmath_RAM_c64x+.lib" -l"..\..\libs\fastrts67x.lib" -l"..\..\libs\dsplib674x.lib" -l"../../libs/vlib.l64p";Run=Always
 FinalBuildCmd=ar6x -rq "..\lib\C6accel_c674\Release\C6Accel.l674" c6accel_c674_release\c6accel_c674_release.o674;Run=Always
 
 ["Archiver" Settings: "c6accel_c64p_debug"]
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/pjt/Makefile c6accel_1_00_00_04_async/dsp/alg/pjt/Makefile
--- c6accel_1_00_00_04_async0/dsp/alg/pjt/Makefile	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/dsp/alg/pjt/Makefile	2010-08-16 00:34:18.000000000 -0500
@@ -2,6 +2,12 @@
 
 # Comment this out if you want to see full compiler and linker output.
 #VERBOSE = @
+
+# uncomment the lines below if you are using VLIB. The library file must be stored at [c6accel_Base_Dir]/dsp/libs
+#VLIB = -l"../../libs/vlib.l64p"
+
+# uncomment the lines below if you are using CXCORE. The library file must be stored at [c6accel_Base_Dir]/dsp/libs
+#CXCORE = -l"../../libs/cxcore.lib"
 
 # Which compiler flags should be used?
 BUILD_TYPE=release
@@ -13,18 +19,37 @@
 
 
 ifeq ($(DSP_ISA),64P)
-EXT		= 64P
-LD_LIBS = -l"../../libs/dsplib64plus.lib" -l="../../libs/C64P_LIBPLUS.lib" -l="../../libs/fastrts64x.lib" -l"../../libs/imglib2.l64P" -l"../../libs/IQmath_c64x+.lib" -l"../../libs/IQmath_RAM_c64x+.lib"
+EXT		= 64P
+#VLIB has been added by Pramod
+LD_LIBS = -l"../../libs/dsplib64plus.lib" -l="../../libs/C64P_LIBPLUS.lib" -l="../../libs/fastrts64x.lib" -l"../../libs/imglib2.l64P" -l"../../libs/IQmath_c64x+.lib" -l"../../libs/IQmath_RAM_c64x+.lib"
+ifdef VLIB 
+LD_LIBS        += $(VLIB)
+endif
+ifdef CXCORE 
+LD_LIBS        += $(CXCORE)
+endif
 ifeq ($(BUILD_TYPE), release)
 LTARGET		= ../lib/C6accel_c64P/Release/C6Accel.l64P
 ATARGET		= ../lib/C6accel_c64P/Release/C6Accel.a64P
-C_FLAGS	       += -mv6400+ -o3 -eoo$(EXT)
+C_FLAGS	       += -mv6400+ -o3 -eoo$(EXT)
+ifdef VLIB 
+C_FLAGS        += -DUSE_VLIB
+endif
+ifdef CXCORE 
+C_FLAGS        += -DUSE_CXCORE
+endif
 OBJDIR		= c6accel_c64P_release
 PARTIAL		= $(OBJDIR)/c6accel_c64p_release.o64P
 else
 LTARGET		= ../lib/C6accel_c64P/Debug/C6Accel.l64P
 ATARGET		= ../lib/C6accel_c64P/Debug/C6Accel.a64P
-C_FLAGS	       += -mv6400+ -g -eoo$(EXT)
+C_FLAGS	       += -mv6400+ -g -eoo$(EXT)
+ifdef VLIB 
+C_FLAGS        += -DUSE_VLIB
+endif
+ifdef CXCORE 
+C_FLAGS        += -DUSE_CXCORE
+endif
 OBJDIR		= c6accel_c64P_debug
 PARTIAL		= $(OBJDIR)/c6accel_c64p_debug.o64P
 endif
@@ -32,18 +57,37 @@
 
 ifeq ($(DSP_ISA),674)
 EXT		= 674
-C_FLAGS        += -DDEVICE_FLOAT 
-LD_LIBS = -l"../../libs/dsplib64plus.lib" -l="../../libs/C64P_LIBPLUS.lib" -l="../../libs/fastrts64x.lib" -l"../../libs/imglib2.l64P" -l"../../libs/IQmath_c64x+.lib" -l"../../libs/IQmath_RAM_c64x+.lib" -l"../../libs/fastrts67x.lib" -l"../../libs/dsplib674x.lib"
+C_FLAGS        += -DDEVICE_FLOAT 
+#VLIB has been added by Pramod
+LD_LIBS = -l"../../libs/dsplib64plus.lib" -l="../../libs/C64P_LIBPLUS.lib" -l="../../libs/fastrts64x.lib" -l"../../libs/imglib2.l64P" -l"../../libs/IQmath_c64x+.lib" -l"../../libs/IQmath_RAM_c64x+.lib" -l"../../libs/fastrts67x.lib" -l"../../libs/dsplib674x.lib"
+ifdef VLIB 
+LD_LIBS        += $(VLIB)
+endif
+ifdef CXCORE 
+LD_LIBS        += $(CXCORE)
+endif
 ifeq ($(BUILD_TYPE), release)
 LTARGET		= ../lib/C6accel_c674/Release/C6Accel.l674
 ATARGET		= ../lib/C6accel_c674/Release/C6Accel.a674
-C_FLAGS	       += -mv6740 -o3 -eoo$(EXT)
+C_FLAGS	       += -mv6740 -o3 -eoo$(EXT)
+ifdef VLIB 
+C_FLAGS        += -DUSE_VLIB
+endif
+ifdef CXCORE 
+C_FLAGS        += -DUSE_CXCORE
+endif
 OBJDIR		= c6accel_c674_release
 PARTIAL		= $(OBJDIR)/c6accel_c674_release.o674
 else
 LTARGET		= ../lib/C6accel_c674/Debug/C6Accel.l674
 ATARGET		= ../lib/C6accel_c674/Debug/C6Accel.a674
-C_FLAGS	       += -mv6740 -g -eoo$(EXT)
+C_FLAGS	       += -mv6740 -g -eoo$(EXT)
+ifdef VLIB 
+C_FLAGS        += -DUSE_VLIB
+endif
+ifdef CXCORE 
+C_FLAGS        += -DUSE_CXCORE
+endif
 OBJDIR		= c6accel_c674_debug
 PARTIAL		= $(OBJDIR)/c6accel_c674_debug.o674
 endif
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/src/C6Accel.c c6accel_1_00_00_04_async/dsp/alg/src/C6Accel.c
--- c6accel_1_00_00_04_async0/dsp/alg/src/C6Accel.c	2010-07-26 16:40:17.000000000 -0500
+++ c6accel_1_00_00_04_async/dsp/alg/src/C6Accel.c	2010-08-15 23:46:10.000000000 -0500
@@ -837,6 +837,26 @@
                                         C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->Col,
                                         C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->Row);
                      }
+                 break;
+		 /* This case is added by Pramod */
+		 case (SOBEL_3X3_8_16_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_sobel_3x3_8_16_Params *C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr;
+                    C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr= pFnArray;
+                    /*Parameter check*/
+                    if (((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->indata_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->outdata_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Col)%2 != 0)|
+                        (((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Col)*((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Row)-2))%8 !=0)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_sobel_3x3_8_16((const unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->indata_InArrID1].buf,
+                                       (unsigned short *)outBufs->descs[C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->outdata_OutArrID1].buf,
+                                        C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Col,
+                                        C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Row);
+                     }
                  break;
                  case (SOBEL_3X3_16_FXN_ID):{
                     /* Unmarshal Parameters */
@@ -2929,18 +2949,106 @@
               case(PWRCNTRLLIB_FXN_ID):
                    return(IUNIVERSAL_EFXNIDFAIL);
               case(AUDSPECHLIB_FXN_ID):
-                   return(IUNIVERSAL_EFXNIDFAIL);
-              default:
+                   return(IUNIVERSAL_EFXNIDFAIL);
+#ifdef USE_VLIB
+	      case(VLIB_FXN_ID):
+     		/* VLIB functions */
+                switch ( fxnID & fxnidMsk){
+                  case(INTEGRALIMAGE_8_FXN_ID):{
+                    /* Unmarshal Parameters */
+		    VLIB_integralImage8_Params *C6ACCEL_TI_VLIB_integralImage8_paramPtr;
+                    C6ACCEL_TI_VLIB_integralImage8_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_VLIB_integralImage8_paramPtr->pIn_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_VLIB_integralImage8_paramPtr->pLastLine_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_VLIB_integralImage8_paramPtr->pOut_OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else 
+                        /* Call underlying kernel */
+                        VLIB_integralImage8( (unsigned char*)inBufs->descs[C6ACCEL_TI_VLIB_integralImage8_paramPtr->pIn_InArrID1].buf,
+                                       	   C6ACCEL_TI_VLIB_integralImage8_paramPtr->inCols,
+					   C6ACCEL_TI_VLIB_integralImage8_paramPtr->inRows,
+                                           (unsigned int *)inBufs->descs[C6ACCEL_TI_VLIB_integralImage8_paramPtr->pLastLine_InArrID2].buf,
+                                           (unsigned int *)outBufs->descs[C6ACCEL_TI_VLIB_integralImage8_paramPtr->pOut_OutArrID1].buf);
+                   }
+		  break;
+		  default:
+	  	    /*Error caused due to passing of an invalid ID*/
+		    return(IUNIVERSAL_EFXNIDFAIL);
+                }
+	        break;
+#endif
+                default:
                    return(IUNIVERSAL_EFXNIDFAIL);
             }
           break;
           case (OTHER):
               switch (( fxnID & fxntypMsk)>>FXNTYP_TAG_SHIFT){
               /* Non-TI vendors can add their kernels in this section */
-                   case (DSPLIB_FXN_ID):
-                        return(IUNIVERSAL_EFXNIDFAIL);
-                   case (IMGLIB_FXN_ID):
-                        return(IUNIVERSAL_EFXNIDFAIL);
+                   case (DSPLIB_FXN_ID):
+   		     switch(fxnID & fxnidMsk) {
+		       case (DFT_F_FXN_ID): {
+			 char *src, *dst;
+			 /* Unmarshal Parameters */
+			 DSP_dft_f_Params *C6ACCEL_DSP_dft_f_paramPtr;
+                         C6ACCEL_DSP_dft_f_paramPtr = pFnArray;
+			 /* Parameter check */
+                         if (((C6ACCEL_DSP_dft_f_paramPtr->src_InArrID1)>INBUF15)|
+                             ((C6ACCEL_DSP_dft_f_paramPtr->dst_OutArrID1)>OUTBUF15)){
+                              return(IUNIVERSAL_EPARAMFAIL);
+                         }
+                         else {
+                           /* Call underlying kernel */
+			   /* Parameter check is done in the library*/
+                           /* Call underlying kernel */
+   			   src = C6ACCEL_DSP_dft_f_paramPtr->src.imageData;
+  			   dst = C6ACCEL_DSP_dft_f_paramPtr->dst.imageData;
+			   C6ACCEL_DSP_dft_f_paramPtr->src.imageData = (char *)inBufs->descs[C6ACCEL_DSP_dft_f_paramPtr->src_InArrID1].buf;
+  			   C6ACCEL_DSP_dft_f_paramPtr->dst.imageData = (char *)outBufs->descs[C6ACCEL_DSP_dft_f_paramPtr->dst_OutArrID1].buf;
+			   #ifdef USE_CXCORE
+			   cvDFT( &C6ACCEL_DSP_dft_f_paramPtr->src,
+			        &C6ACCEL_DSP_dft_f_paramPtr->dst,
+			     	C6ACCEL_DSP_dft_f_paramPtr->dxtType,
+				C6ACCEL_DSP_dft_f_paramPtr->nonZeroRows
+			        );
+			   #else
+			   return(IUNIVERSAL_EFXNIDFAIL);
+			   #endif
+			   C6ACCEL_DSP_dft_f_paramPtr->src.imageData = src;
+  			   C6ACCEL_DSP_dft_f_paramPtr->dst.imageData = dst;
+			   }
+			 }		         
+			 break;
+		       default:
+			 /* Error caused due to passing of an invalid ID */
+			 return(IUNIVERSAL_EFXNIDFAIL);
+                       }
+		   break;
+                   case (IMGLIB_FXN_ID):
+		     switch(fxnID & fxnidMsk) {
+		       case (RGB_TO_Y_FXN_ID): {
+			 /* Unmarshal Parameters */   
+                         IMG_RGB_To_Y_Params *C6ACCEL_TI_IMG_RGB_To_Y_paramPtr;
+                         C6ACCEL_TI_IMG_RGB_To_Y_paramPtr = pFnArray;
+                         /* Parameter check */
+                         if(((C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->src_InArrID1)>INBUF15)|
+                            ((C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->dst_OutArrID1)>INBUF15)){
+                            return(IUNIVERSAL_EPARAMFAIL);
+                          }
+                         else
+                         /* Call underlying kernel */
+                            IMG_RGB_To_Y((unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->src_InArrID1].buf,
+                                         (unsigned char *)outBufs->descs[C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->dst_OutArrID1].buf,
+                                         C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->count);
+                          
+			}
+			break;
+		       default:
+			 /* Error caused due to passing of an invalid ID */
+			 return(IUNIVERSAL_EFXNIDFAIL);
+		      }
+                   break;     
                    case(MATHLIB_FXN_ID):
                         return(IUNIVERSAL_EFXNIDFAIL);
                    case (ANALYTICSLIB_FXN_ID):
@@ -2953,7 +3061,8 @@
                         return(IUNIVERSAL_EFXNIDFAIL);
                    default:
                       return(IUNIVERSAL_EFXNIDFAIL);
-                }
+                }
+	 break;
          default:
                 return(IUNIVERSAL_EFXNIDFAIL);
        }
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/src/C6Accel.c~ c6accel_1_00_00_04_async/dsp/alg/src/C6Accel.c~
--- c6accel_1_00_00_04_async0/dsp/alg/src/C6Accel.c~	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/alg/src/C6Accel.c~	2010-08-15 23:45:51.000000000 -0500
@@ -0,0 +1,3159 @@
+/*******************************************************************************
+**+--------------------------------------------------------------------------+**
+ *                                                                            **
+ * Copyright (c) 2010, Texas Instruments Incorporated                         **
+ * All rights reserved.                                                       **
+ *                                                                            **
+**+--------------------------------------------------------------------------+**
+ *           ======== C6ACCEL.c ========                                      **
+ *           Universal "C6ACCEL" xdais algorithm.                             **
+ *                                                                            **
+ *  This file contains an implementation of the C6Accel xdais algorithm using **
+ *  IUNIVERSAL interface defined by xDM.                                      **
+*******************************************************************************/
+
+/* Include Files */
+#include <xdc/std.h>
+#include <string.h>
+#include <ti/xdais/dm/iuniversal.h>
+
+/* Header Intrinsic to xdais algorithm*/
+#include "C6Accel.h"
+
+#ifdef __TI_COMPILER_VERSION__
+/* xDAIS Rule 13 - this #pragma should only apply to TI codegen */
+#pragma CODE_SECTION(C6ACCEL_TI_control, ".text:algControl")
+#pragma CODE_SECTION(C6ACCEL_TI_process, ".text:algProcess")
+#pragma CODE_SECTION(C6ACCEL_TI_initObj, ".text:algInit")
+#pragma CODE_SECTION(C6ACCEL_TI_free,    ".text:algFree")
+#pragma CODE_SECTION(C6ACCEL_TI_alloc,   ".text:algAlloc")
+#endif
+
+/* Application-Algorithm Interface file includes */
+#include "iC6Accel_ti.h"
+#include "iC6Accel_ti_priv.h"
+
+/* Global function to determine if number is power of two*/
+static unsigned short IsPowOfTwo( unsigned long number);
+
+/* Maintain version string for future releases */
+#define C6ACCEL_VERSIONSTRING "1.00.00.04"
+
+/* IALGFXN definition */ 
+#define IALGFXNS                                                      \
+    &C6ACCEL_TI_IALG,         /* module ID */                         \
+    NULL,                     /* activate */                          \
+    C6ACCEL_TI_alloc,         /* alloc */                             \
+    NULL,                     /* control (NULL => no control ops) */  \
+    NULL,                     /* deactivate */                        \
+    C6ACCEL_TI_free,          /* free */                              \
+    C6ACCEL_TI_initObj,       /* init */                              \
+    NULL,                     /* moved */                             \
+    NULL                      /* numAlloc (NULL => IALG_MAXMEMRECS) */
+
+/****************************************************************************+
+ *           ======== C6ACCEL_TI_I C6ACCEL ========
+ *  This structure defines TI's implementation of the IUNIVERSAL interface
+ *  for the C6ACCEL_TI module.
+ ***************************************************************************/
+IUNIVERSAL_Fxns C6ACCEL_TI_IC6ACCEL = {
+    {IALGFXNS},
+    C6ACCEL_TI_process,
+    C6ACCEL_TI_control,
+};
+
+/***************************************************************************+
+ *           ======== C6ACCEL_TI_IALG ========
+ *  This structure defines TI's implementation of the IALG interface
+ *  for the C6ACCEL_TI module.
+ ***************************************************************************/
+#ifdef __TI_COMPILER_VERSION__
+/* satisfy xDAIS symbol requirement without any overhead */
+asm("_C6ACCEL_TI_IALG .set _C6ACCEL_TI_IC6ACCEL");
+
+#else
+
+/***************************************************************************+
+ *  We duplicate the structure here to allow this code to be compiled and
+ *  run using non-TI toolchains at the expense of unnecessary data space
+ *  consumed by the definition below.
+ **************************************************************************/
+IALG_Fxns C6ACCEL_TI_IALG = {      /* module_vendor_interface */
+    IALGFXNS
+};
+
+#endif
+
+/*Standard iUniversal params defintion */
+IUNIVERSAL_Params UNIVERSAL_TI_PARAMS = {
+    sizeof(IUNIVERSAL_Params),       /* size */
+};
+
+/**************************************************************************+
+ *  ========C6ACCEL_TI_alloc ========
+ *  Return a table of memory descriptors that describe the memory needed
+ *  to construct our object.
+ **************************************************************************/
+/* ARGSUSED - this line tells the TI compiler not to warn about unused args. */
+Int C6ACCEL_TI_alloc(const IALG_Params *algParams,
+    IALG_Fxns **pf, IALG_MemRec memTab[]){
+   /* Request memory for my object */
+    memTab[0].size = sizeof(C6ACCEL_TI_Obj);
+    memTab[0].alignment = 0;
+    memTab[0].space = IALG_EXTERNAL;
+    memTab[0].attrs = IALG_PERSIST;
+
+    return (1);
+}
+
+/*************************************************************************+
+ *  ======== C6ACCEL_TI_free ========
+ *  Return a table of memory pointers that should be freed.  Note
+ *  that this should include *all* memory requested in the
+ *  alloc operation above.
+ *************************************************************************/
+/* ARGSUSED - this line tells the TI compiler not to warn about unused args. */
+Int C6ACCEL_TI_free(IALG_Handle handle, IALG_MemRec memTab[]){
+    /*
+     * Because our internal object size doesn't depend on create
+     * params, we can just leverage the algAlloc() call with default
+     * (NULL) create params.
+     */
+
+    return (C6ACCEL_TI_alloc(NULL, NULL, memTab));
+}
+
+/**************************************************************************+
+ *  ======== C6ACCEL_TI_initObj ========
+ *  Initialize the memory allocated on our behalf (including our object).
+ ***************************************************************************/
+/* ARGSUSED - this line tells the TI compiler not to warn about unused args. */
+Int C6ACCEL_TI_initObj(IALG_Handle handle, const IALG_MemRec memTab[],
+    IALG_Handle p, const IALG_Params *algParams){
+    const IUNIVERSAL_Params *params = (IUNIVERSAL_Params *)algParams;
+
+    if (params == NULL) {
+        params = &UNIVERSAL_TI_PARAMS;
+    }
+    return (IALG_EOK);
+}
+
+/**********************************************************************************+
+ *  ======== C6ACCEL_TI_process ========
+ Process call that contains the Library functions to be executed in the application
+ **********************************************************************************/
+/* ARGSUSED - this line tells the TI compiler not to warn about unused args. */
+XDAS_Int32 C6ACCEL_TI_process(IUNIVERSAL_Handle handle,
+        XDM1_BufDesc *inBufs, XDM1_BufDesc *outBufs, XDM1_BufDesc *inOutBufs,
+        IUNIVERSAL_InArgs *inArgs, IUNIVERSAL_OutArgs *outArgs)
+{
+  const IC6Accel_InArgs *CInArgs =(IC6Accel_InArgs *)inArgs;
+  void   *pFnArray;
+  Int32 fxnID;
+  Int32 i,j;
+
+  /* Mask Variables to extract information from Function IDs */
+  Int32 vendorMsk= VENDOR_MASK;
+  Int32 fxntypMsk= FXN_TYP_MASK;
+  Int32 fxnidMsk= FXN_ID_MASK;
+
+   /* Execute the chain of functions wrapped in the process API call  */
+   for( i = 0; i < CInArgs->Num_fxns; i++ ){
+
+   /* The pFnArray is at an offset in the inArgs structure and so does not need cache management*/
+   pFnArray = (void*)((XDAS_Int8*)CInArgs + CInArgs->fxn[i].Param_ptr_offset);
+   fxnID = CInArgs->fxn[i].FxnID;
+
+   /*Check to see if NULL_INDEX has not been passed*/
+   if (fxnID == NULL_INDEX){
+       return(IUNIVERSAL_EFXNIDFAIL);
+    }
+   else{
+       /* Pick libraries based on vendor */
+       switch ((fxnID & vendorMsk)>>VENDOR_TAG_SHIFT){
+          case (TI):
+          /* Pick the Library function type (eg : IMGLIB function)  */
+          switch (( fxnID & fxntypMsk)>>FXNTYP_TAG_SHIFT){
+           /* DSPLIB functions */
+             case (DSPLIB_FXN_ID):
+             switch ( fxnID & fxnidMsk){
+                 case (FFT16x16_FXN_ID):{
+                   /* Unmarshal Parameters */
+                   DSP_fft16x16_Params *C6ACCEL_TI_DSP_fft16x16_paramPtr;
+                   C6ACCEL_TI_DSP_fft16x16_paramPtr= pFnArray;
+                   /* Parameter check */
+                   if (((C6ACCEL_TI_DSP_fft16x16_paramPtr->w_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_fft16x16_paramPtr->x_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_fft16x16_paramPtr->y_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSP_fft16x16_paramPtr->nx)<16)|
+                       ((C6ACCEL_TI_DSP_fft16x16_paramPtr->nx)>65536)|
+                       (IsPowOfTwo(C6ACCEL_TI_DSP_fft16x16_paramPtr->nx) != TRUE)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                    }
+                    else 
+                       /* Call underlying kernel */
+                       DSP_fft16x16( (short *)inBufs->descs[C6ACCEL_TI_DSP_fft16x16_paramPtr->w_InArrID1].buf,
+                                      C6ACCEL_TI_DSP_fft16x16_paramPtr->nx,
+                                     (short *)inBufs->descs[C6ACCEL_TI_DSP_fft16x16_paramPtr->x_InArrID2].buf,
+                                     (short *)outBufs->descs[C6ACCEL_TI_DSP_fft16x16_paramPtr->y_OutArrID1].buf);
+                  }
+                 break;
+                 case (IFFT16x16_FXN_ID ):{
+                    /* Unmarshal Parameters */  
+                    DSP_ifft16x16_Params *C6ACCEL_TI_DSP_ifft16x16_paramPtr;
+                    C6ACCEL_TI_DSP_ifft16x16_paramPtr= pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSP_ifft16x16_paramPtr->w_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSP_ifft16x16_paramPtr->x_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSP_ifft16x16_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_DSP_ifft16x16_paramPtr->nx)<16)|
+                        ((C6ACCEL_TI_DSP_ifft16x16_paramPtr->nx)>65536)|
+                        (IsPowOfTwo(C6ACCEL_TI_DSP_ifft16x16_paramPtr->nx) != TRUE)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                        /* Call underlying kernel */
+                        DSP_ifft16x16((short *)inBufs->descs[C6ACCEL_TI_DSP_ifft16x16_paramPtr->w_InArrID1].buf,
+                                     C6ACCEL_TI_DSP_ifft16x16_paramPtr->nx,
+                                     (short *)inBufs->descs[C6ACCEL_TI_DSP_ifft16x16_paramPtr->x_InArrID2].buf,
+                                     (short *)outBufs->descs[C6ACCEL_TI_DSP_ifft16x16_paramPtr->y_OutArrID1].buf);
+                   }   
+                 break;
+                 case (MAT_MUL_FXN_ID ):{
+                    /* Unmarshal Parameters */
+                    DSP_mat_mul_Params  *C6ACCEL_TI_DSP_mat_mul_paramPtr;
+                    C6ACCEL_TI_DSP_mat_mul_paramPtr= pFnArray;
+                    /*Parameter check
+                    * 1.InArr, OutArr ID checks
+                    * 2.Check for constraints on matrix dimensions
+                    * 3.Condition to check if col of Input 1 is equal to row of Input 2:
+                    * (buf_size Input1)/(buf_size Input2) = (rows of Input1)/(cols of Input 2)
+                    */
+                    if (((C6ACCEL_TI_DSP_mat_mul_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSP_mat_mul_paramPtr->y_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSP_mat_mul_paramPtr->r_OutArrID1)>OUTBUF15)|
+                        ((float)((inBufs->descs[C6ACCEL_TI_DSP_mat_mul_paramPtr->x_InArrID1].bufSize)/
+                        (inBufs->descs[C6ACCEL_TI_DSP_mat_mul_paramPtr->y_InArrID2].bufSize))!=
+                        ((float)(C6ACCEL_TI_DSP_mat_mul_paramPtr->r1/C6ACCEL_TI_DSP_mat_mul_paramPtr->c2)))|
+                        ((C6ACCEL_TI_DSP_mat_mul_paramPtr->c2)<4)|((C6ACCEL_TI_DSP_mat_mul_paramPtr->c2 )% 4 != 0)|
+                        ((C6ACCEL_TI_DSP_mat_mul_paramPtr->c1)<1)|((C6ACCEL_TI_DSP_mat_mul_paramPtr->r1)% 2 != 0)|
+                        ((C6ACCEL_TI_DSP_mat_mul_paramPtr->r1)< 8)|((C6ACCEL_TI_DSP_mat_mul_paramPtr->c1)>32767)|
+                        ((C6ACCEL_TI_DSP_mat_mul_paramPtr->c2)>32767)|((C6ACCEL_TI_DSP_mat_mul_paramPtr->r1)>32767)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                        /* Call underlying kernel */
+                        DSP_mat_mul((short *)inBufs->descs[C6ACCEL_TI_DSP_mat_mul_paramPtr->x_InArrID1].buf,
+                                      C6ACCEL_TI_DSP_mat_mul_paramPtr->r1,
+                                      C6ACCEL_TI_DSP_mat_mul_paramPtr->c1,
+                                      (short *)inBufs->descs[C6ACCEL_TI_DSP_mat_mul_paramPtr->y_InArrID2].buf,
+                                      C6ACCEL_TI_DSP_mat_mul_paramPtr->c2,
+                                      (short *)outBufs->descs[C6ACCEL_TI_DSP_mat_mul_paramPtr->r_OutArrID1].buf,
+                                      C6ACCEL_TI_DSP_mat_mul_paramPtr->qs);
+                    }
+                 break;
+                 case (FIR_GEN_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSP_fir_gen_Params  *C6ACCEL_TI_DSP_fir_gen_paramPtr;
+                    C6ACCEL_TI_DSP_fir_gen_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSP_fir_gen_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSP_fir_gen_paramPtr->h_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSP_fir_gen_paramPtr->r_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_DSP_fir_gen_paramPtr->nr)%4 != 0)| ((C6ACCEL_TI_DSP_fir_gen_paramPtr->nr)<4)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                       /* Call underlying kernel */
+                        DSP_fir_gen((short *)inBufs->descs[C6ACCEL_TI_DSP_fir_gen_paramPtr->x_InArrID1].buf,
+                                    (short *)inBufs->descs[C6ACCEL_TI_DSP_fir_gen_paramPtr->h_InArrID2].buf,
+                                    (short *)outBufs->descs[C6ACCEL_TI_DSP_fir_gen_paramPtr->r_OutArrID1].buf,
+                                    C6ACCEL_TI_DSP_fir_gen_paramPtr->nh,
+                                    C6ACCEL_TI_DSP_fir_gen_paramPtr->nr);
+                   }
+                 break;
+                 case (AUTOCOR_FXN_ID):{
+                   /* Unmarshal Parameters */
+                   DSP_autocor_Params *C6ACCEL_TI_DSP_autocor_paramPtr;
+                   C6ACCEL_TI_DSP_autocor_paramPtr = pFnArray;
+                   /* Parameter check */
+                   if (((C6ACCEL_TI_DSP_autocor_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_autocor_paramPtr->r_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSP_autocor_paramPtr->nx)%8 != 0)|
+                       ((C6ACCEL_TI_DSP_autocor_paramPtr->nr)%4 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                    }
+                    else
+                     /* Call underlying kernel */
+                        DSP_autocor((short *)outBufs->descs[C6ACCEL_TI_DSP_autocor_paramPtr->r_OutArrID1].buf,
+                                    (short *)inBufs->descs[C6ACCEL_TI_DSP_autocor_paramPtr->x_InArrID1].buf,
+                                     C6ACCEL_TI_DSP_autocor_paramPtr->nx,
+                                     C6ACCEL_TI_DSP_autocor_paramPtr->nr);
+                  }
+                 break;
+                 case (FFT32x32_FXN_ID ):{
+                    /* Unmarshal Parameters */
+                    DSP_fft32x32_Params  *C6ACCEL_TI_DSP_fft32x32_paramPtr;
+                    C6ACCEL_TI_DSP_fft32x32_paramPtr= pFnArray;
+                    /* Parameter check*/
+                    if (((C6ACCEL_TI_DSP_fft32x32_paramPtr->w_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_fft32x32_paramPtr->x_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_fft32x32_paramPtr->y_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSP_fft32x32_paramPtr->nx)<16)|
+                       ((C6ACCEL_TI_DSP_fft32x32_paramPtr->nx)>65536)|
+                       (IsPowOfTwo(C6ACCEL_TI_DSP_fft32x32_paramPtr->nx) != TRUE)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                    }
+                    else
+                     /* Call underlying kernel */
+                       DSP_fft32x32((int *)inBufs->descs[C6ACCEL_TI_DSP_fft32x32_paramPtr->w_InArrID1].buf,
+                                     C6ACCEL_TI_DSP_fft32x32_paramPtr->nx,
+                                     (int *)inBufs->descs[C6ACCEL_TI_DSP_fft32x32_paramPtr->x_InArrID2].buf,
+                                     (int *)outBufs->descs[C6ACCEL_TI_DSP_fft32x32_paramPtr->y_OutArrID1].buf);
+                  } 
+                 break;
+                 case (IFFT32x32_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSP_ifft32x32_Params *C6ACCEL_TI_DSP_ifft32x32_paramPtr;
+                    C6ACCEL_TI_DSP_ifft32x32_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSP_ifft32x32_paramPtr->w_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSP_ifft32x32_paramPtr->x_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSP_ifft32x32_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_DSP_ifft32x32_paramPtr->nx)<16)|
+                        ((C6ACCEL_TI_DSP_ifft32x32_paramPtr->nx)>65536)|
+                        (IsPowOfTwo(C6ACCEL_TI_DSP_ifft32x32_paramPtr->nx) != TRUE)){
+                            return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       DSP_ifft32x32((int *)inBufs->descs[C6ACCEL_TI_DSP_ifft32x32_paramPtr->w_InArrID1].buf,
+                                      C6ACCEL_TI_DSP_ifft32x32_paramPtr->nx,
+                                     (int *)inBufs->descs[C6ACCEL_TI_DSP_ifft32x32_paramPtr->x_InArrID2].buf,
+                                     (int *)outBufs->descs[C6ACCEL_TI_DSP_ifft32x32_paramPtr->y_OutArrID1].buf);
+                   }
+                 break;
+                 case (FIR_R4_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSP_fir_r4_Params *C6ACCEL_TI_DSP_fir_r4_paramPtr;
+                    C6ACCEL_TI_DSP_fir_r4_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSP_fir_r4_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_fir_r4_paramPtr->h_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_fir_r4_paramPtr->r_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSP_fir_r4_paramPtr->nh)%4 != 0)|
+                       ((C6ACCEL_TI_DSP_fir_r4_paramPtr->nh) < 8)|
+                       ((C6ACCEL_TI_DSP_fir_r4_paramPtr->nr)%4 != 0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                    }
+                    else
+                    /* Call underlying kernel */
+                      DSP_fir_r4((short *) inBufs->descs[C6ACCEL_TI_DSP_fir_r4_paramPtr->x_InArrID1].buf,
+                                 (short *) inBufs->descs[C6ACCEL_TI_DSP_fir_r4_paramPtr->h_InArrID2].buf,
+                                 (short *) outBufs->descs[C6ACCEL_TI_DSP_fir_r4_paramPtr->r_OutArrID1].buf,
+                                 C6ACCEL_TI_DSP_fir_r4_paramPtr->nh,
+                                 C6ACCEL_TI_DSP_fir_r4_paramPtr->nr);
+                   }
+                 break;
+                 case (FIR_R8_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSP_fir_r8_Params *C6ACCEL_TI_DSP_fir_r8_paramPtr;
+                    C6ACCEL_TI_DSP_fir_r8_paramPtr = pFnArray;
+                    /* Parameter check*/
+                    if (((C6ACCEL_TI_DSP_fir_r8_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_fir_r8_paramPtr->h_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_fir_r8_paramPtr->r_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSP_fir_r8_paramPtr->nh)%8 != 0)|
+                       ((C6ACCEL_TI_DSP_fir_r8_paramPtr->nh) < 8)|
+                       ((C6ACCEL_TI_DSP_fir_r8_paramPtr->nr)%4 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                    }
+                    else
+                    /* Call underlying kernel */
+                      DSP_fir_r8((short *) inBufs->descs[C6ACCEL_TI_DSP_fir_r8_paramPtr->x_InArrID1].buf,
+                                 (short *) inBufs->descs[C6ACCEL_TI_DSP_fir_r8_paramPtr->h_InArrID2].buf,
+                                 (short *) outBufs->descs[C6ACCEL_TI_DSP_fir_r8_paramPtr->r_OutArrID1].buf,
+                                  C6ACCEL_TI_DSP_fir_r8_paramPtr->nh,
+                                  C6ACCEL_TI_DSP_fir_r8_paramPtr->nr);
+                  } 
+                 break;
+                 case (IIR_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSP_iir_Params *C6ACCEL_TI_DSP_iir_paramPtr;
+                    C6ACCEL_TI_DSP_iir_paramPtr = pFnArray;
+                    /* Parameter check*/
+                    if(((C6ACCEL_TI_DSP_iir_paramPtr->h_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_iir_paramPtr->b_InArrID3)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_iir_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_iir_paramPtr->Ret_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSP_iir_paramPtr->nh)%8 != 0)|
+                       ((C6ACCEL_TI_DSP_iir_paramPtr->nh) < 8)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       for (j = 0; j< C6ACCEL_TI_DSP_iir_paramPtr->n ; j++){
+                         ((short *)outBufs->descs[C6ACCEL_TI_DSP_iir_paramPtr->Ret_OutArrID1].buf)[j] = DSP_iir(((short *)inBufs->descs[C6ACCEL_TI_DSP_iir_paramPtr->x_InArrID1].buf)[j],
+                                                                                         (short *)inBufs->descs[C6ACCEL_TI_DSP_iir_paramPtr->h_InArrID2].buf,
+                                                                                          C6ACCEL_TI_DSP_iir_paramPtr->nh,
+                                                                                         (short *)inBufs->descs[C6ACCEL_TI_DSP_iir_paramPtr->b_InArrID3].buf);
+                     }
+                  }
+                 break;
+                 case (DOTP_SQR_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSP_dotp_sqr_Params *C6ACCEL_TI_DSP_dotp_sqr_paramPtr;
+                    C6ACCEL_TI_DSP_dotp_sqr_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_DSP_dotp_sqr_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_dotp_sqr_paramPtr->y_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_dotp_sqr_paramPtr->r_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSP_dotp_sqr_paramPtr->Ret_outArrID2)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSP_dotp_sqr_paramPtr->nx)%4 != 0)|
+                       ((C6ACCEL_TI_DSP_dotp_sqr_paramPtr->nx) < 12)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                        /* Call underlying kernel */
+                        ((int *)outBufs->descs[C6ACCEL_TI_DSP_dotp_sqr_paramPtr->Ret_outArrID2].buf)[0] =
+                        DSP_dotp_sqr(C6ACCEL_TI_DSP_dotp_sqr_paramPtr->G,
+                                     (short *)inBufs->descs[C6ACCEL_TI_DSP_dotp_sqr_paramPtr->x_InArrID1].buf,
+                                     (short *)inBufs->descs[C6ACCEL_TI_DSP_dotp_sqr_paramPtr->y_InArrID2].buf,
+                                     (int *)outBufs->descs[C6ACCEL_TI_DSP_dotp_sqr_paramPtr->r_OutArrID1].buf,
+                                     C6ACCEL_TI_DSP_dotp_sqr_paramPtr->nx);
+                  }
+                 break;
+                 case (DOTPROD_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSP_dotprod_Params *C6ACCEL_TI_DSP_dotprod_paramPtr;
+                    C6ACCEL_TI_DSP_dotprod_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_DSP_dotprod_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_dotprod_paramPtr->y_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSP_dotprod_paramPtr->nx)%4 != 0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                       /* Call underlying kernel */
+                       ((int *)outBufs->descs[C6ACCEL_TI_DSP_dotprod_paramPtr->Ret_outArrID1].buf)[0] =
+                       DSP_dotprod((short *)inBufs->descs[C6ACCEL_TI_DSP_dotprod_paramPtr->x_InArrID1].buf,
+                                   (short *)inBufs->descs[C6ACCEL_TI_DSP_dotprod_paramPtr->y_InArrID2].buf,
+                                    C6ACCEL_TI_DSP_dotprod_paramPtr->nx);
+                  } 
+                 break;
+               #ifdef DEVICE_FLOAT
+                 case (F_SP_FFTSPXSP_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_fftSPxSP_Params  *C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->w_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->brev_InArrID3)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->N)<8)|
+                        ((C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->N)>65536)|
+                        (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->N) != TRUE)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                    /* Call underlying kernel */
+                       DSPF_sp_fftSPxSP(C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->N,(float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->x_InArrID1].buf,
+                                     (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->w_InArrID2].buf,
+                                     (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->y_OutArrID1].buf,
+                                     (unsigned char *)outBufs->descs[C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->brev_InArrID3].buf,
+                                     C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->n_min,
+                                     C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->offset,
+                                     C6ACCEL_TI_DSPF_sp_fftSPxSP_paramPtr->n_max);
+                  }
+                 break;
+                 case (F_SP_IFFTSPXSP_FXN_ID ):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_ifftSPxSP_Params *C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->w_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->brev_InArrID3)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->N)<8)|
+                        ((C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->N)>65536)|
+                        (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->N) != TRUE)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                     /* Call underlying kernel */
+                       DSPF_sp_ifftSPxSP(C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->N,(float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->x_InArrID1].buf,
+                                     (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->w_InArrID2].buf,
+                                     (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->y_OutArrID1].buf,
+                                     (unsigned char *)outBufs->descs[C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->brev_InArrID3].buf,
+                                     C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->n_min,
+                                     C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->offset,
+                                     C6ACCEL_TI_DSPF_sp_ifftSPxSP_paramPtr->n_max);
+                  }
+                 break;
+                 case (F_SP_AUTOCOR_FXN_ID ):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_autocor_Params *C6ACCEL_TI_DSPF_sp_autocor_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_autocor_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSPF_sp_autocor_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_autocor_paramPtr->r_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_autocor_paramPtr->nr)%4 != 0)|((C6ACCEL_TI_DSPF_sp_autocor_paramPtr->nr)<0)|
+                        (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_autocor_paramPtr->nx) != TRUE)|
+                        ((C6ACCEL_TI_DSPF_sp_autocor_paramPtr->nx)<(C6ACCEL_TI_DSPF_sp_autocor_paramPtr->nr))){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                     /* Call underlying kernel */
+                       DSPF_sp_autocor((float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_autocor_paramPtr->r_OutArrID1].buf,
+                                       (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_autocor_paramPtr->x_InArrID1].buf,
+                                       C6ACCEL_TI_DSPF_sp_autocor_paramPtr->nx,
+                                       C6ACCEL_TI_DSPF_sp_autocor_paramPtr->nr);
+                  }
+                 break;
+                 case (F_SP_CONV_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_convol_Params *C6ACCEL_TI_DSPF_sp_convol_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_convol_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSPF_sp_convol_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_convol_paramPtr->h_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_convol_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_convol_paramPtr->ny) != TRUE)|
+                        ((C6ACCEL_TI_DSPF_sp_convol_paramPtr->ny)<0)|
+                        (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_convol_paramPtr->nh) != TRUE)|
+                        ((C6ACCEL_TI_DSPF_sp_convol_paramPtr->nh)<0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                     /* Call underlying kernel */
+                       DSPF_sp_convol((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_convol_paramPtr->x_InArrID1].buf,
+                                      (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_convol_paramPtr->h_InArrID2].buf,
+                                      (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_convol_paramPtr->y_OutArrID1].buf,
+                                       C6ACCEL_TI_DSPF_sp_convol_paramPtr->nh,
+                                       C6ACCEL_TI_DSPF_sp_convol_paramPtr->ny);
+                  }
+                 break;
+                 case (F_SP_BIQUAD_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_biquad_Params *C6ACCEL_TI_DSPF_sp_biquad_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_biquad_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSPF_sp_biquad_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_biquad_paramPtr->a_InArrID3)>INBUF15)|
+
+                        ((C6ACCEL_TI_DSPF_sp_biquad_paramPtr->b_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_biquad_paramPtr->delay_InArrID4)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_biquad_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((inBufs->descs[C6ACCEL_TI_DSPF_sp_biquad_paramPtr->a_InArrID3].bufSize)!=3*sizeof(float))|
+                        ((inBufs->descs[C6ACCEL_TI_DSPF_sp_biquad_paramPtr->b_InArrID2].bufSize)!=3*sizeof(float))|
+                        (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_biquad_paramPtr->n) != TRUE)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                     /* Call underlying kernel */
+                       DSPF_sp_biquad((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_biquad_paramPtr->x_InArrID1].buf,
+                                      (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_biquad_paramPtr->b_InArrID2].buf,
+                                      (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_biquad_paramPtr->a_InArrID3].buf,
+                                      (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_biquad_paramPtr->delay_InArrID4].buf,
+                                      (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_biquad_paramPtr->y_OutArrID1].buf,
+                                       C6ACCEL_TI_DSPF_sp_biquad_paramPtr->n);
+                  }
+                 break;
+                 case (F_SP_DOTPROD_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_dotprod_Params *C6ACCEL_TI_DSPF_sp_dotprod_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_dotprod_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->y_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->RetOut_OutArrID1)>OUTBUF15)|
+                        (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->n) != TRUE)|
+                        ((C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->n)<0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                     /* Call underlying kernel */
+                       ((float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->RetOut_OutArrID1].buf)[0]=
+                       DSPF_sp_dotprod((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->x_InArrID1].buf,
+                                       (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->y_InArrID2].buf,
+                                        C6ACCEL_TI_DSPF_sp_dotprod_paramPtr->n);
+                  }
+                 break;
+                 case (F_SP_FIR_GEN_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_fir_gen_Params  *C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->h_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->nh)%4 != 0)| ((C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->nh)<=0)|
+                        ((C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->ny)%4 != 0)| ((C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->ny)<=0)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                       /* Call underlying kernel */
+                        DSPF_sp_fir_gen((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->x_InArrID1].buf,
+                                        (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->h_InArrID2].buf,
+                                        (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->y_OutArrID1].buf,
+                                        C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->nh,
+                                        C6ACCEL_TI_DSPF_sp_fir_gen_paramPtr->ny);
+                  }
+                 break;
+                 case (F_SP_FIR_CPLX_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_fir_cplx_Params  *C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->h_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((inBufs->descs[C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->h_InArrID2].bufSize)!=(2*(C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->nh)*sizeof(float)))|
+                        ((outBufs->descs[C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->y_OutArrID1].bufSize)!=(2*(C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->ny)*sizeof(float)))|
+                        ((C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->nh)<=0)|
+                        ((C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->ny)%2 != 0)| ((C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->ny)<=0)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                       /* Call underlying kernel */
+                        DSPF_sp_fir_cplx((float *)(inBufs->descs[C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->x_InArrID1].buf+ 2*sizeof(float)*((C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->nh)-1)),
+                                        (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->h_InArrID2].buf,
+                                        (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->y_OutArrID1].buf,
+                                        C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->nh,
+                                        C6ACCEL_TI_DSPF_sp_fir_cplx_paramPtr->ny);
+                  }
+                 break;
+                 case (F_SP_IIR_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_iir_Params *C6ACCEL_TI_DSPF_sp_iir_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_iir_paramPtr = pFnArray;
+                    /* Parameter check*/
+                    if(((C6ACCEL_TI_DSPF_sp_iir_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_iir_paramPtr->hb_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_iir_paramPtr->ha_InArrID3)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_iir_paramPtr->y1_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_iir_paramPtr->y2_OutArrID2)>OUTBUF15)|
+                       (outBufs->descs[C6ACCEL_TI_DSPF_sp_iir_paramPtr->y1_OutArrID1].bufSize !=((C6ACCEL_TI_DSPF_sp_iir_paramPtr->n)+4)*sizeof(float))|
+                       (outBufs->descs[C6ACCEL_TI_DSPF_sp_iir_paramPtr->y2_OutArrID2].bufSize !=(C6ACCEL_TI_DSPF_sp_iir_paramPtr->n)*sizeof(float))|
+                       (inBufs->descs[C6ACCEL_TI_DSPF_sp_iir_paramPtr->x_InArrID1].bufSize !=((C6ACCEL_TI_DSPF_sp_iir_paramPtr->n)+4)*sizeof(float))|
+                       (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_iir_paramPtr->n) != TRUE)|
+                       ((C6ACCEL_TI_DSPF_sp_iir_paramPtr->n) < 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                        DSPF_sp_iir((float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_iir_paramPtr->y1_OutArrID1].buf,
+                                    (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_iir_paramPtr->x_InArrID1].buf,
+                                    (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_iir_paramPtr->y2_OutArrID2].buf,
+                                    (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_iir_paramPtr->hb_InArrID2].buf,
+                                    (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_iir_paramPtr->ha_InArrID3].buf,
+                                    C6ACCEL_TI_DSPF_sp_iir_paramPtr->n);
+                     
+                  }
+                 break;
+                 case (F_SP_MAT_MUL_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_mat_mul_Params  *C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr= pFnArray;
+                    /*Parameter check
+                    * 1.InArr, OutArr ID checks
+                    * 2.Check for constraints on matrix dimensions
+                    * 3.Condition to check if col of Input 1 is equal to row of Input 2:
+                    * (buf_size Input1)/(buf_size Input2) = (rows of Input1)/(cols of Input 2)
+                    */
+                    if (((C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->x1_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->x2_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((float)((inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->x1_InArrID1].bufSize)/
+                        (inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->x2_InArrID2].bufSize))!=
+                        ((float)(C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->r1/C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->c2)))){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                        /* Call underlying kernel */
+                        DSPF_sp_mat_mul((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->x1_InArrID1].buf,
+                                        C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->r1,
+                                        C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->c1,
+                                        (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->x2_InArrID2].buf,
+                                        C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->c2,
+                                        (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_paramPtr->y_OutArrID1].buf);
+                    }
+                 break;
+                 case (F_SP_MAT_MUL_CPLX_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_mat_mul_cplx_Params  *C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr= pFnArray;
+                    /*Parameter check
+                    * 1.InArr, OutArr ID checks
+                    * 2.Check for constraints on matrix dimensions
+                    * 3.Condition to check if col of Input 1 is equal to row of Input 2:
+                    * (buf_size Input1)/(buf_size Input2) = (rows of Input1)/(cols of Input 2)
+                    */
+                    if (((C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->x1_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->x2_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((float)((inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->x1_InArrID1].bufSize)/
+                        (inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->x2_InArrID2].bufSize))!=
+                        ((float)(C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->r1/C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->c2)))){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                        /* Call underlying kernel */
+                        DSPF_sp_mat_mul_cplx((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->x1_InArrID1].buf,
+                                        C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->r1,
+                                        C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->c1,
+                                        (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->x2_InArrID2].buf,
+                                        C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->c2,
+                                        (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_mat_mul_cplx_paramPtr->y_OutArrID1].buf);
+                    }
+                 break;
+                 case (F_SP_MAT_TRANS_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_mat_trans_Params  *C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr= pFnArray;
+                    /*Parameter check
+                    * 1.InArr, OutArr ID checks
+                    * 2.Check for constraints on matrix dimensions
+                    */
+                    if (((C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr->y_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr->rows)<2)|
+                        ((C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr->cols)<2)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                        /* Call underlying kernel */
+                        DSPF_sp_mat_trans((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr->x_InArrID1].buf,
+                                          C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr->rows,
+                                          C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr->cols,
+                                          (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_mat_trans_paramPtr->y_OutArrID1].buf);
+                   }
+                 break;
+                 case (F_SP_VECMUL_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_vecmul_Params *C6ACCEL_TI_DSPF_sp_vecmul_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_vecmul_paramPtr = pFnArray;
+                    /* Parameter check*/
+                    if(((C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->x1_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->x2_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->y_OutArrID1)>OUTBUF15)|
+                       (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->n) != TRUE)|
+                       ((C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->n) < 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                        DSPF_sp_vecmul((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->x1_InArrID1].buf,
+                                       (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->x2_InArrID2].buf,
+                                       (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->y_OutArrID1].buf,
+                                       C6ACCEL_TI_DSPF_sp_vecmul_paramPtr->n);
+          
+                  }
+                 break;
+                 case (F_SP_VECRECIP_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_vecrecip_Params *C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr = pFnArray;
+                    /* Parameter check*/
+                    if(((C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr->y_OutArrID1)>OUTBUF15)|
+                       (IsPowOfTwo(C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr->n) != TRUE)|
+                       ((C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr->n) < 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                        DSPF_sp_vecrecip((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr->x_InArrID1].buf,
+                                         (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr->y_OutArrID1].buf,
+                                         C6ACCEL_TI_DSPF_sp_vecrecip_paramPtr->n);
+          
+                  }
+                 break;
+                 case (F_SP_VECSUM_SQ_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_vecsum_sq_Params *C6ACCEL_TI_DSPF_sp_vecsum_sq_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_vecsum_sq_paramPtr = pFnArray;
+                    /* Parameter check*/
+                    if(((C6ACCEL_TI_DSPF_sp_vecsum_sq_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_vecsum_sq_paramPtr->OutRet_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_vecsum_sq_paramPtr->n) < 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                         ((float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_vecsum_sq_paramPtr->OutRet_OutArrID1].buf)[0]=
+                         DSPF_sp_vecsum_sq((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_vecsum_sq_paramPtr->x_InArrID1].buf,
+                                            C6ACCEL_TI_DSPF_sp_vecsum_sq_paramPtr->n);
+          
+                  }
+                 break;
+                 case (F_SP_W_VEC_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    DSPF_sp_w_vec_Params *C6ACCEL_TI_DSPF_sp_w_vec_paramPtr;
+                    C6ACCEL_TI_DSPF_sp_w_vec_paramPtr = pFnArray;
+                    /* Parameter check*/
+                    if(((C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->x1_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->x2_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->y_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->n) < 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                         DSPF_sp_w_vec((float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->x1_InArrID1].buf,
+                                       (float *)inBufs->descs[C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->x2_InArrID2].buf,
+                                       C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->m,
+                                       (float *)outBufs->descs[C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->y_OutArrID1].buf,
+                                       C6ACCEL_TI_DSPF_sp_w_vec_paramPtr->n);
+          
+                  }
+                 break;
+               #endif
+                 default:
+                   /*Error caused due to passing of an invalid ID*/
+                      return(IUNIVERSAL_EFXNIDFAIL);
+               }
+             break;
+             case (IMGLIB_FXN_ID):
+                /* IMGLIB functions */
+               switch ( fxnID & fxnidMsk){
+                 case (SOBEL_3X3_8_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_sobel_3x3_8_Params *C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr;
+                    C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr= pFnArray;
+                    /*Parameter check*/
+                    if (((C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->indata_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->outdata_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->Col)%2 != 0)|
+                        (((C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->Col)*((C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->Row)-2))%8 !=0)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_sobel_3x3_8((const unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->indata_InArrID1].buf,
+                                       (unsigned char *)outBufs->descs[C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->outdata_OutArrID1].buf,
+                                        C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->Col,
+                                        C6ACCEL_TI_IMG_sobel_3x3_8_paramPtr->Row);
+                     }
+                 break;
+		 /* This case is added by Pramod */
+		 case (SOBEL_3X3_8_16_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_sobel_3x3_8_16_Params *C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr;
+                    C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr= pFnArray;
+                    /*Parameter check*/
+                    if (((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->indata_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->outdata_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Col)%2 != 0)|
+                        (((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Col)*((C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Row)-2))%8 !=0)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_sobel_3x3_8_16((const unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->indata_InArrID1].buf,
+                                       (unsigned short *)outBufs->descs[C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->outdata_OutArrID1].buf,
+                                        C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Col,
+                                        C6ACCEL_TI_IMG_sobel_3x3_8_16_paramPtr->Row);
+                     }
+                 break;
+                 case (SOBEL_3X3_16_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_sobel_3x3_16_Params *C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr;
+                    C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr = pFnArray;
+                    /*Parameter check*/
+                    if(((C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->indata_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->outdata_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->Col)%2 != 0)|
+                       ((C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->Row) < 3)|
+                       (((C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->Col)*((C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->Row)-2))%8 !=0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                        IMG_sobel_3x3_16((const unsigned short *)inBufs->descs[C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->indata_InArrID1].buf,
+                                         (unsigned short *)outBufs->descs[C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->outdata_OutArrID1].buf,
+                                          C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->Col,
+                                          C6ACCEL_TI_IMG_sobel_3x3_16_paramPtr->Row);
+                    }
+                 break;
+                 case (HISTOGRAM_8_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_histogram_8_Params *C6ACCEL_TI_IMG_histogram_8_paramPtr;
+                    C6ACCEL_TI_IMG_histogram_8_paramPtr = pFnArray;
+                    /*Parameter check*/
+                    if (((C6ACCEL_TI_IMG_histogram_8_paramPtr->indata_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_histogram_8_paramPtr->t_hist_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_histogram_8_paramPtr->hist_OutArrID2)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_histogram_8_paramPtr->n)%8 != 0)|
+                         (outBufs->descs[C6ACCEL_TI_IMG_histogram_8_paramPtr->hist_OutArrID2].bufSize<(256*sizeof(short)))|
+                         (outBufs->descs[C6ACCEL_TI_IMG_histogram_8_paramPtr->t_hist_OutArrID1].bufSize<(1024*sizeof(short)))){
+                             return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                        IMG_histogram_8((unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_histogram_8_paramPtr->indata_InArrID1].buf,
+                                         C6ACCEL_TI_IMG_histogram_8_paramPtr->n,
+                                         C6ACCEL_TI_IMG_histogram_8_paramPtr->accumulate,
+                                         (short *)outBufs->descs[C6ACCEL_TI_IMG_histogram_8_paramPtr->t_hist_OutArrID1].buf,
+                                         (short *)outBufs->descs[C6ACCEL_TI_IMG_histogram_8_paramPtr->hist_OutArrID2].buf);
+
+                    }
+                 break;
+                 case (HISTOGRAM_16_FXN_ID ):{
+                    /* Unmarshal Parameters */
+                    IMG_histogram_16_Params *C6ACCEL_TI_IMG_histogram_16_paramPtr;
+                    C6ACCEL_TI_IMG_histogram_16_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_IMG_histogram_16_paramPtr->in_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_histogram_16_paramPtr->t_hist_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_histogram_16_paramPtr->hist_OutArrID2)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_histogram_16_paramPtr->n)%8 != 0)|
+                        ((C6ACCEL_TI_IMG_histogram_16_paramPtr->img_bits) <1)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_histogram_16_c((unsigned short*)inBufs->descs[C6ACCEL_TI_IMG_histogram_16_paramPtr->in_InArrID1].buf,
+                                           C6ACCEL_TI_IMG_histogram_16_paramPtr->n,
+                                           C6ACCEL_TI_IMG_histogram_16_paramPtr->accumulate,
+                                          (short *)outBufs->descs[C6ACCEL_TI_IMG_histogram_16_paramPtr->t_hist_OutArrID1].buf,
+                                          (short *)outBufs->descs[C6ACCEL_TI_IMG_histogram_16_paramPtr->hist_OutArrID2].buf,
+                                           C6ACCEL_TI_IMG_histogram_16_paramPtr->img_bits);
+                    }
+                 break;
+                 case (MEDIAN_3X3_8_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_median_3x3_8_Params *C6ACCEL_TI_IMG_median_3x3_8_paramPtr;
+                    C6ACCEL_TI_IMG_median_3x3_8_paramPtr = pFnArray;
+                    /*Parameter check*/
+                    if(((C6ACCEL_TI_IMG_median_3x3_8_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_median_3x3_8_paramPtr->OutArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_median_3x3_8_paramPtr->Col)%4 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_median_3x3_8((unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_median_3x3_8_paramPtr->InArrID1].buf,
+                                        C6ACCEL_TI_IMG_median_3x3_8_paramPtr->Col,
+                                        (unsigned char *)outBufs->descs[C6ACCEL_TI_IMG_median_3x3_8_paramPtr->OutArrID1].buf);
+                    }
+                 break;
+                 case (MEDIAN_3X3_16_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_median_3x3_16_Params *C6ACCEL_TI_IMG_median_3x3_16_paramPtr;
+                    C6ACCEL_TI_IMG_median_3x3_16_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_median_3x3_16_paramPtr->idata_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_median_3x3_16_paramPtr->odata_OutArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_median_3x3_16_paramPtr->nwidth) < 4)|
+                       ((C6ACCEL_TI_IMG_median_3x3_16_paramPtr->nwidth)%4 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_median_3x3_16((const short *)inBufs->descs[C6ACCEL_TI_IMG_median_3x3_16_paramPtr->idata_InArrID1].buf,
+                                          C6ACCEL_TI_IMG_median_3x3_16_paramPtr->nwidth,
+                                         (short *)outBufs->descs[C6ACCEL_TI_IMG_median_3x3_16_paramPtr->odata_OutArrID1].buf);
+                    }
+                  break;
+                  case (MEDIAN_3X3_16S_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     IMG_median_3x3_16s_Params *C6ACCEL_TI_IMG_median_3x3_16s_paramPtr;
+                     C6ACCEL_TI_IMG_median_3x3_16s_paramPtr  = pFnArray;
+                     /* Parameter check */
+                     if (((C6ACCEL_TI_IMG_median_3x3_16s_paramPtr->idata_InArrID1)>INBUF15)|
+                         ((C6ACCEL_TI_IMG_median_3x3_16s_paramPtr->odata_OutArrID1)>INBUF15)|
+                         ((C6ACCEL_TI_IMG_median_3x3_16s_paramPtr->nwidth) < 4)|
+                         ((C6ACCEL_TI_IMG_median_3x3_16s_paramPtr->nwidth) % 4 != 0)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                     /* Call underlying kernel */
+                        IMG_median_3x3_16s((const short *)inBufs->descs[C6ACCEL_TI_IMG_median_3x3_16s_paramPtr->idata_InArrID1].buf,
+                                           C6ACCEL_TI_IMG_median_3x3_16s_paramPtr->nwidth,
+                                           (short *)outBufs->descs[C6ACCEL_TI_IMG_median_3x3_16s_paramPtr->odata_OutArrID1].buf);
+                    }
+                  break;
+                  case (MEDIAN_3X3_8_FRAME_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     IMG_median_3x3_8_Frame_Params *C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr;
+                     C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr = pFnArray;
+                     /*Parameter check*/
+                     if(((C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->OutArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->Row) <= 0)|
+                        ((C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->Col)%4 != 0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{ // Use Row to loop through image line by line using existing DSP API
+                         int r;
+                         /* Call underlying kernel */
+                         unsigned char *pInChar=(unsigned char*)(inBufs->descs[C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->InArrID1].buf);
+                         unsigned char *pOutChar=(unsigned char*)(outBufs->descs[C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->OutArrID1].buf);
+                         for(r=0;r<C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->Row;r++){
+                             IMG_median_3x3_8(pInChar+r*C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->Col,
+                                          C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->Col,
+                                          pOutChar+r*C6ACCEL_TI_IMG_median_3x3_8_Frame_paramPtr->Col);
+                          }
+                      }
+                   }
+                  break;
+                  case (MEDIAN_3X3_16_FRAME_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_median_3x3_16_Frame_Params *C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr;
+                    C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->idata_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->odata_OutArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->Row) <= 0)|
+                       ((C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->nwidth) < 4)|
+                       ((C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->nwidth)%4 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                      { // Use Row to loop through image line by line using existing DSP API
+                        int r;
+                        short *pInShort=(short*)(inBufs->descs[C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->idata_InArrID1].buf);
+                        short *pOutShort=(short*)(outBufs->descs[C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->odata_OutArrID1].buf);
+                        /* Call underlying kernel */
+                        for(r=0;r<C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->Row;r++){
+                            IMG_median_3x3_16(pInShort+r*C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->nwidth,
+                                              C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->nwidth,
+                                              pOutShort+r*C6ACCEL_TI_IMG_median_3x3_16_Frame_paramPtr->nwidth);
+                          }
+                       }
+                    }
+                  break;
+                  case (MEDIAN_3X3_16S_FRAME_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     IMG_median_3x3_16s_Frame_Params *C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr;
+                     C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr  = pFnArray;
+                     /* Parameter check */
+                     if (((C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->idata_InArrID1)>INBUF15)|
+                         ((C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->odata_OutArrID1)>INBUF15)|
+                         ((C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->Row) <= 0)|
+                         ((C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->nwidth) < 4)|
+                         ((C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->nwidth) % 4 != 0)){
+                           return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                       { // Use Row to loop through image line by line using existing DSP API
+                        int r;
+                        short *pInShort=(short*)(inBufs->descs[C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->idata_InArrID1].buf);
+                        short *pOutShort=(short*)(outBufs->descs[C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->odata_OutArrID1].buf);
+                        /* Call underlying kernel */
+                        for(r=0;r<C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->Row;r++){
+                           IMG_median_3x3_16s( pInShort+r*C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->nwidth,
+                                               C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->nwidth,
+                                               pOutShort+r*C6ACCEL_TI_IMG_median_3x3_16s_Frame_paramPtr->nwidth);
+                        }
+                     }
+                   }
+                 break;
+                 case (CONV_3X3_I8_C8S_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_conv_3x3_i8_c8s_Params *C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr;
+                    C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr = pFnArray;
+                    /*Parameter check*/
+                    if(((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->in_data_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->out_data_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->mask_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->cols)%8 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_conv_3x3_i8_c8s((unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->in_data_InArrID1].buf,
+                                           (unsigned char *)outBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->out_data_OutArrID1].buf,
+                                           C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->cols,
+                                           (const char *)inBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->mask_InArrID2].buf,
+                                           C6ACCEL_TI_IMG_conv_3x3_i8_c8s_paramPtr->shift);
+                     }
+                  break;
+                  case (CONV_3X3_I16S_C16S_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     IMG_conv_3x3_i16s_c16s_Params *C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr;
+                     C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->in_data_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->out_data_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->mask_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->pitch)<(C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->width))|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->width)< 2)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->width)%2 != 0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                      else
+                      /* Call underlying kernel */
+                         IMG_conv_3x3_i16s_c16s((short *)inBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->in_data_InArrID1].buf,
+                                                (short *)outBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->out_data_OutArrID1].buf,
+                                                C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->width,
+                                                C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->pitch,
+                                                (const short *)inBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->mask_InArrID2].buf,
+                                                C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_paramPtr->shift);
+                  }
+                  break;
+                  case (CONV_3X3_I8_C8S_FRAME_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     IMG_conv_3x3_i8_c8s_Frame_Params *C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr;
+                     C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr = pFnArray;
+                     /*Parameter check*/
+                     if(((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->in_data_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->out_data_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->mask_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->rows)<= 0)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->cols)%8 != 0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                       { // Use Row to loop through image line by line using existing DSP API
+                        int r;
+                        unsigned char *pInChar=(unsigned char*)inBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->in_data_InArrID1].buf;
+                        unsigned char *pOutChar=(unsigned char*)outBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->out_data_OutArrID1].buf;
+                        /* Call underlying kernel */
+                        for(r=0;r<C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->rows;r++){
+                            IMG_conv_3x3_i8_c8s(pInChar + r*C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->cols,
+                                                pOutChar + r*C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->cols,
+                                                C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->cols,
+                                               (const char *)inBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->mask_InArrID2].buf,
+                                               C6ACCEL_TI_IMG_conv_3x3_i8_c8s_Frame_paramPtr->shift);
+                         }
+                      }
+                   }
+                  break;
+                  case (CONV_3X3_I16S_C16S_FRAME_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     IMG_conv_3x3_i16s_c16s_Frame_Params *C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr;
+                     C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->in_data_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->out_data_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->mask_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->pitch)<(C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->width))|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->rows)<= 0)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->width)< 2)|
+                        ((C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->width)%2 != 0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                       { // Use Row to loop through image line by line using existing DSP API
+                        int r;
+                        short *pInShort=(short*)inBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->in_data_InArrID1].buf;
+                        short *pOutShort=(short*)outBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->out_data_OutArrID1].buf;
+                        /* Call underlying kernel */
+                        for(r=0;r<C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->rows;r++){
+                            IMG_conv_3x3_i16s_c16s((short *)pInShort+r*C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->pitch,
+                                                  (short *)pOutShort+r*C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->pitch,
+                                                  C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->width,
+                                                  C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->pitch,
+                                                  (const short *)inBufs->descs[C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->mask_InArrID2].buf,
+                                                  C6ACCEL_TI_IMG_conv_3x3_i16s_c16s_Frame_paramPtr->shift);
+                          }
+                       }
+                    }
+                 break;
+                 case (CORR_3X3_I8_C8_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_corr_3x3_i8_c8_Params *C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr;
+                    C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr  = pFnArray;
+                    /*Parameter check*/
+                    if(((C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->in_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->mask_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->out_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->n_out)%4 != 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->x_dim)%2 != 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->x_dim)<4)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                      IMG_corr_3x3_i8_c8((const unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->in_InArrID1].buf,
+                                         (int *)outBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->out_OutArrID1].buf,
+                                         C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->n_out,
+                                         C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->x_dim,
+                                         (const unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->mask_InArrID2].buf,
+                                         C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->shift,
+                                         C6ACCEL_TI_IMG_corr_3x3_i8_c8_paramPtr->round);
+                  }
+                 break;
+                 case (CORR_3X3_I16S_C16S_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_corr_3x3_i16s_c16s_Params *C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr;
+                    C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr  = pFnArray;
+                    /*Parameter check*/
+                    if(((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->imgin_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->mask_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->imgout_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->pitch)<(C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->width))|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->width)%2 != 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->width)<2)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                        IMG_corr_3x3_i16s_c16s((const short *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->imgin_InArrID1].buf,
+                                               (int *)outBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->imgout_OutArrID1].buf,
+                                               C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->width,
+                                               C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->pitch,
+                                               (const short *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->mask_InArrID2].buf,
+                                               C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->shift,
+                                               C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_paramPtr->round);
+                  }
+                 break;
+                 case (CORR_3X3_I8_C16S_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_corr_3x3_i8_c16s_Params *C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr;
+                    C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr  = pFnArray;
+                    /*Parameter check*/
+                    if(((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->imgin_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->mask_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->imgout_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->pitch)<(C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->width))|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->width)%2 != 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->width)<2)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                       IMG_corr_3x3_i8_c16s((const unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->mask_InArrID2].buf,
+                                            (int *)outBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->imgout_OutArrID1].buf,
+                                            C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->width,
+                                            C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->pitch,
+                                            (const short *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c16s_paramPtr->mask_InArrID2].buf);
+                  }
+                 break;
+                 case (CORR_3X3_I8_C8_FRAME_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_corr_3x3_i8_c8_Frame_Params *C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr;
+                    C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr  = pFnArray;
+                    /*Parameter check*/
+                    if(((C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->in_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->mask_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->out_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->n_out)%4 != 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->rows) <= 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->x_dim)%2 != 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->x_dim)<4)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else{ // Use Row to loop through image line by line using existing DSP API
+                          int r;
+                          unsigned char *pInChar=(unsigned char*)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->in_InArrID1].buf;
+                          int *pOutInt          =(int*)outBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->out_OutArrID1].buf;
+                          /* Call underlying kernel */
+                          for(r=0;r<C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->rows;r++){
+                             IMG_corr_3x3_i8_c8(pInChar + r*C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->x_dim,
+                                                pOutInt + r*C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->x_dim,
+                                                C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->n_out,
+                                                C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->x_dim,
+                                                (const unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->mask_InArrID2].buf,
+                                                C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->shift,
+                                                C6ACCEL_TI_IMG_corr_3x3_i8_c8_Frame_paramPtr->round);
+                          }
+                      }
+                  }
+                 break;
+                 case (CORR_3X3_I16S_C16S_FRAME_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     IMG_corr_3x3_i16s_c16s_Frame_Params *C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr;
+                     C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr  = pFnArray;
+                     /*Parameter check*/
+                     if(((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->imgin_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->mask_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->imgout_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->pitch)<(C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->width))|
+                        ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->rows) <= 0)|
+                        ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->width)%2 != 0)|
+                        ((C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->width)<2)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                      else{ // Use Row to loop through image line by line using existing DSP API
+                           int r;
+                           short *pInShort=(short*)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->imgin_InArrID1].buf;
+                           int *pOutInt          =(int*)outBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->imgout_OutArrID1].buf;
+                           /* Call underlying kernel */
+                           for(r=0;r<C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->rows;r++){
+                               IMG_corr_3x3_i16s_c16s(pInShort + r * C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->pitch,
+                                                     (int *)pOutInt + r * C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->pitch,
+                                                     C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->width,
+                                                     C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->pitch,
+                                                     (const short *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->mask_InArrID2].buf,
+                                                     C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->shift,
+                                                     C6ACCEL_TI_IMG_corr_3x3_i16s_c16s_Frame_paramPtr->round);
+                            }
+                       }
+                   }
+                 break;
+                 case (CORR_3X3_I8_C16S_FRAME_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_corr_3x3_i8_c16s_Frame_Params *C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr;
+                    C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr  = pFnArray;
+                    /*Parameter check*/
+                    if(((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->imgin_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->mask_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->imgout_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->pitch)<(C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->width))|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->width)%2 != 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->rows) <= 0)|
+                       ((C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->width)<2)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else{ // Use Row to loop through image line by line using existing DSP API
+                          int r;
+                          unsigned char *pInChar=(unsigned char*)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->mask_InArrID2].buf;
+                          int *pOutInt          =(int*)outBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->imgout_OutArrID1].buf;
+                          /* Call underlying kernel */
+                          for(r=0;r<C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->rows;r++){
+                              IMG_corr_3x3_i8_c16s(pInChar + r*C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->pitch,
+                                                   pOutInt + r*C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->pitch,
+                                                   C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->width,
+                                                   C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->pitch,
+                                                   (const short *)inBufs->descs[C6ACCEL_TI_IMG_corr_3x3_i8_c16s_Frame_paramPtr->mask_InArrID2].buf);
+                            }
+                       }
+                   }
+                 break;
+                 case (MULS_8_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_mulS_8_Params *C6ACCEL_TI_IMG_mulS_8_paramPtr;
+                    C6ACCEL_TI_IMG_mulS_8_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_mulS_8_paramPtr->imgR_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_mulS_8_paramPtr->imgW_OutArrID1)>INBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_mulS_8((unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_mulS_8_paramPtr->imgR_InArrID1].buf,
+                                  (short *)outBufs->descs[C6ACCEL_TI_IMG_mulS_8_paramPtr->imgW_OutArrID1].buf,
+                                   C6ACCEL_TI_IMG_mulS_8_paramPtr->constData,
+                                   C6ACCEL_TI_IMG_mulS_8_paramPtr->count);
+                     }
+                 break;
+                 case (MULS_16S_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_mulS_16s_Params *C6ACCEL_TI_IMG_mulS_16s_paramPtr;
+                    C6ACCEL_TI_IMG_mulS_16s_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_mulS_16s_paramPtr->imgR_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_mulS_16s_paramPtr->imgW_OutArrID1)>INBUF15)){
+                       return(IUNIVERSAL_EPARAMFAIL);
+                    }
+                    else
+                    /* Call underlying kernel */
+                      IMG_mulS_16s((short *)inBufs->descs[C6ACCEL_TI_IMG_mulS_16s_paramPtr->imgR_InArrID1].buf,
+                                   (int *)outBufs->descs[C6ACCEL_TI_IMG_mulS_16s_paramPtr->imgW_OutArrID1].buf,
+                                   (short)C6ACCEL_TI_IMG_mulS_16s_paramPtr->constData,
+                                   C6ACCEL_TI_IMG_mulS_16s_paramPtr->count);
+                    }
+                 break;
+                 case (ADDS_8_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_addS_8_Params *C6ACCEL_TI_IMG_addS_8_paramPtr;
+                    C6ACCEL_TI_IMG_addS_8_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_addS_8_paramPtr->imgR_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_addS_8_paramPtr->imgW_OutArrID1)>INBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_addS_8((char *)inBufs->descs[C6ACCEL_TI_IMG_addS_8_paramPtr->imgR_InArrID1].buf,
+                                  (char *)outBufs->descs[C6ACCEL_TI_IMG_addS_8_paramPtr->imgW_OutArrID1].buf,
+                                  C6ACCEL_TI_IMG_addS_8_paramPtr->constData,
+                                  C6ACCEL_TI_IMG_addS_8_paramPtr->count);
+                    }
+                 break;
+                 case (ADDS_16S_FXN_ID):{ 
+                    /* Unmarshal Parameters */   
+                    IMG_addS_16s_Params *C6ACCEL_TI_IMG_addS_16s_paramPtr;
+                    C6ACCEL_TI_IMG_addS_16s_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_addS_16s_paramPtr->imgR_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_addS_16s_paramPtr->imgW_OutArrID1)>INBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_addS_16s((short *)inBufs->descs[C6ACCEL_TI_IMG_addS_16s_paramPtr->imgR_InArrID1].buf,
+                                    (short *)outBufs->descs[C6ACCEL_TI_IMG_addS_16s_paramPtr->imgW_OutArrID1].buf,
+                                    C6ACCEL_TI_IMG_addS_16s_paramPtr->constData,
+                                    C6ACCEL_TI_IMG_addS_16s_paramPtr->count);
+                    }
+                 break;
+                 case (SUBS_8_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_subS_8_Params *C6ACCEL_TI_IMG_subS_8_paramPtr;
+                    C6ACCEL_TI_IMG_subS_8_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_subS_8_paramPtr->imgR_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_subS_8_paramPtr->imgW_OutArrID1)>INBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                      IMG_subS_8((char *)inBufs->descs[C6ACCEL_TI_IMG_subS_8_paramPtr->imgR_InArrID1].buf,
+                                 (char *)outBufs->descs[C6ACCEL_TI_IMG_subS_8_paramPtr->imgW_OutArrID1].buf,
+                                  C6ACCEL_TI_IMG_subS_8_paramPtr->constData,
+                                  C6ACCEL_TI_IMG_subS_8_paramPtr->count);
+                    }
+                 break;
+                 case (SUBS_16S_FXN_ID):{ 
+                    /* Unmarshal Parameters */   
+                    IMG_subS_16s_Params *C6ACCEL_TI_IMG_subS_16s_paramPtr;
+                    C6ACCEL_TI_IMG_subS_16s_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_subS_16s_paramPtr->imgR_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_subS_16s_paramPtr->imgW_OutArrID1)>INBUF15)){
+                       return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_subS_16s((short *)inBufs->descs[C6ACCEL_TI_IMG_subS_16s_paramPtr->imgR_InArrID1].buf,
+                                    (short *)outBufs->descs[C6ACCEL_TI_IMG_subS_16s_paramPtr->imgW_OutArrID1].buf,
+                                    C6ACCEL_TI_IMG_subS_16s_paramPtr->constData,
+                                    C6ACCEL_TI_IMG_subS_16s_paramPtr->count);
+                     }
+                 break;
+                 case (YC_DEMUX_LE16_16_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_yc_demux_le16_16_Params *C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr;
+                    C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->yc_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->y_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->cr_OutArrID2)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->cb_OutArrID3)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->n)%16 !=0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                        IMG_yc_demux_le16_16(C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->n,
+                                            (const unsigned short *)inBufs->descs[C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->yc_InArrID1].buf,
+                                            (short *) outBufs->descs[C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->y_OutArrID1].buf,
+                                            (short *) outBufs->descs[C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->cr_OutArrID2].buf,
+                                            (short *) outBufs->descs[C6ACCEL_TI_IMG_yc_demux_le16_16_paramPtr->cb_OutArrID3].buf);
+                    }
+                 break;
+                 case (YC_DEMUX_LE8_C_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_yc_demux_le8_c_Params *C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr;
+                    C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->yc_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->y_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->cr_OutArrID2)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->cb_OutArrID3)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->n)%16 !=0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else
+                    /* Call underlying kernel */
+                       IMG_yc_demux_le8_c(C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->n,
+                                          (const unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->yc_InArrID1].buf,
+                                          (unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->y_OutArrID1].buf,
+                                          (unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->cr_OutArrID2].buf,
+                                          (unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_yc_demux_le8_c_paramPtr->cb_OutArrID3].buf);
+                    }
+                 break;
+                 case (YCBCR422PL_RGB565_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     IMG_ycbcr422pl_to_rgb565_Params   *C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr;
+                     C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->coeff_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->y_data_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->cb_data_InArrID3)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->cr_data_InArrID4)>INBUF15)|
+                        ((C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->rgb_data_OutArrID1)>OUTBUF15)|
+                        ((C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->num_pixels)%8 != 0)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                      else
+                      /* Call underlying kernel */
+                         IMG_ycbcr422pl_to_rgb565((const short *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->coeff_InArrID1].buf,
+                                                  (const unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->y_data_InArrID2].buf,
+                                                  (const unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->cb_data_InArrID3].buf,
+                                                  (const unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->cr_data_InArrID4].buf,
+                                                  (unsigned short *) outBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->rgb_data_OutArrID1].buf,
+                                                  C6ACCEL_TI_IMG_ycbcr422pl_to_rgb565_paramPtr->num_pixels);
+                    }
+                 break;
+                 case (YCBCR422PL16_RGB565_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_ycbcr422pl16_to_rgb565_Params *C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr;
+                    C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->coeff_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->y_data_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->cb_data_InArrID3)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->cr_data_InArrID4)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->rgb_data_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->num_pixels)%8 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else
+                     /* Call underlying kernel */
+                        IMG_ycbcr422pl16_to_rgb565_c((const short *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->coeff_InArrID1].buf,
+                                                     (short *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->y_data_InArrID2].buf,
+                                                     (short *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->cb_data_InArrID3].buf,
+                                                     (short *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->cr_data_InArrID4].buf,
+                                                     (unsigned short *) outBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->rgb_data_OutArrID1].buf,
+                                                     C6ACCEL_TI_IMG_ycbcr422pl16_to_rgb565_paramPtr->num_pixels);
+                    }
+                 break;
+                 case (YUV420PL_TO_RGB565_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_yuv420pl_to_rgb565_Params  *C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr;
+                    C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->coeff_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->y_data_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->cb_data_InArrID3)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->cr_data_InArrID4)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->rgb_data_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->Height)%2 != 0)|
+                       ((C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->Width)%8 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                        IMG_yuv420pl_to_rgb565((const short *) inBufs->descs[C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->coeff_InArrID1].buf,
+                                               C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->Height,
+                                               C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->Width,
+                                               (unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->y_data_InArrID2].buf,
+                                               (unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->cb_data_InArrID3].buf,
+                                               (unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->cr_data_InArrID4].buf,
+                                               (unsigned short *) outBufs->descs[C6ACCEL_TI_IMG_yuv420pl_to_rgb565_paramPtr->rgb_data_OutArrID1].buf);
+                   }
+                 break;
+                 case (YUV420PL16_TO_RGB565_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_yuv420pl16_to_rgb565_Params *C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr;
+                    C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->coeff_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->y_data_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->cb_data_InArrID3)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->cr_data_InArrID4)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->rgb_data_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->Height)%2 != 0)|
+                       ((C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->Width)%2 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                        IMG_yuv420pl16_to_rgb565((const short *) inBufs->descs[C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->coeff_InArrID1].buf,
+                                                  C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->Height,
+                                                  C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->Width,
+                                                  (short *) inBufs->descs[C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->y_data_InArrID2].buf,
+                                                  (short *) inBufs->descs[C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->cb_data_InArrID3].buf,
+                                                  (short *) inBufs->descs[C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->cr_data_InArrID4].buf,
+                                                  (unsigned short *) outBufs->descs[C6ACCEL_TI_IMG_yuv420pl16_to_rgb565_paramPtr->rgb_data_OutArrID1].buf);
+                  }
+                 break;
+                 case (YCBCR422SP_TO_YCBCR420PL_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_ycbcr422sp_to_ycbcr420pl_Params  *C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr;
+                    C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->y_src_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->cbcr_src_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->y_dst_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->cb_dst_OutArrID2)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->cr_dst_OutArrID3)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->width)%16 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                        ycbcr422sp_to_ycbcr420pl((const unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->y_src_InArrID1].buf,
+                                                 (const unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->cbcr_src_InArrID2].buf,
+                                                 (unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->y_dst_OutArrID1].buf,
+                                                 (unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->cb_dst_OutArrID2].buf,
+                                                 (unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->cr_dst_OutArrID3].buf,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->num_lines,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->width,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->src_pitch,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->dst_y_pitch,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr420pl_paramPtr->dst_cbcr_pitch);
+                                           
+                                               
+                  }
+                 break;
+                 case (YCBCR422PL_TO_YCBCR422SP_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_ycbcr422pl_to_ycbcr422sp_Params  *C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr;
+                    C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->y_src_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->cr_src_InArrID3)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->cb_src_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->y_dst_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->cbcr_dst_OutArrID2)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->width)%16 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                        ycbcr422pl_to_ycbcr422sp((unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->y_dst_OutArrID1].buf,
+                                                 (unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->cbcr_dst_OutArrID2].buf,
+                                                 (unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->y_src_InArrID1].buf,
+                                                 (unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->cb_src_InArrID2].buf,
+                                                 (unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->cr_src_InArrID3].buf,
+                                                 C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->num_lines,
+                                                 C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->width,
+                                                 C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->dst_pitch,
+                                                 C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->src_y_pitch,
+                                                 C6ACCEL_TI_IMG_ycbcr422pl_to_ycbcr422sp_paramPtr->src_cbcr_pitch);
+                                           
+                                               
+                  }
+                 break;
+                 case (YCBCR422SP_TO_YCBCR422ILE_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    IMG_ycbcr422sp_to_ycbcr422ile_Params  *C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr;
+                    C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->y_src_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->cbcr_src_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->ycbcr_dst_OutArrID1)>OUTBUF15)|
+                       ((C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->width)%16 != 0)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else
+                     /* Call underlying kernel */
+                        ycbcr422sp_to_ycbcr422ile((unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->y_src_InArrID1].buf,
+                                                 (unsigned char *) inBufs->descs[C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->cbcr_src_InArrID2].buf,
+                                                 (unsigned char *) outBufs->descs[C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->ycbcr_dst_OutArrID1].buf,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->num_lines,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->width,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->src_pitch,
+                                                 C6ACCEL_TI_IMG_ycbcr422sp_to_ycbcr422ile_paramPtr->dst_ycbcr_pitch);
+                                           
+                                               
+                  }
+                 break;
+                 default:
+                    /*Error caused due to passing of an invalid ID*/
+                         return(IUNIVERSAL_EFXNIDFAIL);
+                  }
+             break;
+             case(MATHLIB_FXN_ID):
+               /* IQMATHLIB functions */
+               switch ( fxnID & fxnidMsk){
+                 case(IQNMPY_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNmpy_Params  *C6ACCEL_TI_IQNmpy_paramPtr;
+                    C6ACCEL_TI_IQNmpy_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNmpy_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNmpy_paramPtr->InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNmpy_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNmpy_paramPtr->InArrID1].buf;
+                         inArrRdr2 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNmpy_paramPtr->InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNmpy_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNmpy_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNmpy(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNmpy_paramPtr->qfmt);
+                          }
+                       }
+                    }
+                 break;
+                 case(IQNSQRT_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNsqrt_Params  *C6ACCEL_TI_IQNsqrt_paramPtr;
+                    C6ACCEL_TI_IQNsqrt_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNsqrt_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNsqrt_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                        inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNsqrt_paramPtr->InArrID1].buf;
+                        outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNsqrt_paramPtr->OutArrID1].buf;
+                        for(j=0 ; j < (C6ACCEL_TI_IQNsqrt_paramPtr-> n); j++){
+                            outArrRdr[j] = _IQNsqrt(inArrRdr1[j], C6ACCEL_TI_IQNsqrt_paramPtr->qfmt);
+                         }
+                     }
+                  }
+                 break;
+                 case(IQNSIN_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNsin_Params  *C6ACCEL_TI_IQNsin_paramPtr;
+                    C6ACCEL_TI_IQNsin_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNsin_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNsin_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNsin_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNsin_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNsin_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNsin(inArrRdr1[j], C6ACCEL_TI_IQNsin_paramPtr->qfmt);
+                           }
+                       }
+                   }
+                 break;
+                 case(IQNCOS_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNcos_Params   *C6ACCEL_TI_IQNcos_paramPtr;
+                    C6ACCEL_TI_IQNcos_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNcos_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNcos_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNcos_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNcos_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNcos_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNcos(inArrRdr1[j], C6ACCEL_TI_IQNcos_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNDIV_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNdiv_Params  *C6ACCEL_TI_IQNdiv_paramPtr;
+                    C6ACCEL_TI_IQNdiv_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNdiv_paramPtr->num_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNdiv_paramPtr->den_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNdiv_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNdiv_paramPtr->num_InArrID1].buf;
+                         inArrRdr2 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNdiv_paramPtr->den_InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNdiv_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNdiv_paramPtr->n); j++){
+                             outArrRdr[j] = _IQNdiv(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNdiv_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNATAN2_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNatan2_Params *C6ACCEL_TI_IQNatan2_paramPtr;
+                    C6ACCEL_TI_IQNatan2_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNatan2_paramPtr->y_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNatan2_paramPtr->x_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNatan2_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNatan2_paramPtr->y_InArrID1].buf;
+                         inArrRdr2 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNatan2_paramPtr->x_InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNatan2_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNatan2_paramPtr->n); j++){
+                             outArrRdr[j] = _IQNatan2(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNatan2_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNEXP_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNexp_Params  *C6ACCEL_TI_IQNexp_paramPtr;
+                    C6ACCEL_TI_IQNexp_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNexp_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNexp_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNexp_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNexp_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNexp_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNexp(inArrRdr1[j], C6ACCEL_TI_IQNexp_paramPtr->qfmt);
+                           }
+                       }
+                   }
+                 break;
+                 case(IQNLOG_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNlog_Params *C6ACCEL_TI_IQNlog_paramPtr;
+                    C6ACCEL_TI_IQNlog_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNlog_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNlog_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNlog_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNlog_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNlog_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNlog(inArrRdr1[j], C6ACCEL_TI_IQNlog_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNABS_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNabs_Params *C6ACCEL_TI_IQNabs_paramPtr;
+                    C6ACCEL_TI_IQNabs_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNabs_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNabs_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNabs_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNabs_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNabs_paramPtr-> n); j++){
+                              outArrRdr[j] = _IQNabs(inArrRdr1[j]);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNRMPY_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNrmpy_Params *C6ACCEL_TI_IQNrmpy_paramPtr;
+                    C6ACCEL_TI_IQNrmpy_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNrmpy_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNrmpy_paramPtr->InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNrmpy_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNrmpy_paramPtr->InArrID1].buf;
+                         inArrRdr2 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNrmpy_paramPtr->InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNrmpy_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNrmpy_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNrmpy(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNrmpy_paramPtr->qfmt);
+                           }
+                       }
+                  }
+                 break;
+                 case(IQNRSMPY_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNrsmpy_Params *C6ACCEL_TI_IQNrsmpy_paramPtr;
+                    C6ACCEL_TI_IQNrsmpy_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNrsmpy_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNrsmpy_paramPtr->InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNrsmpy_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNrsmpy_paramPtr->InArrID1].buf;
+                         inArrRdr2 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNrsmpy_paramPtr->InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNrsmpy_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNrsmpy_paramPtr-> n); j++){
+                              outArrRdr[j] = _IQNrsmpy(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNrsmpy_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNASIN_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNasin_Params *C6ACCEL_TI_IQNasin_paramPtr;
+                    C6ACCEL_TI_IQNasin_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNasin_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNasin_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNasin_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNasin_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNasin_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNasin(inArrRdr1[j], C6ACCEL_TI_IQNasin_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNACOS_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNacos_Params  *C6ACCEL_TI_IQNacos_paramPtr;
+                    C6ACCEL_TI_IQNacos_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNacos_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNacos_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNacos_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNacos_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNacos_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNacos(inArrRdr1[j], C6ACCEL_TI_IQNacos_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNSINPU_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNsinPU_Params *C6ACCEL_TI_IQNsinPU_paramPtr;
+                    C6ACCEL_TI_IQNsinPU_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNsinPU_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNsinPU_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                        /* Call underlying kernel */
+                        inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNsinPU_paramPtr->InArrID1].buf;
+                        outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNsinPU_paramPtr->OutArrID1].buf;
+                        for(j=0 ; j < (C6ACCEL_TI_IQNsinPU_paramPtr-> n); j++){
+                            outArrRdr[j] = _IQNsinPU(inArrRdr1[j], C6ACCEL_TI_IQNsinPU_paramPtr->qfmt);
+                         }
+                      }
+                   }
+                 break;
+                 case(IQNCOSPU_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNcosPU_Params *C6ACCEL_TI_IQNcosPU_paramPtr;
+                    C6ACCEL_TI_IQNcosPU_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNcosPU_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNcosPU_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNcosPU_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNcosPU_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNcosPU_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNcosPU(inArrRdr1[j], C6ACCEL_TI_IQNcosPU_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNATAN2PU_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNatan2PU_Params *C6ACCEL_TI_IQNatan2PU_paramPtr;
+                    C6ACCEL_TI_IQNatan2PU_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNatan2PU_paramPtr->y_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNatan2PU_paramPtr->x_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNatan2PU_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNatan2PU_paramPtr->y_InArrID1].buf;
+                         inArrRdr2 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNatan2PU_paramPtr->x_InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNatan2PU_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNatan2PU_paramPtr->n); j++){
+                              outArrRdr[j] = _IQNatan2PU(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNatan2PU_paramPtr->qfmt);
+                           }
+                       }
+                   }
+                 break;
+                 case(IQNMPYIQX_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNmpyIQX_Params *C6ACCEL_TI_IQNmpyIQX_paramPtr;
+                    C6ACCEL_TI_IQNmpyIQX_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNmpyIQX_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNmpyIQX_paramPtr->InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNmpyIQX_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNmpyIQX_paramPtr->InArrID1].buf;
+                         inArrRdr2 = (int *)inBufs->descs[C6ACCEL_TI_IQNmpyIQX_paramPtr->InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNmpyIQX_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNmpyIQX_paramPtr->n); j++){
+                             outArrRdr[j] = _IQNmpyIQx(inArrRdr1[j],
+                                                       C6ACCEL_TI_IQNmpyIQX_paramPtr->qfmt1,
+                                                       inArrRdr2[j],
+                                                       C6ACCEL_TI_IQNmpyIQX_paramPtr->qfmt2,
+                                                       C6ACCEL_TI_IQNmpyIQX_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNMPYI32INT_FXN_ID):{
+                     /* Unmarshal Parameters */
+                     I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                     IQNmpyI32int_Params *C6ACCEL_TI_IQNmpyI32int_paramPtr;
+                     C6ACCEL_TI_IQNmpyI32int_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_IQNmpyI32int_paramPtr->InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_IQNmpyI32int_paramPtr->InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_IQNmpyI32int_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNmpyI32int_paramPtr->InArrID1].buf;
+                          inArrRdr2 = (int *)inBufs->descs[C6ACCEL_TI_IQNmpyI32int_paramPtr->InArrID2].buf;
+                          outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNmpyI32int_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_IQNmpyI32int_paramPtr->n); j++){
+                              outArrRdr[j] = _IQNmpyI32int(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNmpyI32int_paramPtr->qfmt);
+                           }
+                       }
+                   }
+                 break;
+                 case(IQNMPYI32FRAC_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNmpyI32frac_Params *C6ACCEL_TI_IQNmpyI32frac_paramPtr;
+                    C6ACCEL_TI_IQNmpyI32frac_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNmpyI32frac_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNmpyI32frac_paramPtr->InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNmpyI32frac_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNmpyI32frac_paramPtr->InArrID1].buf;
+                         inArrRdr2 = (int *)inBufs->descs[C6ACCEL_TI_IQNmpyI32frac_paramPtr->InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNmpyI32frac_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNmpyI32frac_paramPtr->n); j++){
+                             outArrRdr[j] = _IQNmpyI32frac(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNmpyI32frac_paramPtr->qfmt);
+                          }
+                     }
+                 }
+                 break;
+                 case(IQNPOW_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNpow_Params *C6ACCEL_TI_IQNpow_paramPtr;
+                    C6ACCEL_TI_IQNpow_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNpow_paramPtr->A_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNpow_paramPtr->B_InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNpow_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNpow_paramPtr->A_InArrID1].buf;
+                         inArrRdr2 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNpow_paramPtr->B_InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNpow_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNpow_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNpow(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNpow_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNISQRT_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQNisqrt_Params *C6ACCEL_TI_IQNisqrt_paramPtr;
+                    C6ACCEL_TI_IQNisqrt_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNisqrt_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNisqrt_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                        /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNisqrt_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNisqrt_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNisqrt_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNisqrt(inArrRdr1[j], C6ACCEL_TI_IQNisqrt_paramPtr->qfmt);
+                           }
+                      }
+                  }
+                 break;
+                 case(IQNMAG_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *inArrRdr2, *outArrRdr;
+                    IQNmag_Params *C6ACCEL_TI_IQNmag_paramPtr;
+                    C6ACCEL_TI_IQNmag_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNmag_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNmag_paramPtr->InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_IQNmag_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNmag_paramPtr->InArrID1].buf;
+                         inArrRdr2 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNmag_paramPtr->InArrID2].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNmag_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNmag_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNmag(inArrRdr1[j], inArrRdr2[j], C6ACCEL_TI_IQNmag_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(IQNTOF_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1;
+                    float *out;
+                    IQNtoF_Params *C6ACCEL_TI_IQNtoF_paramPtr;
+                    C6ACCEL_TI_IQNtoF_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNtoF_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNtoF_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                        /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNtoF_paramPtr->InArrID1].buf;
+                         out = (float *)outBufs->descs[C6ACCEL_TI_IQNtoF_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNtoF_paramPtr-> n); j++){
+                             out[j] = _IQNtoF(inArrRdr1[j],C6ACCEL_TI_IQNtoF_paramPtr->qfmt);
+                          }
+                      }
+                  }
+                 break;
+                 case(FTOIQN_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *outArrRdr;
+                    float *in1;
+                    FtoIQN_Params *C6ACCEL_TI_FtoIQN_paramPtr;
+                    C6ACCEL_TI_FtoIQN_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_FtoIQN_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_FtoIQN_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         in1 = (float *)inBufs->descs[C6ACCEL_TI_FtoIQN_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_FtoIQN_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_FtoIQN_paramPtr-> n); j++){
+                             outArrRdr[j] = _FtoIQN(in1[j], C6ACCEL_TI_FtoIQN_paramPtr->qfmt);
+                           }
+                      }
+                  }
+                 break;
+                 case(IQN_FXN_ID):{
+                    /* Unmarshal Parameters */
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    IQN_Params *C6ACCEL_TI_IQN_paramPtr;
+                    C6ACCEL_TI_IQN_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQN_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQN_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQN_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQN_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQN_paramPtr-> n); j++){
+                             outArrRdr[j] = (I32_IQ)(inArrRdr1[j] * pow((double)2,(double)C6ACCEL_TI_IQN_paramPtr->qfmt));
+                           }
+                       }
+                   }
+                 break;
+                 case(IQXTOIQY_FXN_ID):{
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    /* Unmarshal Parameters */
+                    IQXtoIQY_Params *C6ACCEL_TI_IQXtoIQY_paramPtr;
+                    C6ACCEL_TI_IQXtoIQY_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQXtoIQY_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQXtoIQY_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQXtoIQY_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQXtoIQY_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQXtoIQY_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQXtoIQY(inArrRdr1[j],C6ACCEL_TI_IQXtoIQY_paramPtr->x,C6ACCEL_TI_IQXtoIQY_paramPtr->y);
+                           }
+                       }
+                   }
+                 break;
+                 case(IQNINT_FXN_ID):{
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    /* Unmarshal Parameters */
+                    IQNint_Params *C6ACCEL_TI_IQNint_paramPtr;
+                    C6ACCEL_TI_IQNint_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNint_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNint_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNint_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNint_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNint_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNint(inArrRdr1[j], C6ACCEL_TI_IQNint_paramPtr->qfmt);
+                           }
+                       }
+                   }
+                 break;
+                 case(IQNFRAC_FXN_ID):{
+                    I32_IQ *inArrRdr1, *outArrRdr;
+                    /* Unmarshal Parameters */
+                    IQNfrac_Params *C6ACCEL_TI_IQNfrac_paramPtr;
+                    C6ACCEL_TI_IQNfrac_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_IQNfrac_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_IQNfrac_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else{
+                         /* Call underlying kernel */
+                         inArrRdr1 = (I32_IQ *)inBufs->descs[C6ACCEL_TI_IQNfrac_paramPtr->InArrID1].buf;
+                         outArrRdr = (I32_IQ *)outBufs->descs[C6ACCEL_TI_IQNfrac_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_IQNfrac_paramPtr-> n); j++){
+                             outArrRdr[j] = _IQNfrac(inArrRdr1[j], C6ACCEL_TI_IQNfrac_paramPtr->qfmt);
+                           }
+                       }
+                   }
+                 break;
+                 /* FASTRTS LIB functions */
+                 case (ADDSP_FXN_ID):{
+                    float  *in1, *in2, *out;
+                    /* Unmarshal Parameters */
+                    addsp_i_Params *C6ACCEL_TI_addsp_i_paramPtr;
+                    C6ACCEL_TI_addsp_i_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_addsp_i_paramPtr->InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_addsp_i_paramPtr->InArrID2)>INBUF15)|
+                       ((C6ACCEL_TI_addsp_i_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                         /* Call underlying kernel */
+                         in1 = (float *)inBufs->descs[C6ACCEL_TI_addsp_i_paramPtr->InArrID1].buf;
+                         in2 = (float *)inBufs->descs[C6ACCEL_TI_addsp_i_paramPtr->InArrID2].buf;
+                         out = (float *)outBufs->descs[C6ACCEL_TI_addsp_i_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_addsp_i_paramPtr-> n); j++){
+                            out[j] = addsp_i(in1[j], in2[j]);
+                           }
+                       }
+                   }
+                 break;
+                 case (SUBSP_FXN_ID):{
+                     float  *in1, *in2, *out;
+                     /* Unmarshal Parameters */
+                     subsp_i_Params *C6ACCEL_TI_subsp_i_paramPtr;
+                     C6ACCEL_TI_subsp_i_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_subsp_i_paramPtr->InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_subsp_i_paramPtr->InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_subsp_i_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                      else{
+                          /* Call underlying kernel */
+                           in1 = (float *)inBufs->descs[C6ACCEL_TI_subsp_i_paramPtr->InArrID1].buf;
+                           in2 = (float *)inBufs->descs[C6ACCEL_TI_subsp_i_paramPtr->InArrID2].buf;
+                           out = (float *)outBufs->descs[C6ACCEL_TI_subsp_i_paramPtr->OutArrID1].buf;
+                           for(j=0 ; j < (C6ACCEL_TI_subsp_i_paramPtr-> n); j++){
+                              out[j] = subsp_i(in1[j], in2[j]);
+                             }
+                         }
+                    }
+                 break;
+                 case (MPYSP_FXN_ID):{
+                     float  *in1, *in2, *out;
+                     /* Unmarshal Parameters */
+                     mpysp_i_Params *C6ACCEL_TI_mpysp_i_paramPtr;
+                     C6ACCEL_TI_mpysp_i_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_mpysp_i_paramPtr->InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_mpysp_i_paramPtr->InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_mpysp_i_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                      else{
+                           /* Call underlying kernel */
+                           in1 = (float *)inBufs->descs[C6ACCEL_TI_mpysp_i_paramPtr->InArrID1].buf;
+                           in2 = (float *)inBufs->descs[C6ACCEL_TI_mpysp_i_paramPtr->InArrID2].buf;
+                           out = (float *)outBufs->descs[C6ACCEL_TI_mpysp_i_paramPtr->OutArrID1].buf;
+                           for(j=0 ; j < (C6ACCEL_TI_mpysp_i_paramPtr-> n); j++){
+                              out[j] = mpysp_i(in1[j], in2[j]);
+                            }
+                        }
+                   }
+                 break;
+                 case (DIVSP_FXN_ID):{
+                     float  *in1, *in2, *out;
+                     /* Unmarshal Parameters */
+                     divsp_i_Params  *C6ACCEL_TI_divsp_i_paramPtr;
+                     C6ACCEL_TI_divsp_i_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_divsp_i_paramPtr->InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_divsp_i_paramPtr->InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_divsp_i_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                      else{
+                           /* Call underlying kernel */
+                           in1 = (float *)inBufs->descs[C6ACCEL_TI_divsp_i_paramPtr->InArrID1].buf;
+                           in2 = (float *)inBufs->descs[C6ACCEL_TI_divsp_i_paramPtr->InArrID2].buf;
+                           out = (float *)outBufs->descs[C6ACCEL_TI_divsp_i_paramPtr->OutArrID1].buf;
+                           for(j=0 ; j < (C6ACCEL_TI_divsp_i_paramPtr-> n); j++){
+                              out[j] = divsp_i(in1[j], in2[j]);
+                             }
+                        }
+                   }
+                 break;
+                 case (RECIPSP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     recipsp_i_Params *C6ACCEL_TI_recipsp_i_paramPtr;
+                     C6ACCEL_TI_recipsp_i_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_recipsp_i_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_recipsp_i_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_recipsp_i_paramPtr->x_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_recipsp_i_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_recipsp_i_paramPtr-> n); j++){
+                              out[j] = recipsp_i(in1[j]);
+                           }
+                       }
+                   }
+                 break;
+                 case (INTSP_FXN_ID):{
+                     I32_IQ *inArrRdr1;
+                     float *out;
+                     /* Unmarshal Parameters */
+                     intsp_i_Params *C6ACCEL_TI_intsp_i_paramPtr;
+                     C6ACCEL_TI_intsp_i_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_intsp_i_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_intsp_i_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                         inArrRdr1 = (int *)inBufs->descs[C6ACCEL_TI_intsp_i_paramPtr->x_InArrID1].buf;
+                         out = (float *)outBufs->descs[C6ACCEL_TI_intsp_i_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_intsp_i_paramPtr-> n); j++){
+                             out[j] = intsp_i(inArrRdr1[j]);
+                           }
+                       }
+                   }
+                 break;
+                 case (SPINT_FXN_ID):{
+                     I32_IQ *outArrRdr;
+                     float *in1;
+                     /* Unmarshal Parameters */
+                     spint_i_Params *C6ACCEL_TI_spint_i_paramPtr;
+                     C6ACCEL_TI_spint_i_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_spint_i_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_spint_i_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                         in1 = (float *)inBufs->descs[C6ACCEL_TI_spint_i_paramPtr->x_InArrID1].buf;
+                         outArrRdr = (int *)outBufs->descs[C6ACCEL_TI_spint_i_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_spint_i_paramPtr-> n); j++){
+                             outArrRdr[j] = spint_i(in1[j]);
+                          }
+                       }
+                   }
+                 break;
+                 case (SPUINT_FXN_ID):{
+                    I32_IQ *outArrRdr;
+                    float *in1;
+                    /* Unmarshal Parameters */
+                    spuint_i_Params *C6ACCEL_TI_spuint_i_paramPtr;
+                    C6ACCEL_TI_spuint_i_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_spuint_i_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_spuint_i_paramPtr->OutArrID1)>OUTBUF15)){
+                       return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         in1 = (float *)inBufs->descs[C6ACCEL_TI_spuint_i_paramPtr->x_InArrID1].buf;
+                         outArrRdr = (int *)outBufs->descs[C6ACCEL_TI_spuint_i_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_spuint_i_paramPtr-> n); j++){
+                             outArrRdr[j] = spuint_i(in1[j]);
+                          }
+                      }
+                  }
+                 break;
+                 case (SQRTSP_FXN_ID):{
+                    float  *in1, *out;
+                    /* Unmarshal Parameters */
+                    sqrtsp_i_Params *C6ACCEL_TI_sqrtsp_i_paramPtr;
+                    C6ACCEL_TI_sqrtsp_i_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_sqrtsp_i_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_sqrtsp_i_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                         /* Call underlying kernel */
+                         in1 = (float *)inBufs->descs[C6ACCEL_TI_sqrtsp_i_paramPtr->x_InArrID1].buf;
+                         out = (float *)outBufs->descs[C6ACCEL_TI_sqrtsp_i_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_sqrtsp_i_paramPtr-> n); j++){
+                             out[j] = sqrtsp_i(in1[j]);
+                          }
+                      }
+                  }
+                 break;
+                 case (UINTSP_FXN_ID):{
+                    I32_IQ *inArrRdr1;
+                    float *out;
+                    /* Unmarshal Parameters */
+                    uintsp_i_Params *C6ACCEL_TI_uintsp_i_paramPtr;
+                    C6ACCEL_TI_uintsp_i_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if(((C6ACCEL_TI_uintsp_i_paramPtr->x_InArrID1)>INBUF15)|
+                       ((C6ACCEL_TI_uintsp_i_paramPtr->OutArrID1)>OUTBUF15)){
+                         return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                    else{
+                        /* Call underlying kernel */
+                         inArrRdr1 = (int *)inBufs->descs[C6ACCEL_TI_uintsp_i_paramPtr->x_InArrID1].buf;
+                         out = (float *)outBufs->descs[C6ACCEL_TI_uintsp_i_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_uintsp_i_paramPtr-> n); j++){
+                             out[j] = uintsp_i(inArrRdr1[j]);
+                          }
+                      }
+                   }
+                 break;
+                 #ifdef DEVICE_FLOAT
+                 case (ATANSP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     atansp_Params *C6ACCEL_TI_atansp_paramPtr;
+                     C6ACCEL_TI_atansp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_atansp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_atansp_paramPtr->OutArrID1)>OUTBUF15)){
+                        return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_atansp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_atansp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_atansp_paramPtr->n); j++){
+                              out[j] = atansp(in1[j]);
+                           }
+                      }
+                  }
+                 break;
+                 case (COSSP_FXN_ID):{
+                        float  *in1, *out;
+                        /* Unmarshal Parameters */
+                        cossp_Params *C6ACCEL_TI_cossp_paramPtr;
+                        C6ACCEL_TI_cossp_paramPtr = pFnArray;
+                        /* Parameter check */
+                         if(((C6ACCEL_TI_cossp_paramPtr->z_InArrID1)>INBUF15)|
+                            ((C6ACCEL_TI_cossp_paramPtr->OutArrID1)>OUTBUF15)){
+                             return(IUNIVERSAL_EPARAMFAIL);
+                          }
+                         else{
+                              /* Call underlying kernel */
+                              in1 = (float *)inBufs->descs[C6ACCEL_TI_cossp_paramPtr->z_InArrID1].buf;
+                              out = (float *)outBufs->descs[C6ACCEL_TI_cossp_paramPtr->OutArrID1].buf;
+                              for(j=0 ; j < (C6ACCEL_TI_cossp_paramPtr-> n); j++){
+                                out[j] = cossp(in1[j]);
+                             }
+                         }
+                    }
+                 break;
+                 case (SINSP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     sinsp_Params *C6ACCEL_TI_sinsp_paramPtr;
+                     C6ACCEL_TI_sinsp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_sinsp_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_sinsp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_sinsp_paramPtr->x_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_sinsp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_sinsp_paramPtr-> n); j++){
+                                out[j] = sinsp(in1[j]);
+                            }
+                        }
+                    }
+                 break;
+                 case (EXPSP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     expsp_Params *C6ACCEL_TI_expsp_paramPtr;
+                     C6ACCEL_TI_expsp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_expsp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_expsp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_expsp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_expsp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_expsp_paramPtr->n); j++){
+                              out[j] = expsp(in1[j]);
+                            }
+                        }
+                    }
+                 break;
+                 case (LOGSP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     logsp_Params *C6ACCEL_TI_logsp_paramPtr;
+                     C6ACCEL_TI_logsp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_logsp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_logsp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_logsp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_logsp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_logsp_paramPtr-> n); j++){
+                              out[j] = logsp(in1[j]);
+                           }
+                       }
+                  }
+                 break;
+                 case (POWSP_FXN_ID):{
+                     float  *in1, *in2, *out;
+                     /* Unmarshal Parameters */
+                     powsp_Params *C6ACCEL_TI_powsp_paramPtr;
+                     C6ACCEL_TI_powsp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_powsp_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_powsp_paramPtr->y_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_powsp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_powsp_paramPtr->x_InArrID1].buf;
+                          in2 = (float *)inBufs->descs[C6ACCEL_TI_powsp_paramPtr->y_InArrID2].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_powsp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_powsp_paramPtr-> n); j++){
+                              out[j] = powsp(in1[j],in2[j]);
+                           }
+                       }
+                  }
+                 break;
+                 case (ATANDP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     atandp_Params *C6ACCEL_TI_atandp_paramPtr;
+                     C6ACCEL_TI_atandp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_atandp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_atandp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_atandp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_atandp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_atandp_paramPtr->n); j++){
+                              out[j] = atandp(in1[j]);
+                           }
+                       }
+                  }
+                 break;
+                 case (COSDP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     cosdp_Params *C6ACCEL_TI_cosdp_paramPtr;
+                     C6ACCEL_TI_cosdp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_cosdp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_cosdp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                      else{
+                         /* Call underlying kernel */
+                         in1 = (float *)inBufs->descs[C6ACCEL_TI_cosdp_paramPtr->z_InArrID1].buf;
+                         out = (float *)outBufs->descs[C6ACCEL_TI_cosdp_paramPtr->OutArrID1].buf;
+                         for(j=0 ; j < (C6ACCEL_TI_cosdp_paramPtr-> n); j++){
+                                out[j] = cosdp(in1[j]);
+                           }
+                       }
+                  }
+                 break;
+                 case (SINDP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     sindp_Params *C6ACCEL_TI_sindp_paramPtr;
+                     C6ACCEL_TI_sindp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_sindp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_sindp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_sindp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_sindp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_sindp_paramPtr-> n); j++){
+                              out[j] = sindp(in1[j]);
+                           }
+                      }
+                  }
+                 break;
+                 case (EXPDP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     expdp_Params *C6ACCEL_TI_expdp_paramPtr;
+                     C6ACCEL_TI_expdp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_expdp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_expdp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_expdp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_expdp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_expdp_paramPtr->n); j++){
+                              out[j] = expdp(in1[j]);
+                            }
+                        }
+                    }
+                 break;
+                 case (LOGDP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     logdp_Params *C6ACCEL_TI_logdp_paramPtr;
+                     C6ACCEL_TI_logdp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_logdp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_logdp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_logdp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_logdp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_logdp_paramPtr-> n); j++){
+                              out[j] = logdp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (POWDP_FXN_ID):{
+                     float  *in1,*in2, *out;
+                     /* Unmarshal Parameters */
+                     powdp_Params *C6ACCEL_TI_powdp_paramPtr;
+                     C6ACCEL_TI_powdp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_powdp_paramPtr->x_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_powdp_paramPtr->y_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_powdp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_powdp_paramPtr->x_InArrID1].buf;
+                          in2 = (float *)inBufs->descs[C6ACCEL_TI_powdp_paramPtr->y_InArrID2].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_powdp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_powdp_paramPtr-> n); j++){
+                              out[j] = powdp(in1[j],in2[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (RECIPDP_FXN_ID):{
+                     float  *in1,*out;
+                     /* Unmarshal Parameters */
+                     recipdp_Params *C6ACCEL_TI_recipdp_paramPtr;
+                     C6ACCEL_TI_recipdp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_recipdp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_recipdp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_recipdp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_recipdp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_recipdp_paramPtr-> n); j++){
+                              out[j] = recipdp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (RSQRTDP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     rsqrtdp_Params *C6ACCEL_TI_rsqrtdp_paramPtr;
+                     C6ACCEL_TI_rsqrtdp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_rsqrtdp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_rsqrtdp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_rsqrtdp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_rsqrtdp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_rsqrtdp_paramPtr-> n); j++){
+                              out[j] = rsqrtdp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (SQRTDP_FXN_ID):{
+                     float  *in1,*out;
+                     /* Unmarshal Parameters */
+                     sqrtdp_Params *C6ACCEL_TI_sqrtdp_paramPtr;
+                     C6ACCEL_TI_sqrtdp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_sqrtdp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_sqrtdp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_sqrtdp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_sqrtdp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_sqrtdp_paramPtr-> n); j++){
+                              out[j] = sqrtdp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (EXP2DP_FXN_ID):{
+                     float  *in1,*out;
+                     /* Unmarshal Parameters */
+                     exp2dp_Params *C6ACCEL_TI_exp2dp_paramPtr;
+                     C6ACCEL_TI_exp2dp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_exp2dp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_exp2dp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_exp2dp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_exp2dp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_exp2dp_paramPtr-> n); j++){
+                              out[j] = exp2dp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (EXP10DP_FXN_ID):{
+                     float  *in1,*out;
+                     /* Unmarshal Parameters */
+                     exp10dp_Params *C6ACCEL_TI_exp10dp_paramPtr;
+                     C6ACCEL_TI_exp10dp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_exp10dp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_exp10dp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_exp10dp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_exp10dp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_exp10dp_paramPtr-> n); j++){
+                              out[j] = exp10dp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (ATAN2DP_FXN_ID):{
+                     float  *in1,*in2, *out;
+                     /* Unmarshal Parameters */
+                     atan2dp_Params *C6ACCEL_TI_atan2dp_paramPtr;
+                     C6ACCEL_TI_atan2dp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_atan2dp_paramPtr->y_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_atan2dp_paramPtr->x_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_atan2dp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_atan2dp_paramPtr->y_InArrID1].buf;
+                          in2 = (float *)inBufs->descs[C6ACCEL_TI_atan2dp_paramPtr->x_InArrID2].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_atan2dp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_atan2dp_paramPtr-> n); j++){
+                              out[j] = atan2dp(in1[j],in2[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (RECIPF_FXN_ID):{
+                     float  *in1,*out;
+                     /* Unmarshal Parameters */
+                     recipsp_Params *C6ACCEL_TI_recipsp_paramPtr;
+                     C6ACCEL_TI_recipsp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_recipsp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_recipsp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_recipsp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_recipsp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_recipsp_paramPtr-> n); j++){
+                              out[j] = recipsp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (RSQRTSP_FXN_ID):{
+                     float  *in1, *out;
+                     /* Unmarshal Parameters */
+                     rsqrtsp_Params *C6ACCEL_TI_rsqrtsp_paramPtr;
+                     C6ACCEL_TI_rsqrtsp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_rsqrtsp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_rsqrtsp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_rsqrtsp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_rsqrtsp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_rsqrtsp_paramPtr-> n); j++){
+                              out[j] = rsqrtsp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (SQRT_FXN_ID):{
+                     float  *in1,*out;
+                     /* Unmarshal Parameters */
+                     sqrtsp_Params *C6ACCEL_TI_sqrtsp_paramPtr;
+                     C6ACCEL_TI_sqrtsp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_sqrtsp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_sqrtsp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_sqrtsp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_sqrtsp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_sqrtsp_paramPtr-> n); j++){
+                              out[j] = sqrtsp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (EXP2SP_FXN_ID):{
+                     float  *in1,*out;
+                     /* Unmarshal Parameters */
+                     exp2sp_Params *C6ACCEL_TI_exp2sp_paramPtr;
+                     C6ACCEL_TI_exp2sp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_exp2sp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_exp2sp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_exp2sp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_exp2sp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_exp2sp_paramPtr-> n); j++){
+                              out[j] = exp2sp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (EXP10SP_FXN_ID):{
+                     float  *in1,*out;
+                     /* Unmarshal Parameters */
+                     exp10sp_Params *C6ACCEL_TI_exp10sp_paramPtr;
+                     C6ACCEL_TI_exp10sp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_exp10sp_paramPtr->z_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_exp10sp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_exp10sp_paramPtr->z_InArrID1].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_exp10sp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_exp10sp_paramPtr-> n); j++){
+                              out[j] = exp10sp(in1[j]);
+                            }
+                       }
+                  }
+                 break;
+                 case (ATAN2SP_FXN_ID):{
+                     float  *in1,*in2, *out;
+                     /* Unmarshal Parameters */
+                     atan2sp_Params *C6ACCEL_TI_atan2sp_paramPtr;
+                     C6ACCEL_TI_atan2sp_paramPtr = pFnArray;
+                     /* Parameter check */
+                     if(((C6ACCEL_TI_atan2sp_paramPtr->y_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_atan2sp_paramPtr->x_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_atan2sp_paramPtr->OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                      }
+                     else{
+                          /* Call underlying kernel */
+                          in1 = (float *)inBufs->descs[C6ACCEL_TI_atan2sp_paramPtr->y_InArrID1].buf;
+                          in2 = (float *)inBufs->descs[C6ACCEL_TI_atan2sp_paramPtr->x_InArrID2].buf;
+                          out = (float *)outBufs->descs[C6ACCEL_TI_atan2sp_paramPtr->OutArrID1].buf;
+                          for(j=0 ; j < (C6ACCEL_TI_atan2sp_paramPtr-> n); j++){
+                              out[j] = atan2sp(in1[j],in2[j]);
+                            }
+                       }
+                  }
+                 break;
+                 #endif
+                 default:
+                    /*Error caused due to passing of an invalid ID*/
+                    return(IUNIVERSAL_EFXNIDFAIL);
+                  }
+              break;
+              /* Reserved for future purposes */
+              case (ANALYTICSLIB_FXN_ID):
+                   return(IUNIVERSAL_EFXNIDFAIL);
+              case (MEDICALLIB_FXN_ID):
+                   return(IUNIVERSAL_EFXNIDFAIL);
+              case(PWRCNTRLLIB_FXN_ID):
+                   return(IUNIVERSAL_EFXNIDFAIL);
+              case(AUDSPECHLIB_FXN_ID):
+                   return(IUNIVERSAL_EFXNIDFAIL);
+#ifdef USE_VLIB
+	      case(VLIB_FXN_ID):
+     		/* VLIB functions */
+                switch ( fxnID & fxnidMsk){
+                  case(INTEGRALIMAGE_8_FXN_ID):{
+                    /* Unmarshal Parameters */
+		    VLIB_integralImage8_Params *C6ACCEL_TI_VLIB_integralImage8_paramPtr;
+                    C6ACCEL_TI_VLIB_integralImage8_paramPtr = pFnArray;
+                    /* Parameter check */
+                    if (((C6ACCEL_TI_VLIB_integralImage8_paramPtr->pIn_InArrID1)>INBUF15)|
+                        ((C6ACCEL_TI_VLIB_integralImage8_paramPtr->pLastLine_InArrID2)>INBUF15)|
+                        ((C6ACCEL_TI_VLIB_integralImage8_paramPtr->pOut_OutArrID1)>OUTBUF15)){
+                          return(IUNIVERSAL_EPARAMFAIL);
+                     }
+                     else 
+                        /* Call underlying kernel */
+                        VLIB_integralImage8( (unsigned char*)inBufs->descs[C6ACCEL_TI_VLIB_integralImage8_paramPtr->pIn_InArrID1].buf,
+                                       	   C6ACCEL_TI_VLIB_integralImage8_paramPtr->inCols,
+					   C6ACCEL_TI_VLIB_integralImage8_paramPtr->inRows,
+                                           (unsigned int *)inBufs->descs[C6ACCEL_TI_VLIB_integralImage8_paramPtr->pLastLine_InArrID2].buf,
+                                           (unsigned int *)outBufs->descs[C6ACCEL_TI_VLIB_integralImage8_paramPtr->pOut_OutArrID1].buf);
+                   }
+		  break;
+		  default:
+	  	    /*Error caused due to passing of an invalid ID*/
+		    return(IUNIVERSAL_EFXNIDFAIL);
+                }
+	        break;
+#endif
+                default:
+                   return(IUNIVERSAL_EFXNIDFAIL);
+            }
+          break;
+          case (OTHER):
+              switch (( fxnID & fxntypMsk)>>FXNTYP_TAG_SHIFT){
+              /* Non-TI vendors can add their kernels in this section */
+                   case (DSPLIB_FXN_ID):
+   		     switch(fxnID & fxnidMsk) {
+		       case (DFT_F_FXN_ID): {
+			 char *src, *dst;
+			 /* Unmarshal Parameters */
+			 DSP_dft_f_Params *C6ACCEL_DSP_dft_f_paramPtr;
+                         C6ACCEL_DSP_dft_f_paramPtr = pFnArray;
+			 /* Parameter check */
+                         if (((C6ACCEL_DSP_dft_f_paramPtr->src_InArrID1)>INBUF15)|
+                             ((C6ACCEL_DSP_dft_f_paramPtr->dst_OutArrID1)>OUTBUF15)){
+                              return(IUNIVERSAL_EPARAMFAIL);
+                         }
+                         else {
+                           /* Call underlying kernel */
+			   /* Parameter check is done in the library*/
+                           /* Call underlying kernel */
+   			   src = C6ACCEL_DSP_dft_f_paramPtr->src.imageData;
+  			   dst = C6ACCEL_DSP_dft_f_paramPtr->dst.imageData;
+			   C6ACCEL_DSP_dft_f_paramPtr->src.imageData = (char *)inBufs->descs[C6ACCEL_DSP_dft_f_paramPtr->src_InArrID1].buf;
+  			   C6ACCEL_DSP_dft_f_paramPtr->dst.imageData = (char *)outBufs->descs[C6ACCEL_DSP_dft_f_paramPtr->dst_OutArrID1].buf;
+			   #ifdef USE_CXCORE
+			   cvDFT( &C6ACCEL_DSP_dft_f_paramPtr->src,
+			        &C6ACCEL_DSP_dft_f_paramPtr->dst,
+			     	C6ACCEL_DSP_dft_f_paramPtr->dxtType,
+				C6ACCEL_DSP_dft_f_paramPtr->nonZeroRows
+			        );
+			   #else
+			   return(IUNIVERSAL_EFXNIDFAIL);
+			   #endif
+			   C6ACCEL_DSP_dft_f_paramPtr->src.imageData = src;
+  			   C6ACCEL_DSP_dft_f_paramPtr->dst.imageData = dst;
+			   }
+			 }		         
+			 break;
+		       default:
+			 /* Error caused due to passing of an invalid ID */
+			 return(IUNIVERSAL_EFXNIDFAIL);
+                       }
+		   break;
+                   case (IMGLIB_FXN_ID):
+		     switch(fxnID & fxnidMsk) {
+		       case (RGB_TO_Y_FXN_ID): {
+			 /* Unmarshal Parameters */   
+                         IMG_RGB_To_Y_Params *C6ACCEL_TI_IMG_RGB_To_Y_paramPtr;
+                         C6ACCEL_TI_IMG_RGB_To_Y_paramPtr = pFnArray;
+                         /* Parameter check */
+                         if(((C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->src_InArrID1)>INBUF15)|
+                            ((C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->dst_OutArrID1)>INBUF15)){
+                            return(IUNIVERSAL_EPARAMFAIL);
+                          }
+                         else
+                         /* Call underlying kernel */
+                            IMG_RGB_To_Y((unsigned char *)inBufs->descs[C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->src_InArrID1].buf,
+                                         (unsigned char *)outBufs->descs[C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->dst_OutArrID1].buf,
+                                         C6ACCEL_TI_IMG_RGB_To_Y_paramPtr->count);
+                          
+			}
+			break;
+		       default:
+			 /* Error caused due to passing of an invalid ID */
+			 return(IUNIVERSAL_EFXNIDFAIL);
+		      }
+                   break;     
+                   case(MATHLIB_FXN_ID):
+                        return(IUNIVERSAL_EFXNIDFAIL);
+                   case (ANALYTICSLIB_FXN_ID):
+                        return(IUNIVERSAL_EFXNIDFAIL);
+                   case (MEDICALLIB_FXN_ID):
+                        return(IUNIVERSAL_EFXNIDFAIL);
+                   case(PWRCNTRLLIB_FXN_ID):
+                        return(IUNIVERSAL_EFXNIDFAIL);
+                   case(AUDSPECHLIB_FXN_ID):
+                        return(IUNIVERSAL_EFXNIDFAIL);
+                   default:
+                      return(IUNIVERSAL_EFXNIDFAIL);
+                }
+	 break;
+         default:
+                return(IUNIVERSAL_EFXNIDFAIL);
+       }
+    }
+ }
+
+    /* report how we accessed the input buffer */
+    for (i=0;i<inBufs->numBufs; i++)
+     {
+        inBufs->descs[i].accessMask = 0;
+        XDM_SETACCESSMODE_READ(inBufs->descs[i].accessMask);
+      }
+    /* and output buffer */
+    for (i=0;i< outBufs->numBufs; i++)
+     {
+        outBufs->descs[i].accessMask = 0;
+        XDM_SETACCESSMODE_WRITE(outBufs->descs[i].accessMask);
+      }
+
+    return (IUNIVERSAL_EOK);
+}
+
+
+/******************************************************************************
+ *  ======== C6Accel_TI_control ========
+ *****************************************************************************/
+/* ARGSUSED - this line tells the TI compiler not to warn about unused args. */
+XDAS_Int32 C6ACCEL_TI_control(IUNIVERSAL_Handle handle,
+    IUNIVERSAL_Cmd id, IUNIVERSAL_DynamicParams *dynParams,
+    IUNIVERSAL_Status *status)
+{
+    XDAS_Int32 retVal;
+
+    /* validate arguments - this codec only supports "base" xDM. */
+    if ((dynParams->size != sizeof(*dynParams)) ||
+        (status->size != sizeof(*status))) {
+        return (IUNIVERSAL_EUNSUPPORTED);
+    }
+
+    /* initialize for the general case where we don't access the data buffer */
+    XDM_CLEARACCESSMODE_READ(status->data.descs[0].accessMask);
+    XDM_CLEARACCESSMODE_WRITE(status->data.descs[0].accessMask);
+
+    switch (id) {
+        case XDM_GETVERSION:
+            if ((status->data.descs[0].buf != NULL) &&
+                (status->data.descs[0].bufSize >=
+                    strlen(C6ACCEL_VERSIONSTRING))) {
+
+                strncpy((char *)status->data.descs[0].buf,
+                        C6ACCEL_VERSIONSTRING,
+                        strlen(C6ACCEL_VERSIONSTRING));
+
+                /* null terminate the string */
+                status->data.descs[0].
+                buf[strlen(C6ACCEL_VERSIONSTRING)] = '\0';
+
+                /* strncpy wrote to the data buffer */
+                XDM_SETACCESSMODE_WRITE(status->data.descs[0].accessMask);
+                retVal = IUNIVERSAL_EOK;
+            }
+            else {
+                retVal = IUNIVERSAL_EFAIL;
+            }
+
+        break;
+
+        default:
+            /* unsupported cmd */
+            retVal = IUNIVERSAL_EFAIL;
+        break;
+    }
+
+    return (retVal);
+}
+
+/****************************************************************************
+**                      Algorithm specific Function defintions
+*****************************************************************************/
+/* Function to check the condition if a number is power of 2         *
+ *   This function is useful in checking the N parameter passed to   *
+ *   FFT and Inverse FFT functions are power of 2                    */
+
+static U16_IQ IsPowOfTwo( Uword40 x)
+{
+   return (x != 0) && ((x & (x - 1)) == 0);
+}
+
+/****************************************************************************
+**                        END OF FILE
+*****************************************************************************/
+/*
+ *  @(#) ti.C6accel; 1, 0, 0,10; 5-4-2010 17:59:00;
+ */
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/src/IMG_sobel_3x3_8_16_i.c c6accel_1_00_00_04_async/dsp/alg/src/IMG_sobel_3x3_8_16_i.c
--- c6accel_1_00_00_04_async0/dsp/alg/src/IMG_sobel_3x3_8_16_i.c	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/alg/src/IMG_sobel_3x3_8_16_i.c	2010-08-14 17:17:16.000000000 -0500
@@ -0,0 +1,257 @@
+/* ======================================================================== */
+/*  TEXAS INSTRUMENTS, INC.                                                 */
+/*                                                                          */
+/*  IMGLIB-2  DSP Image/Video Processing Library                            */
+/*                                                                          */
+/*      Release:        Revision 2.0.1                                      */
+/*      Snapshot date:  6-May-2008                                          */
+/*                                                                          */
+/*  This library contains proprietary intellectual property of Texas        */
+/*  Instruments, Inc.  The library and its source code are protected by     */
+/*  various copyrights, and portions may also be protected by patents or    */
+/*  other legal protections.                                                */
+/*                                                                          */
+/*  This software is licensed for use with Texas Instruments TMS320         */
+/*  family DSPs.  This license was provided to you prior to installing      */
+/*  the software.  You may review this license by consulting the file       */
+/*  TI_license.PDF which accompanies the files in this library.             */
+/* ------------------------------------------------------------------------ */
+/*          Copyright (C) 2008 Texas Instruments, Incorporated.             */
+/*                          All Rights Reserved.                            */
+/* ======================================================================== */
+/* ======================================================================== */
+/*  TEXAS INSTRUMENTS, INC.                                                 */
+/*                                                                          */
+/*  NAME                                                                    */
+/*      sobel_3x3_8                                                         */
+/*                                                                          */
+/*  USAGE                                                                   */
+/*      This routine is C-callable and can be called as:                    */
+/*                                                                          */
+/*      void sobel_3x3_8                                                    */
+/*      (                                                                   */
+/*          const unsigned char *in_data,      // Input image data  //      */
+/*          unsigned char       *out_data,     // Output image data //      */ 
+/*          short cols, short rows             // Image dimensions  //      */ 
+/*      )                                                                   */
+/*                                                                          */
+/*      The sobel filter is applied to the input image.  The input image    */ 
+/*      dimensions are given by the arguments 'cols' and 'rows'.  The       */
+/*      output image is 'cols' pixels wide and 'rows - 2' pixels tall.      */
+/*                                                                          */
+/*  DESCRIPTION                                                             */
+/*                                                                          */
+/*      To see how the implementation is going to work on the input         */
+/*      buffer, lets imagine we have the following input buffer:            */  
+/*      lets imagine we have the following input buffer:                    */
+/*                                                                          */
+/*              yyyyyyyyyyyyyyyy                                            */
+/*              yxxxxxxxxxxxxxxy                                            */
+/*              yxxxxxxxxxxxxxxy                                            */
+/*              yxxxxxxxxxxxxxxy                                            */
+/*              yxxxxxxxxxxxxxxy                                            */
+/*              yyyyyyyyyyyyyyyy                                            */
+/*                                                                          */
+/*      The output buffer would be:                                         */
+/*                                                                          */
+/*              tXXXXXXXXXXXXXXz                                            */
+/*              zXXXXXXXXXXXXXXz                                            */
+/*              zXXXXXXXXXXXXXXz                                            */
+/*              zXXXXXXXXXXXXXXt                                            */  
+/*                                                                          */
+/*      Where:                                                              */
+/*                                                                          */
+/*          X = sobel(x)    The algorithm is applied to that pixel.         */
+/*                          The correct output is obtained, the data        */ 
+/*                          around the pixels we work on is used            */
+/*                                                                          */
+/*          t               Whatever was in the output buffer in that       */
+/*                          position is kept there.                         */
+/*                                                                          */
+/*          z = sobel(y)    The algorithm is applied to that pixel.         */
+/*                          The output is not meaningful, because the       */
+/*                          necessary data to process the pixel is not      */
+/*                          available.  This is because for each output     */
+/*                          pixel we need input pixels from the right and   */
+/*                          from the left of the output pixel.  But this    */ 
+/*                          data doesn't exist.                             */
+/*                                                                          */
+/*      This means that we will only process (rows-2) lines.  Then, we      */
+/*      will process all the pixels inside each line. Even though the       */
+/*      results for the first and last pixels in each line will not         */
+/*      be relevant, it makes the control much simpler and ends up          */
+/*      saving cycles.                                                      */
+/*                                                                          */ 
+/*      Also the first pixel in the first processed line and the            */ 
+/*      last pixel in the last processed line will not be computed.         */ 
+/*      It is not necessary, since the results would be bogus.              */
+/*                                                                          */
+/*      The following horizontal and vertical masks that are                */
+/*      applied to the input buffer to obtain one output pixel.             */
+/*                                                                          */
+/*          Horizontal:                                                     */
+/*              -1 -2 -1                                                    */
+/*               0  0  0                                                    */
+/*               1  2  1                                                    */
+/*                                                                          */
+/*          Vertical:                                                       */
+/*              -1  0  1                                                    */
+/*              -2  0  2                                                    */
+/*              -1  0  1                                                    */
+/*                                                                          */
+/*  ASSUMPTIONS                                                             */
+/*      (rows * cols) must be a multiple of 8                               */
+/*      The input image width must be even (eg. 'cols' must be even).       */
+/*                                                                          */
+/*  NOTES                                                                   */
+/*      The values of the left-most and right-most pixels on each line      */
+/*      of the output are not well-defined.                                 */
+/* ------------------------------------------------------------------------ */
+/*            Copyright (c) 2008 Texas Instruments, Incorporated.           */
+/*                           All Rights Reserved.                           */
+/* ======================================================================== */
+#include <c6x.h>
+
+void IMG_sobel_3x3_8_16
+(
+    const unsigned char *restrict in,   /* Input image data   */
+    unsigned short       *restrict out,  /* Output image data  */
+    short cols, short rows              /* Image dimensions   */
+)
+{    
+    int i,t13,t14,end,final_pass;
+    int w = cols;
+    int mult1   = 0x00fffeff;
+    int mult2   = 0x00010201;
+
+    int mult1_b = 0xfffeff00;
+    int mult2_b = 0x01020100;
+
+    _nassert(cols > 3);
+    _nassert(cols % 2 == 0);
+    _nassert(rows > 3);
+    _nassert(cols * (rows - 2) - 2 >= 8);
+
+    /* -------------------------------------------------------------------- */
+    /*  Iterate over entire image as a single, continuous raster line.      */
+    /* -------------------------------------------------------------------- */
+    
+    end        = (cols*(rows-2) - 2);
+    final_pass = end - 6;
+
+    for (i = 0; i < end; i+=8)
+    {
+        double in1_d,in1_d2,in2_d1,in2_d2,in3_d,in3_d2;
+        unsigned int in1_l,in1_h,in2_l,in2_h,in3_l,in3_h;
+        unsigned int in2_l2,in2_h2;
+        unsigned int tmp1,tmp3,tmp2,tmp4;
+        unsigned int t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12;
+        int H, H3, H5, H7;
+        unsigned int b1,b2,b3,b4,b5,b6,b7,b8;
+        double b10,b11,b12,b13,b14,b15;
+      
+        /* ---------------------------------------------------------------- */
+        /*  Read in the required 3x3 region from the input.                 */
+        /* ---------------------------------------------------------------- */
+
+        in1_d   = _memd8_const((void*)&in[i]);
+        in1_d2  = _memd8_const((void*)&in[i+2]);
+        tmp1    = _lo(in1_d2);
+        tmp2    = _hi(in1_d2);
+        in1_l   = _lo(in1_d);
+        in1_h   = _hi(in1_d);
+
+        in2_d1  = _memd8_const((void*)&in[i+w]);
+        in2_d2  = _memd8_const((void*)&in[i+w+2]);
+        in2_l   = _lo(in2_d1);
+        in2_l2  = _hi(in2_d1);
+        in2_h   = _lo(in2_d2);
+        in2_h2  = _hi(in2_d2);
+
+        in3_d   = _memd8_const((void*)&in[i+2*w]);
+        in3_d2  = _memd8_const((void*)&in[i+2*w+2]);
+        tmp3    = _lo(in3_d2);
+        tmp4    = _hi(in3_d2);
+        in3_l   = _lo(in3_d);
+        in3_h   = _hi(in3_d);
+
+        /* ---------------------------------------------------------------- */
+        /*  Apply horizontal and vertical filter masks.  The final filter   */
+        /*  output is the sum of the absolute values of these filters.      */
+        /* ---------------------------------------------------------------- */
+        // i00=in[i    ]; i01=in[i    +1]; i02=in[i    +2];
+        // i10=in[i+  w];                  i12=in[i+  w+2];
+        // i20=in[i+2*w]; i21=in[i+2*w+1]; i22=in[i+2*w+2];
+        // H = -i00 - 2*i01 -   i02 +   i20 + 2*i21 + i22;
+        // V = -i00 +   i02 - 2*i10 + 2*i12 -   i20 + i22;    
+
+        /* t1, t3, t5, t7 are the horizontal guys, two shorts per word */
+
+        H    = _add2(_pack2(_dotpsu4(mult1_b,in1_l),_dotpsu4(mult1,in1_l)),
+                     _pack2(_dotpsu4(mult2_b,in3_l),_dotpsu4(mult2,in3_l)));
+        H3   = _add2(_pack2(_dotpsu4(mult1_b,tmp1), _dotpsu4(mult1,tmp1)), 
+                     _pack2(_dotpsu4(mult2_b,tmp3), _dotpsu4(mult2,tmp3)));
+        H5   = _add2(_pack2(_dotpsu4(mult1_b,in1_h),_dotpsu4(mult1,in1_h)),
+                     _pack2(_dotpsu4(mult2_b,in3_h),_dotpsu4(mult2,in3_h)));
+        H7   = _add2(_pack2(_dotpsu4(mult1_b,tmp2), _dotpsu4(mult1,tmp2)),
+                     _pack2(_dotpsu4(mult2_b,tmp4), _dotpsu4(mult2,tmp4)));
+
+        
+        t1 = _abs2(H);
+        t3 = _abs2(H3);
+        t5 = _abs2(H5);
+        t7 = _abs2(H7);
+
+        /* t2, t4, t6, t8 are the vertical guys, two shorts per word */
+
+        b10= _mpyu4(in2_l2,0x2020202);
+        b11= _mpyu4(in1_h, 0x1010101);
+        b12= _mpyu4(in2_l, 0x2020202);
+        b13= _mpyu4(in2_h, 0x2020202);
+        b14= _mpyu4(in2_h2,0x2020202);
+        b15= _mpyu4(tmp2,  0x1010101);
+
+        b1 = _add2(_add2(_unpklu4(in1_l),_lo(b12)),_unpklu4(in3_l));
+        b2 = _add2(_add2(_unpkhu4(in1_l),_hi(b12)),_unpkhu4(in3_l));
+        b3 = _add2(_add2(_unpklu4(tmp1), _lo(b13)),_unpklu4(tmp3));
+        b4 = _add2(_add2(_unpkhu4(tmp1), _hi(b13)),_unpkhu4(tmp3));
+        b5 = _add2(_add2(_lo(b11),_lo(b10)),_unpklu4(in3_h));
+        b6 = _add2(_add2(_hi(b11),_hi(b10)),_unpkhu4(in3_h));
+        b7 = _add2(_add2(_lo(b15),_lo(b14)),_unpklu4(tmp4));
+        b8 = _add2(_add2(_hi(b15),_hi(b14)),_unpkhu4(tmp4));
+
+        t2 = _abs2(_sub2(b2,b1));
+        t4 = _abs2(_sub2(b4,b3));
+        t6 = _abs2(_sub2(b6,b5));
+        t8 = _abs2(_sub2(b8,b7));
+        
+        t9 = _add2(t1,t2);
+        t10= _add2(t3,t4);
+        t11= _add2(t5,t6);
+        t12= _add2(t7,t8);
+
+        t13 = _spacku4(t10,t9);
+        t14 = _spacku4(t12,t11);
+		
+        if(i!=final_pass) /* the last 6 outputs must be stored seperately */ {
+		  _memd8((void *)&out[i+1]) = _itod(_unpkhu4(t13), _unpklu4(t13));
+		  _memd8((void *)&out[i+5]) = _itod(_unpkhu4(t14), _unpklu4(t14)); //changed &out[i+3] to &out[i+5]
+		}
+    }
+
+#if 0
+GAGAN: TAKING OUT FOR NOW
+    /* clean up the last 6 "output" guys */
+    _mem4((void *)&out[i-7]) = t13;
+    out[i-3] = t14 & 0xff;
+    out[i-2] = (t14>>8)&0xff;
+#endif
+
+}
+
+/* ======================================================================== */
+/*  End of file:  IMG_sobel_3x3_8_i.c                                       */
+/* ------------------------------------------------------------------------ */
+/*            Copyright (c) 2008 Texas Instruments, Incorporated.           */
+/*                           All Rights Reserved.                           */
+/* ======================================================================== */
diff -uNr c6accel_1_00_00_04_async0/dsp/alg/src/RGB_To_Y.c c6accel_1_00_00_04_async/dsp/alg/src/RGB_To_Y.c
--- c6accel_1_00_00_04_async0/dsp/alg/src/RGB_To_Y.c	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/alg/src/RGB_To_Y.c	2010-08-14 17:17:16.000000000 -0500
@@ -0,0 +1,45 @@
+
+
+void IMG_RGB_To_Y (
+		unsigned char * restrict src,
+		unsigned char * restrict dst,		
+		unsigned int count
+) {
+
+	unsigned short R, G, B;
+	
+	unsigned short RC = 0x4c;
+	unsigned short GC = 0x95;
+	unsigned short BC = 0x1D;
+
+	unsigned int acc; 
+
+	unsigned int i;
+	
+
+
+	for (i = 0; i < count; i ++) {
+             /*
+		R = *src++;
+		G = *src++;
+		B = *src++;
+	     */
+		B = *src++;
+		G = *src++;
+		R = *src++;
+	      
+		R = R << 8;
+		G = G << 8;
+		B = B << 8;
+
+		acc = R * RC;
+		acc += G * GC;
+		acc += B * BC;
+
+		acc = acc >> 16;
+
+		*dst++ = acc;
+	}
+}
+
+
Binary files c6accel_1_00_00_04_async0/dsp/libs/cxcore.lib and c6accel_1_00_00_04_async/dsp/libs/cxcore.lib differ
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/include/cvver.h c6accel_1_00_00_04_async/dsp/libs/include/cvver.h
--- c6accel_1_00_00_04_async0/dsp/libs/include/cvver.h	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/libs/include/cvver.h	2010-08-11 13:57:58.000000000 -0500
@@ -0,0 +1,55 @@
+/*M///////////////////////////////////////////////////////////////////////////////////////
+//
+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
+//
+//  By downloading, copying, installing or using the software you agree to this license.
+//  If you do not agree to this license, do not download, install,
+//  copy or use the software.
+//
+//
+//                        Intel License Agreement
+//                For Open Source Computer Vision Library
+//
+// Copyright( C) 2000, Intel Corporation, all rights reserved.
+// Third party copyrights are property of their respective owners.
+//
+// Redistribution and use in source and binary forms, with or without modification,
+// are permitted provided that the following conditions are met:
+//
+//   * Redistribution's of source code must retain the above copyright notice,
+//     this list of conditions and the following disclaimer.
+//
+//   * Redistribution's in binary form must reproduce the above copyright notice,
+//     this list of conditions and the following disclaimer in the documentation
+//     and/or other materials provided with the distribution.
+//
+//   * The name of Intel Corporation may not be used to endorse or promote products
+//     derived from this software without specific prior written permission.
+//
+// This software is provided by the copyright holders and contributors "as is" and
+// any express or implied warranties, including, but not limited to, the implied
+// warranties of merchantability and fitness for a particular purpose are disclaimed.
+// In no event shall the Intel Corporation or contributors be liable for any direct,
+// indirect, incidental, special, exemplary, or consequential damages
+//(including, but not limited to, procurement of substitute goods or services;
+// loss of use, data, or profits; or business interruption) however caused
+// and on any theory of liability, whether in contract, strict liability,
+// or tort(including negligence or otherwise) arising in any way out of
+// the use of this software, even if advised of the possibility of such damage.
+//
+//M*/
+
+/*
+  definition of the current version of OpenCV
+  Usefull to test in user programs
+*/
+
+#ifndef _CVVERSION_H_
+#define _CVVERSION_H_
+
+#define CV_MAJOR_VERSION    1
+#define CV_MINOR_VERSION    0
+#define CV_SUBMINOR_VERSION 0
+#define CV_VERSION          "1.0.0"
+
+#endif /*_CVVERSION_H_*/
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/include/cxtypes.h c6accel_1_00_00_04_async/dsp/libs/include/cxtypes.h
--- c6accel_1_00_00_04_async0/dsp/libs/include/cxtypes.h	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/libs/include/cxtypes.h	2010-08-11 13:57:58.000000000 -0500
@@ -0,0 +1,1771 @@
+/*M///////////////////////////////////////////////////////////////////////////////////////
+//
+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
+//
+//  By downloading, copying, installing or using the software you agree to this license.
+//  If you do not agree to this license, do not download, install,
+//  copy or use the software.
+//
+//
+//                        Intel License Agreement
+//                For Open Source Computer Vision Library
+//
+// Copyright (C) 2000, Intel Corporation, all rights reserved.
+// Third party copyrights are property of their respective owners.
+//
+// Redistribution and use in source and binary forms, with or without modification,
+// are permitted provided that the following conditions are met:
+//
+//   * Redistribution's of source code must retain the above copyright notice,
+//     this list of conditions and the following disclaimer.
+//
+//   * Redistribution's in binary form must reproduce the above copyright notice,
+//     this list of conditions and the following disclaimer in the documentation
+//     and/or other materials provided with the distribution.
+//
+//   * The name of Intel Corporation may not be used to endorse or promote products
+//     derived from this software without specific prior written permission.
+//
+// This software is provided by the copyright holders and contributors "as is" and
+// any express or implied warranties, including, but not limited to, the implied
+// warranties of merchantability and fitness for a particular purpose are disclaimed.
+// In no event shall the Intel Corporation or contributors be liable for any direct,
+// indirect, incidental, special, exemplary, or consequential damages
+// (including, but not limited to, procurement of substitute goods or services;
+// loss of use, data, or profits; or business interruption) however caused
+// and on any theory of liability, whether in contract, strict liability,
+// or tort (including negligence or otherwise) arising in any way out of
+// the use of this software, even if advised of the possibility of such damage.
+//
+//M*/
+
+#ifndef _CXCORE_TYPES_H_
+#define _CXCORE_TYPES_H_
+
+#if !defined _CRT_SECURE_NO_DEPRECATE && _MSC_VER > 1300
+#define _CRT_SECURE_NO_DEPRECATE /* to avoid multiple Visual Studio 2005 warnings */
+#endif
+
+#ifndef SKIP_INCLUDES
+  #include <assert.h>
+  #include <stdlib.h>
+  #include <string.h>
+  #include <float.h>
+
+  #if defined __ICL
+    #define CV_ICC   __ICL
+  #elif defined __ICC
+    #define CV_ICC   __ICC
+  #elif defined __ECL
+    #define CV_ICC   __ECL
+  #elif defined __ECC
+    #define CV_ICC   __ECC
+  #endif
+
+  #if defined WIN64 && defined EM64T && (defined _MSC_VER || defined CV_ICC) \
+      || defined __SSE2__ || defined _MM_SHUFFLE2
+    #include <emmintrin.h>
+    #define CV_SSE2 1
+  #else
+    #define CV_SSE2 0
+  #endif
+
+  #if defined __BORLANDC__
+    #include <fastmath.h>
+  #elif defined WIN64 && !defined EM64T && defined CV_ICC
+    #include <mathimf.h>
+  #else
+    #include <math.h>
+  #endif
+
+  #ifdef HAVE_IPL
+      #ifndef __IPL_H__
+          #if defined WIN32 || defined WIN64
+              #include <ipl.h>
+          #else
+              #include <ipl/ipl.h>
+          #endif
+      #endif
+  #elif defined __IPL_H__
+      #define HAVE_IPL
+  #endif
+#endif // SKIP_INCLUDES
+
+#if defined WIN32 || defined WIN64
+    #define CV_CDECL __cdecl
+    #define CV_STDCALL __stdcall
+#else
+    #define CV_CDECL
+    #define CV_STDCALL
+#endif
+
+#ifndef CV_EXTERN_C
+    #ifdef __cplusplus
+        #define CV_EXTERN_C extern "C"
+        #define CV_DEFAULT(val) = val
+    #else
+        #define CV_EXTERN_C
+        #define CV_DEFAULT(val)
+    #endif
+#endif
+
+#ifndef CV_EXTERN_C_FUNCPTR
+    #ifdef __cplusplus
+        #define CV_EXTERN_C_FUNCPTR(x) extern "C" { typedef x; }
+    #else
+        #define CV_EXTERN_C_FUNCPTR(x) typedef x
+    #endif
+#endif
+
+#ifndef CV_INLINE
+#if defined __cplusplus
+    #define CV_INLINE inline
+#elif (defined WIN32 || defined WIN64) && !defined __GNUC__
+    #define CV_INLINE __inline
+#else
+    #define CV_INLINE static
+#endif
+#endif /* CV_INLINE */
+
+#if (defined WIN32 || defined WIN64) && defined CVAPI_EXPORTS
+    #define CV_EXPORTS __declspec(dllexport)
+#else
+    #define CV_EXPORTS
+#endif
+
+#ifndef CVAPI
+    #define CVAPI(rettype) CV_EXTERN_C CV_EXPORTS rettype CV_CDECL
+#endif
+
+#if defined _MSC_VER || defined __BORLANDC__
+typedef __int64 int64;
+typedef unsigned __int64 uint64;
+#else
+typedef long long int64;
+typedef unsigned long long uint64;
+#endif
+
+#ifndef HAVE_IPL
+typedef unsigned char uchar;
+typedef unsigned short ushort;
+#endif
+
+/* CvArr* is used to pass arbitrary array-like data structures
+   into the functions where the particular
+   array type is recognized at runtime */
+typedef void CvArr;
+
+typedef union Cv32suf
+{
+    int i;
+    unsigned u;
+    float f;
+}
+Cv32suf;
+
+typedef union Cv64suf
+{
+    int64 i;
+    uint64 u;
+    double f;
+}
+Cv64suf;
+
+/****************************************************************************************\
+*                             Common macros and inline functions                         *
+\****************************************************************************************/
+
+#define CV_PI   3.1415926535897932384626433832795
+#define CV_LOG2 0.69314718055994530941723212145818
+
+#define CV_SWAP(a,b,t) ((t) = (a), (a) = (b), (b) = (t))
+
+#ifndef MIN
+#define MIN(a,b)  ((a) > (b) ? (b) : (a))
+#endif
+
+#ifndef MAX
+#define MAX(a,b)  ((a) < (b) ? (b) : (a))
+#endif
+
+/* min & max without jumps */
+#define  CV_IMIN(a, b)  ((a) ^ (((a)^(b)) & (((a) < (b)) - 1)))
+
+#define  CV_IMAX(a, b)  ((a) ^ (((a)^(b)) & (((a) > (b)) - 1)))
+
+/* absolute value without jumps */
+#ifndef __cplusplus
+#define  CV_IABS(a)     (((a) ^ ((a) < 0 ? -1 : 0)) - ((a) < 0 ? -1 : 0))
+#else
+#define  CV_IABS(a)     abs(a)
+#endif
+#define  CV_CMP(a,b)    (((a) > (b)) - ((a) < (b)))
+#define  CV_SIGN(a)     CV_CMP((a),0)
+
+CV_INLINE  int  cvRound( double value )
+{
+#if CV_SSE2
+    __m128d t = _mm_load_sd( &value );
+    return _mm_cvtsd_si32(t);
+#elif defined WIN32 && !defined WIN64 && defined _MSC_VER
+    int t;
+    __asm
+    {
+        fld value;
+        fistp t;
+    }
+    return t;
+#elif (defined HAVE_LRINT) || (defined WIN64 && !defined EM64T && defined CV_ICC)
+    return (int)lrint(value);
+#else
+    /*
+     the algorithm was taken from Agner Fog's optimization guide
+     at http://www.agner.org/assem
+     */
+    Cv64suf temp;
+    temp.f = value + 6755399441055744.0;
+    return (int)temp.u;
+#endif
+}
+
+
+CV_INLINE  int  cvFloor( double value )
+{
+#if CV_SSE2
+    __m128d t = _mm_load_sd( &value );
+    int i = _mm_cvtsd_si32(t);
+    return i - _mm_movemask_pd(_mm_cmplt_sd(t,_mm_cvtsi32_sd(t,i)));
+#else
+    int temp = cvRound(value);
+    Cv32suf diff;
+    diff.f = (float)(value - temp);
+    return temp - (diff.i < 0);
+#endif
+}
+
+
+CV_INLINE  int  cvCeil( double value )
+{
+#if CV_SSE2
+    __m128d t = _mm_load_sd( &value );
+    int i = _mm_cvtsd_si32(t);
+    return i + _mm_movemask_pd(_mm_cmplt_sd(_mm_cvtsi32_sd(t,i),t));
+#else
+    int temp = cvRound(value);
+    Cv32suf diff;
+    diff.f = (float)(temp - value);
+    return temp + (diff.i < 0);
+#endif
+}
+
+#define cvInvSqrt(value) ((float)(1./sqrt(value)))
+#define cvSqrt(value)  ((float)sqrt(value))
+
+CV_INLINE int cvIsNaN( double value )
+{
+#if 1/*defined _MSC_VER || defined __BORLANDC__
+    return _isnan(value);
+#elif defined __GNUC__
+    return isnan(value);
+#else*/
+    Cv64suf ieee754;
+    ieee754.f = value;
+    return ((unsigned)(ieee754.u >> 32) & 0x7fffffff) +
+           ((unsigned)ieee754.u != 0) > 0x7ff00000;
+#endif
+}
+
+
+CV_INLINE int cvIsInf( double value )
+{
+#if 1/*defined _MSC_VER || defined __BORLANDC__
+    return !_finite(value);
+#elif defined __GNUC__
+    return isinf(value);
+#else*/
+    Cv64suf ieee754;
+    ieee754.f = value;
+    return ((unsigned)(ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&
+           (unsigned)ieee754.u == 0;
+#endif
+}
+
+
+/*************** Random number generation *******************/
+
+typedef uint64 CvRNG;
+
+CV_INLINE CvRNG cvRNG( int64 seed CV_DEFAULT(-1))
+{
+    CvRNG rng = seed ? (uint64)seed : (uint64)(int64)-1;
+    return rng;
+}
+
+/* returns random 32-bit unsigned integer */
+CV_INLINE unsigned cvRandInt( CvRNG* rng )
+{
+    uint64 temp = *rng;
+    temp = (uint64)(unsigned)temp*1554115554 + (temp >> 32);
+    *rng = temp;
+    return (unsigned)temp;
+}
+
+/* returns random floating-point number between 0 and 1 */
+CV_INLINE double cvRandReal( CvRNG* rng )
+{
+    return cvRandInt(rng)*2.3283064365386962890625e-10 /* 2^-32 */;
+}
+
+/****************************************************************************************\
+*                                  Image type (IplImage)                                 *
+\****************************************************************************************/
+
+#ifndef HAVE_IPL
+
+/*
+ * The following definitions (until #endif)
+ * is an extract from IPL headers.
+ * Copyright (c) 1995 Intel Corporation.
+ */
+#define IPL_DEPTH_SIGN 0x80000000
+
+#define IPL_DEPTH_1U     1
+#define IPL_DEPTH_8U     8
+#define IPL_DEPTH_16U   16
+#define IPL_DEPTH_32F   32
+
+#define IPL_DEPTH_8S  (IPL_DEPTH_SIGN| 8)
+#define IPL_DEPTH_16S (IPL_DEPTH_SIGN|16)
+#define IPL_DEPTH_32S (IPL_DEPTH_SIGN|32)
+
+#define IPL_DATA_ORDER_PIXEL  0
+#define IPL_DATA_ORDER_PLANE  1
+
+#define IPL_ORIGIN_TL 0
+#define IPL_ORIGIN_BL 1
+
+#define IPL_ALIGN_4BYTES   4
+#define IPL_ALIGN_8BYTES   8
+#define IPL_ALIGN_16BYTES 16
+#define IPL_ALIGN_32BYTES 32
+
+#define IPL_ALIGN_DWORD   IPL_ALIGN_4BYTES
+#define IPL_ALIGN_QWORD   IPL_ALIGN_8BYTES
+
+#define IPL_BORDER_CONSTANT   0
+#define IPL_BORDER_REPLICATE  1
+#define IPL_BORDER_REFLECT    2
+#define IPL_BORDER_WRAP       3
+
+typedef struct _IplImage
+{
+    int  nSize;         /* sizeof(IplImage) */
+    int  ID;            /* version (=0)*/
+    int  nChannels;     /* Most of OpenCV functions support 1,2,3 or 4 channels */
+    int  alphaChannel;  /* ignored by OpenCV */
+    int  depth;         /* pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16S,
+                           IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported */
+    char colorModel[4]; /* ignored by OpenCV */
+    char channelSeq[4]; /* ditto */
+    int  dataOrder;     /* 0 - interleaved color channels, 1 - separate color channels.
+                           cvCreateImage can only create interleaved images */
+    int  origin;        /* 0 - top-left origin,
+                           1 - bottom-left origin (Windows bitmaps style) */
+    int  align;         /* Alignment of image rows (4 or 8).
+                           OpenCV ignores it and uses widthStep instead */
+    int  width;         /* image width in pixels */
+    int  height;        /* image height in pixels */
+    struct _IplROI *roi;/* image ROI. if NULL, the whole image is selected */
+    struct _IplImage *maskROI; /* must be NULL */
+    void  *imageId;     /* ditto */
+    struct _IplTileInfo *tileInfo; /* ditto */
+    int  imageSize;     /* image data size in bytes
+                           (==image->height*image->widthStep
+                           in case of interleaved data)*/
+    char *imageData;  /* pointer to aligned image data */
+    int  widthStep;   /* size of aligned image row in bytes */
+    int  BorderMode[4]; /* ignored by OpenCV */
+    int  BorderConst[4]; /* ditto */
+    char *imageDataOrigin; /* pointer to very origin of image data
+                              (not necessarily aligned) -
+                              needed for correct deallocation */
+}
+IplImage;
+
+typedef struct _IplTileInfo IplTileInfo;
+
+typedef struct _IplROI
+{
+    int  coi; /* 0 - no COI (all channels are selected), 1 - 0th channel is selected ...*/
+    int  xOffset;
+    int  yOffset;
+    int  width;
+    int  height;
+}
+IplROI;
+
+typedef struct _IplConvKernel
+{
+    int  nCols;
+    int  nRows;
+    int  anchorX;
+    int  anchorY;
+    int *values;
+    int  nShiftR;
+}
+IplConvKernel;
+
+typedef struct _IplConvKernelFP
+{
+    int  nCols;
+    int  nRows;
+    int  anchorX;
+    int  anchorY;
+    float *values;
+}
+IplConvKernelFP;
+
+#define IPL_IMAGE_HEADER 1
+#define IPL_IMAGE_DATA   2
+#define IPL_IMAGE_ROI    4
+
+#endif/*HAVE_IPL*/
+
+/* extra border mode */
+#define IPL_BORDER_REFLECT_101    4
+
+#define IPL_IMAGE_MAGIC_VAL  ((int)sizeof(IplImage))
+#define CV_TYPE_NAME_IMAGE "opencv-image"
+
+#define CV_IS_IMAGE_HDR(img) \
+    ((img) != NULL && ((const IplImage*)(img))->nSize == sizeof(IplImage))
+
+#define CV_IS_IMAGE(img) \
+    (CV_IS_IMAGE_HDR(img) && ((IplImage*)img)->imageData != NULL)
+
+/* for storing double-precision
+   floating point data in IplImage's */
+#define IPL_DEPTH_64F  64
+
+/* get reference to pixel at (col,row),
+   for multi-channel images (col) should be multiplied by number of channels */
+#define CV_IMAGE_ELEM( image, elemtype, row, col )       \
+    (((elemtype*)((image)->imageData + (image)->widthStep*(row)))[(col)])
+
+/****************************************************************************************\
+*                                  Matrix type (CvMat)                                   *
+\****************************************************************************************/
+
+#define CV_CN_MAX     64
+#define CV_CN_SHIFT   3
+#define CV_DEPTH_MAX  (1 << CV_CN_SHIFT)
+
+#define CV_8U   0
+#define CV_8S   1
+#define CV_16U  2
+#define CV_16S  3
+#define CV_32S  4
+#define CV_32F  5
+#define CV_64F  6
+#define CV_USRTYPE1 7
+
+#define CV_MAKETYPE(depth,cn) ((depth) + (((cn)-1) << CV_CN_SHIFT))
+#define CV_MAKE_TYPE CV_MAKETYPE
+
+#define CV_8UC1 CV_MAKETYPE(CV_8U,1)
+#define CV_8UC2 CV_MAKETYPE(CV_8U,2)
+#define CV_8UC3 CV_MAKETYPE(CV_8U,3)
+#define CV_8UC4 CV_MAKETYPE(CV_8U,4)
+#define CV_8UC(n) CV_MAKETYPE(CV_8U,(n))
+
+#define CV_8SC1 CV_MAKETYPE(CV_8S,1)
+#define CV_8SC2 CV_MAKETYPE(CV_8S,2)
+#define CV_8SC3 CV_MAKETYPE(CV_8S,3)
+#define CV_8SC4 CV_MAKETYPE(CV_8S,4)
+#define CV_8SC(n) CV_MAKETYPE(CV_8S,(n))
+
+#define CV_16UC1 CV_MAKETYPE(CV_16U,1)
+#define CV_16UC2 CV_MAKETYPE(CV_16U,2)
+#define CV_16UC3 CV_MAKETYPE(CV_16U,3)
+#define CV_16UC4 CV_MAKETYPE(CV_16U,4)
+#define CV_16UC(n) CV_MAKETYPE(CV_16U,(n))
+
+#define CV_16SC1 CV_MAKETYPE(CV_16S,1)
+#define CV_16SC2 CV_MAKETYPE(CV_16S,2)
+#define CV_16SC3 CV_MAKETYPE(CV_16S,3)
+#define CV_16SC4 CV_MAKETYPE(CV_16S,4)
+#define CV_16SC(n) CV_MAKETYPE(CV_16S,(n))
+
+#define CV_32SC1 CV_MAKETYPE(CV_32S,1)
+#define CV_32SC2 CV_MAKETYPE(CV_32S,2)
+#define CV_32SC3 CV_MAKETYPE(CV_32S,3)
+#define CV_32SC4 CV_MAKETYPE(CV_32S,4)
+#define CV_32SC(n) CV_MAKETYPE(CV_32S,(n))
+
+#define CV_32FC1 CV_MAKETYPE(CV_32F,1)
+#define CV_32FC2 CV_MAKETYPE(CV_32F,2)
+#define CV_32FC3 CV_MAKETYPE(CV_32F,3)
+#define CV_32FC4 CV_MAKETYPE(CV_32F,4)
+#define CV_32FC(n) CV_MAKETYPE(CV_32F,(n))
+
+#define CV_64FC1 CV_MAKETYPE(CV_64F,1)
+#define CV_64FC2 CV_MAKETYPE(CV_64F,2)
+#define CV_64FC3 CV_MAKETYPE(CV_64F,3)
+#define CV_64FC4 CV_MAKETYPE(CV_64F,4)
+#define CV_64FC(n) CV_MAKETYPE(CV_64F,(n))
+
+#define CV_AUTO_STEP  0x7fffffff
+#define CV_WHOLE_ARR  cvSlice( 0, 0x3fffffff )
+
+#define CV_MAT_CN_MASK          ((CV_CN_MAX - 1) << CV_CN_SHIFT)
+#define CV_MAT_CN(flags)        ((((flags) & CV_MAT_CN_MASK) >> CV_CN_SHIFT) + 1)
+#define CV_MAT_DEPTH_MASK       (CV_DEPTH_MAX - 1)
+#define CV_MAT_DEPTH(flags)     ((flags) & CV_MAT_DEPTH_MASK)
+#define CV_MAT_TYPE_MASK        (CV_DEPTH_MAX*CV_CN_MAX - 1)
+#define CV_MAT_TYPE(flags)      ((flags) & CV_MAT_TYPE_MASK)
+#define CV_MAT_CONT_FLAG_SHIFT  14
+#define CV_MAT_CONT_FLAG        (1 << CV_MAT_CONT_FLAG_SHIFT)
+#define CV_IS_MAT_CONT(flags)   ((flags) & CV_MAT_CONT_FLAG)
+#define CV_IS_CONT_MAT          CV_IS_MAT_CONT
+#define CV_MAT_TEMP_FLAG_SHIFT  15
+#define CV_MAT_TEMP_FLAG        (1 << CV_MAT_TEMP_FLAG_SHIFT)
+#define CV_IS_TEMP_MAT(flags)   ((flags) & CV_MAT_TEMP_FLAG)
+
+#define CV_MAGIC_MASK       0xFFFF0000
+#define CV_MAT_MAGIC_VAL    0x42420000
+#define CV_TYPE_NAME_MAT    "opencv-matrix"
+
+typedef struct CvMat
+{
+    int type;
+    int step;
+
+    /* for internal use only */
+    int* refcount;
+    int hdr_refcount;
+
+    union
+    {
+        uchar* ptr;
+        short* s;
+        int* i;
+        float* fl;
+        double* db;
+    } data;
+
+#ifdef __cplusplus
+    union
+    {
+        int rows;
+        int height;
+    };
+
+    union
+    {
+        int cols;
+        int width;
+    };
+#else
+    int rows;
+    int cols;
+#endif
+
+}
+CvMat;
+
+
+#define CV_IS_MAT_HDR(mat) \
+    ((mat) != NULL && \
+    (((const CvMat*)(mat))->type & CV_MAGIC_MASK) == CV_MAT_MAGIC_VAL && \
+    ((const CvMat*)(mat))->cols > 0 && ((const CvMat*)(mat))->rows > 0)
+
+#define CV_IS_MAT(mat) \
+    (CV_IS_MAT_HDR(mat) && ((const CvMat*)(mat))->data.ptr != NULL)
+
+#define CV_IS_MASK_ARR(mat) \
+    (((mat)->type & (CV_MAT_TYPE_MASK & ~CV_8SC1)) == 0)
+
+#define CV_ARE_TYPES_EQ(mat1, mat2) \
+    ((((mat1)->type ^ (mat2)->type) & CV_MAT_TYPE_MASK) == 0)
+
+#define CV_ARE_CNS_EQ(mat1, mat2) \
+    ((((mat1)->type ^ (mat2)->type) & CV_MAT_CN_MASK) == 0)
+
+#define CV_ARE_DEPTHS_EQ(mat1, mat2) \
+    ((((mat1)->type ^ (mat2)->type) & CV_MAT_DEPTH_MASK) == 0)
+
+#define CV_ARE_SIZES_EQ(mat1, mat2) \
+    ((mat1)->height == (mat2)->height && (mat1)->width == (mat2)->width)
+
+#define CV_IS_MAT_CONST(mat)  \
+    (((mat)->height|(mat)->width) == 1)
+
+/* size of each channel item,
+   0x124489 = 1000 0100 0100 0010 0010 0001 0001 ~ array of sizeof(arr_type_elem) */
+#define CV_ELEM_SIZE1(type) \
+    ((((sizeof(size_t)<<28)|0x8442211) >> CV_MAT_DEPTH(type)*4) & 15)
+
+/* 0x3a50 = 11 10 10 01 01 00 00 ~ array of log2(sizeof(arr_type_elem)) */
+#define CV_ELEM_SIZE(type) \
+    (CV_MAT_CN(type) << ((((sizeof(size_t)/4+1)*16384|0x3a50) >> CV_MAT_DEPTH(type)*2) & 3))
+
+/* inline constructor. No data is allocated internally!!!
+   (use together with cvCreateData, or use cvCreateMat instead to
+   get a matrix with allocated data) */
+CV_INLINE CvMat cvMat( int rows, int cols, int type, void* data CV_DEFAULT(NULL))
+{
+    CvMat m;
+
+    assert( (unsigned)CV_MAT_DEPTH(type) <= CV_64F );
+    type = CV_MAT_TYPE(type);
+    m.type = CV_MAT_MAGIC_VAL | CV_MAT_CONT_FLAG | type;
+    m.cols = cols;
+    m.rows = rows;
+    m.step = rows > 1 ? m.cols*CV_ELEM_SIZE(type) : 0;
+    m.data.ptr = (uchar*)data;
+    m.refcount = NULL;
+    m.hdr_refcount = 0;
+
+    return m;
+}
+
+
+#define CV_MAT_ELEM_PTR_FAST( mat, row, col, pix_size )  \
+    (assert( (unsigned)(row) < (unsigned)(mat).rows &&   \
+             (unsigned)(col) < (unsigned)(mat).cols ),   \
+     (mat).data.ptr + (size_t)(mat).step*(row) + (pix_size)*(col))
+
+#define CV_MAT_ELEM_PTR( mat, row, col )                 \
+    CV_MAT_ELEM_PTR_FAST( mat, row, col, CV_ELEM_SIZE((mat).type) )
+
+#define CV_MAT_ELEM( mat, elemtype, row, col )           \
+    (*(elemtype*)CV_MAT_ELEM_PTR_FAST( mat, row, col, sizeof(elemtype)))
+
+
+CV_INLINE  double  cvmGet( const CvMat* mat, int row, int col )
+{
+    int type;
+
+    type = CV_MAT_TYPE(mat->type);
+    assert( (unsigned)row < (unsigned)mat->rows &&
+            (unsigned)col < (unsigned)mat->cols );
+
+    if( type == CV_32FC1 )
+        return ((float*)(mat->data.ptr + (size_t)mat->step*row))[col];
+    else
+    {
+        assert( type == CV_64FC1 );
+        return ((double*)(mat->data.ptr + (size_t)mat->step*row))[col];
+    }
+}
+
+
+CV_INLINE  void  cvmSet( CvMat* mat, int row, int col, double value )
+{
+    int type;
+    type = CV_MAT_TYPE(mat->type);
+    assert( (unsigned)row < (unsigned)mat->rows &&
+            (unsigned)col < (unsigned)mat->cols );
+
+    if( type == CV_32FC1 )
+        ((float*)(mat->data.ptr + (size_t)mat->step*row))[col] = (float)value;
+    else
+    {
+        assert( type == CV_64FC1 );
+        ((double*)(mat->data.ptr + (size_t)mat->step*row))[col] = (double)value;
+    }
+}
+
+
+CV_INLINE int cvCvToIplDepth( int type )
+{
+    int depth = CV_MAT_DEPTH(type);
+    return CV_ELEM_SIZE1(depth)*8 | (depth == CV_8S || depth == CV_16S ||
+           depth == CV_32S ? IPL_DEPTH_SIGN : 0);
+}
+
+
+/****************************************************************************************\
+*                       Multi-dimensional dense array (CvMatND)                          *
+\****************************************************************************************/
+
+#define CV_MATND_MAGIC_VAL    0x42430000
+#define CV_TYPE_NAME_MATND    "opencv-nd-matrix"
+
+#define CV_MAX_DIM            32
+#define CV_MAX_DIM_HEAP       (1 << 16)
+
+typedef struct CvMatND
+{
+    int type;
+    int dims;
+
+    int* refcount;
+    int hdr_refcount;
+
+    union
+    {
+        uchar* ptr;
+        float* fl;
+        double* db;
+        int* i;
+        short* s;
+    } data;
+
+    struct
+    {
+        int size;
+        int step;
+    }
+    dim[CV_MAX_DIM];
+}
+CvMatND;
+
+#define CV_IS_MATND_HDR(mat) \
+    ((mat) != NULL && (((const CvMatND*)(mat))->type & CV_MAGIC_MASK) == CV_MATND_MAGIC_VAL)
+
+#define CV_IS_MATND(mat) \
+    (CV_IS_MATND_HDR(mat) && ((const CvMatND*)(mat))->data.ptr != NULL)
+
+
+/****************************************************************************************\
+*                      Multi-dimensional sparse array (CvSparseMat)                      *
+\****************************************************************************************/
+
+#define CV_SPARSE_MAT_MAGIC_VAL    0x42440000
+#define CV_TYPE_NAME_SPARSE_MAT    "opencv-sparse-matrix"
+
+struct CvSet;
+
+typedef struct CvSparseMat
+{
+    int type;
+    int dims;
+    int* refcount;
+    int hdr_refcount;
+
+    struct CvSet* heap;
+    void** hashtable;
+    int hashsize;
+    int valoffset;
+    int idxoffset;
+    int size[CV_MAX_DIM];
+}
+CvSparseMat;
+
+#define CV_IS_SPARSE_MAT_HDR(mat) \
+    ((mat) != NULL && \
+    (((const CvSparseMat*)(mat))->type & CV_MAGIC_MASK) == CV_SPARSE_MAT_MAGIC_VAL)
+
+#define CV_IS_SPARSE_MAT(mat) \
+    CV_IS_SPARSE_MAT_HDR(mat)
+
+/**************** iteration through a sparse array *****************/
+
+typedef struct CvSparseNode
+{
+    unsigned hashval;
+    struct CvSparseNode* next;
+}
+CvSparseNode;
+
+typedef struct CvSparseMatIterator
+{
+    CvSparseMat* mat;
+    CvSparseNode* node;
+    int curidx;
+}
+CvSparseMatIterator;
+
+#define CV_NODE_VAL(mat,node)   ((void*)((uchar*)(node) + (mat)->valoffset))
+#define CV_NODE_IDX(mat,node)   ((int*)((uchar*)(node) + (mat)->idxoffset))
+
+/****************************************************************************************\
+*                                         Histogram                                      *
+\****************************************************************************************/
+
+typedef int CvHistType;
+
+#define CV_HIST_MAGIC_VAL     0x42450000
+#define CV_HIST_UNIFORM_FLAG  (1 << 10)
+
+/* indicates whether bin ranges are set already or not */
+#define CV_HIST_RANGES_FLAG   (1 << 11)
+
+#define CV_HIST_ARRAY         0
+#define CV_HIST_SPARSE        1
+#define CV_HIST_TREE          CV_HIST_SPARSE
+
+/* should be used as a parameter only,
+   it turns to CV_HIST_UNIFORM_FLAG of hist->type */
+#define CV_HIST_UNIFORM       1
+
+typedef struct CvHistogram
+{
+    int     type;
+    CvArr*  bins;
+    float   thresh[CV_MAX_DIM][2]; /* for uniform histograms */
+    float** thresh2; /* for non-uniform histograms */
+    CvMatND mat; /* embedded matrix header for array histograms */
+}
+CvHistogram;
+
+#define CV_IS_HIST( hist ) \
+    ((hist) != NULL  && \
+     (((CvHistogram*)(hist))->type & CV_MAGIC_MASK) == CV_HIST_MAGIC_VAL && \
+     (hist)->bins != NULL)
+
+#define CV_IS_UNIFORM_HIST( hist ) \
+    (((hist)->type & CV_HIST_UNIFORM_FLAG) != 0)
+
+#define CV_IS_SPARSE_HIST( hist ) \
+    CV_IS_SPARSE_MAT((hist)->bins)
+
+#define CV_HIST_HAS_RANGES( hist ) \
+    (((hist)->type & CV_HIST_RANGES_FLAG) != 0)
+
+/****************************************************************************************\
+*                      Other supplementary data type definitions                         *
+\****************************************************************************************/
+
+/*************************************** CvRect *****************************************/
+
+typedef struct CvRect
+{
+    int x;
+    int y;
+    int width;
+    int height;
+}
+CvRect;
+
+CV_INLINE  CvRect  cvRect( int x, int y, int width, int height )
+{
+    CvRect r;
+
+    r.x = x;
+    r.y = y;
+    r.width = width;
+    r.height = height;
+
+    return r;
+}
+
+
+CV_INLINE  IplROI  cvRectToROI( CvRect rect, int coi )
+{
+    IplROI roi;
+    roi.xOffset = rect.x;
+    roi.yOffset = rect.y;
+    roi.width = rect.width;
+    roi.height = rect.height;
+    roi.coi = coi;
+
+    return roi;
+}
+
+
+CV_INLINE  CvRect  cvROIToRect( IplROI roi )
+{
+    return cvRect( roi.xOffset, roi.yOffset, roi.width, roi.height );
+}
+
+/*********************************** CvTermCriteria *************************************/
+
+#define CV_TERMCRIT_ITER    1
+#define CV_TERMCRIT_NUMBER  CV_TERMCRIT_ITER
+#define CV_TERMCRIT_EPS     2
+
+typedef struct CvTermCriteria
+{
+    int    type;  /* may be combination of
+                     CV_TERMCRIT_ITER
+                     CV_TERMCRIT_EPS */
+    int    max_iter;
+    double epsilon;
+}
+CvTermCriteria;
+
+CV_INLINE  CvTermCriteria  cvTermCriteria( int type, int max_iter, double epsilon )
+{
+    CvTermCriteria t;
+
+    t.type = type;
+    t.max_iter = max_iter;
+    t.epsilon = (float)epsilon;
+
+    return t;
+}
+
+
+/******************************* CvPoint and variants ***********************************/
+
+typedef struct CvPoint
+{
+    int x;
+    int y;
+}
+CvPoint;
+
+
+CV_INLINE  CvPoint  cvPoint( int x, int y )
+{
+    CvPoint p;
+
+    p.x = x;
+    p.y = y;
+
+    return p;
+}
+
+
+typedef struct CvPoint2D32f
+{
+    float x;
+    float y;
+}
+CvPoint2D32f;
+
+
+CV_INLINE  CvPoint2D32f  cvPoint2D32f( double x, double y )
+{
+    CvPoint2D32f p;
+
+    p.x = (float)x;
+    p.y = (float)y;
+
+    return p;
+}
+
+
+CV_INLINE  CvPoint2D32f  cvPointTo32f( CvPoint point )
+{
+    return cvPoint2D32f( (float)point.x, (float)point.y );
+}
+
+
+CV_INLINE  CvPoint  cvPointFrom32f( CvPoint2D32f point )
+{
+    CvPoint ipt;
+    ipt.x = cvRound(point.x);
+    ipt.y = cvRound(point.y);
+
+    return ipt;
+}
+
+
+typedef struct CvPoint3D32f
+{
+    float x;
+    float y;
+    float z;
+}
+CvPoint3D32f;
+
+
+CV_INLINE  CvPoint3D32f  cvPoint3D32f( double x, double y, double z )
+{
+    CvPoint3D32f p;
+
+    p.x = (float)x;
+    p.y = (float)y;
+    p.z = (float)z;
+
+    return p;
+}
+
+
+typedef struct CvPoint2D64f
+{
+    double x;
+    double y;
+}
+CvPoint2D64f;
+
+
+CV_INLINE  CvPoint2D64f  cvPoint2D64f( double x, double y )
+{
+    CvPoint2D64f p;
+
+    p.x = x;
+    p.y = y;
+
+    return p;
+}
+
+
+typedef struct CvPoint3D64f
+{
+    double x;
+    double y;
+    double z;
+}
+CvPoint3D64f;
+
+
+CV_INLINE  CvPoint3D64f  cvPoint3D64f( double x, double y, double z )
+{
+    CvPoint3D64f p;
+
+    p.x = x;
+    p.y = y;
+    p.z = z;
+
+    return p;
+}
+
+
+/******************************** CvSize's & CvBox **************************************/
+
+typedef struct
+{
+    int width;
+    int height;
+}
+CvSize;
+
+CV_INLINE  CvSize  cvSize( int width, int height )
+{
+    CvSize s;
+
+    s.width = width;
+    s.height = height;
+
+    return s;
+}
+
+typedef struct CvSize2D32f
+{
+    float width;
+    float height;
+}
+CvSize2D32f;
+
+
+CV_INLINE  CvSize2D32f  cvSize2D32f( double width, double height )
+{
+    CvSize2D32f s;
+
+    s.width = (float)width;
+    s.height = (float)height;
+
+    return s;
+}
+
+typedef struct CvBox2D
+{
+    CvPoint2D32f center;  /* center of the box */
+    CvSize2D32f  size;    /* box width and length */
+    float angle;          /* angle between the horizontal axis
+                             and the first side (i.e. length) in degrees */
+}
+CvBox2D;
+
+
+/* Line iterator state */
+typedef struct CvLineIterator
+{
+    /* pointer to the current point */
+    uchar* ptr;
+
+    /* Bresenham algorithm state */
+    int  err;
+    int  plus_delta;
+    int  minus_delta;
+    int  plus_step;
+    int  minus_step;
+}
+CvLineIterator;
+
+
+
+/************************************* CvSlice ******************************************/
+
+typedef struct CvSlice
+{
+    int  start_index, end_index;
+}
+CvSlice;
+
+CV_INLINE  CvSlice  cvSlice( int start, int end )
+{
+    CvSlice slice;
+    slice.start_index = start;
+    slice.end_index = end;
+
+    return slice;
+}
+
+#define CV_WHOLE_SEQ_END_INDEX 0x3fffffff
+#define CV_WHOLE_SEQ  cvSlice(0, CV_WHOLE_SEQ_END_INDEX)
+
+
+/************************************* CvScalar *****************************************/
+
+typedef struct CvScalar
+{
+    double val[4];
+}
+CvScalar;
+
+CV_INLINE  CvScalar  cvScalar( double val0, double val1 CV_DEFAULT(0),
+                               double val2 CV_DEFAULT(0), double val3 CV_DEFAULT(0))
+{
+    CvScalar scalar;
+    scalar.val[0] = val0; scalar.val[1] = val1;
+    scalar.val[2] = val2; scalar.val[3] = val3;
+    return scalar;
+}
+
+
+CV_INLINE  CvScalar  cvRealScalar( double val0 )
+{
+    CvScalar scalar;
+    scalar.val[0] = val0;
+    scalar.val[1] = scalar.val[2] = scalar.val[3] = 0;
+    return scalar;
+}
+
+CV_INLINE  CvScalar  cvScalarAll( double val0123 )
+{
+    CvScalar scalar;
+    scalar.val[0] = val0123;
+    scalar.val[1] = val0123;
+    scalar.val[2] = val0123;
+    scalar.val[3] = val0123;
+    return scalar;
+}
+
+/****************************************************************************************\
+*                                   Dynamic Data structures                              *
+\****************************************************************************************/
+
+/******************************** Memory storage ****************************************/
+
+typedef struct CvMemBlock
+{
+    struct CvMemBlock*  prev;
+    struct CvMemBlock*  next;
+}
+CvMemBlock;
+
+#define CV_STORAGE_MAGIC_VAL    0x42890000
+
+typedef struct CvMemStorage
+{
+    int signature;
+    CvMemBlock* bottom;/* first allocated block */
+    CvMemBlock* top;   /* current memory block - top of the stack */
+    struct  CvMemStorage* parent; /* borrows new blocks from */
+    int block_size;  /* block size */
+    int free_space;  /* free space in the current block */
+}
+CvMemStorage;
+
+#define CV_IS_STORAGE(storage)  \
+    ((storage) != NULL &&       \
+    (((CvMemStorage*)(storage))->signature & CV_MAGIC_MASK) == CV_STORAGE_MAGIC_VAL)
+
+
+typedef struct CvMemStoragePos
+{
+    CvMemBlock* top;
+    int free_space;
+}
+CvMemStoragePos;
+
+
+/*********************************** Sequence *******************************************/
+
+typedef struct CvSeqBlock
+{
+    struct CvSeqBlock*  prev; /* previous sequence block */
+    struct CvSeqBlock*  next; /* next sequence block */
+    int    start_index;       /* index of the first element in the block +
+                                 sequence->first->start_index */
+    int    count;             /* number of elements in the block */
+    char*  data;              /* pointer to the first element of the block */
+}
+CvSeqBlock;
+
+
+#define CV_TREE_NODE_FIELDS(node_type)                          \
+    int       flags;         /* micsellaneous flags */          \
+    int       header_size;   /* size of sequence header */      \
+    struct    node_type* h_prev; /* previous sequence */        \
+    struct    node_type* h_next; /* next sequence */            \
+    struct    node_type* v_prev; /* 2nd previous sequence */    \
+    struct    node_type* v_next  /* 2nd next sequence */
+
+/*
+   Read/Write sequence.
+   Elements can be dynamically inserted to or deleted from the sequence.
+*/
+#define CV_SEQUENCE_FIELDS()                                            \
+    CV_TREE_NODE_FIELDS(CvSeq);                                         \
+    int       total;          /* total number of elements */            \
+    int       elem_size;      /* size of sequence element in bytes */   \
+    char*     block_max;      /* maximal bound of the last block */     \
+    char*     ptr;            /* current write pointer */               \
+    int       delta_elems;    /* how many elements allocated when the seq grows */  \
+    CvMemStorage* storage;    /* where the seq is stored */             \
+    CvSeqBlock* free_blocks;  /* free blocks list */                    \
+    CvSeqBlock* first; /* pointer to the first sequence block */
+
+typedef struct CvSeq
+{
+    CV_SEQUENCE_FIELDS()
+}
+CvSeq;
+
+#define CV_TYPE_NAME_SEQ             "opencv-sequence"
+#define CV_TYPE_NAME_SEQ_TREE        "opencv-sequence-tree"
+
+/*************************************** Set ********************************************/
+/*
+  Set.
+  Order is not preserved. There can be gaps between sequence elements.
+  After the element has been inserted it stays in the same place all the time.
+  The MSB(most-significant or sign bit) of the first field (flags) is 0 iff the element exists.
+*/
+#define CV_SET_ELEM_FIELDS(elem_type)   \
+    int  flags;                         \
+    struct elem_type* next_free;
+
+typedef struct CvSetElem
+{
+    CV_SET_ELEM_FIELDS(CvSetElem)
+}
+CvSetElem;
+
+#define CV_SET_FIELDS()      \
+    CV_SEQUENCE_FIELDS()     \
+    CvSetElem* free_elems;   \
+    int active_count;
+
+typedef struct CvSet
+{
+    CV_SET_FIELDS()
+}
+CvSet;
+
+
+#define CV_SET_ELEM_IDX_MASK   ((1 << 26) - 1)
+#define CV_SET_ELEM_FREE_FLAG  (1 << (sizeof(int)*8-1))
+
+/* Checks whether the element pointed by ptr belongs to a set or not */
+#define CV_IS_SET_ELEM( ptr )  (((CvSetElem*)(ptr))->flags >= 0)
+
+/************************************* Graph ********************************************/
+
+/*
+  Graph is represented as a set of vertices.
+  Vertices contain their adjacency lists (more exactly, pointers to first incoming or
+  outcoming edge (or 0 if isolated vertex)). Edges are stored in another set.
+  There is a single-linked list of incoming/outcoming edges for each vertex.
+
+  Each edge consists of:
+    two pointers to the starting and the ending vertices (vtx[0] and vtx[1],
+    respectively). Graph may be oriented or not. In the second case, edges between
+    vertex i to vertex j are not distingueshed (during the search operations).
+
+    two pointers to next edges for the starting and the ending vertices.
+    next[0] points to the next edge in the vtx[0] adjacency list and
+    next[1] points to the next edge in the vtx[1] adjacency list.
+*/
+#define CV_GRAPH_EDGE_FIELDS()      \
+    int flags;                      \
+    float weight;                   \
+    struct CvGraphEdge* next[2];    \
+    struct CvGraphVtx* vtx[2];
+
+
+#define CV_GRAPH_VERTEX_FIELDS()    \
+    int flags;                      \
+    struct CvGraphEdge* first;
+
+
+typedef struct CvGraphEdge
+{
+    CV_GRAPH_EDGE_FIELDS()
+}
+CvGraphEdge;
+
+typedef struct CvGraphVtx
+{
+    CV_GRAPH_VERTEX_FIELDS()
+}
+CvGraphVtx;
+
+typedef struct CvGraphVtx2D
+{
+    CV_GRAPH_VERTEX_FIELDS()
+    CvPoint2D32f* ptr;
+}
+CvGraphVtx2D;
+
+/*
+   Graph is "derived" from the set (this is set a of vertices)
+   and includes another set (edges)
+*/
+#define  CV_GRAPH_FIELDS()   \
+    CV_SET_FIELDS()          \
+    CvSet* edges;
+
+typedef struct CvGraph
+{
+    CV_GRAPH_FIELDS()
+}
+CvGraph;
+
+#define CV_TYPE_NAME_GRAPH "opencv-graph"
+
+/*********************************** Chain/Countour *************************************/
+
+typedef struct CvChain
+{
+    CV_SEQUENCE_FIELDS()
+    CvPoint  origin;
+}
+CvChain;
+
+#define CV_CONTOUR_FIELDS()  \
+    CV_SEQUENCE_FIELDS()     \
+    CvRect rect;             \
+    int color;               \
+    int reserved[3];
+
+typedef struct CvContour
+{
+    CV_CONTOUR_FIELDS()
+}
+CvContour;
+
+typedef CvContour CvPoint2DSeq;
+
+/****************************************************************************************\
+*                                    Sequence types                                      *
+\****************************************************************************************/
+
+#define CV_SEQ_MAGIC_VAL             0x42990000
+
+#define CV_IS_SEQ(seq) \
+    ((seq) != NULL && (((CvSeq*)(seq))->flags & CV_MAGIC_MASK) == CV_SEQ_MAGIC_VAL)
+
+#define CV_SET_MAGIC_VAL             0x42980000
+#define CV_IS_SET(set) \
+    ((set) != NULL && (((CvSeq*)(set))->flags & CV_MAGIC_MASK) == CV_SET_MAGIC_VAL)
+
+#define CV_SEQ_ELTYPE_BITS           9
+#define CV_SEQ_ELTYPE_MASK           ((1 << CV_SEQ_ELTYPE_BITS) - 1)
+
+#define CV_SEQ_ELTYPE_POINT          CV_32SC2  /* (x,y) */
+#define CV_SEQ_ELTYPE_CODE           CV_8UC1   /* freeman code: 0..7 */
+#define CV_SEQ_ELTYPE_GENERIC        0
+#define CV_SEQ_ELTYPE_PTR            CV_USRTYPE1
+#define CV_SEQ_ELTYPE_PPOINT         CV_SEQ_ELTYPE_PTR  /* &(x,y) */
+#define CV_SEQ_ELTYPE_INDEX          CV_32SC1  /* #(x,y) */
+#define CV_SEQ_ELTYPE_GRAPH_EDGE     0  /* &next_o, &next_d, &vtx_o, &vtx_d */
+#define CV_SEQ_ELTYPE_GRAPH_VERTEX   0  /* first_edge, &(x,y) */
+#define CV_SEQ_ELTYPE_TRIAN_ATR      0  /* vertex of the binary tree   */
+#define CV_SEQ_ELTYPE_CONNECTED_COMP 0  /* connected component  */
+#define CV_SEQ_ELTYPE_POINT3D        CV_32FC3  /* (x,y,z)  */
+
+#define CV_SEQ_KIND_BITS        3
+#define CV_SEQ_KIND_MASK        (((1 << CV_SEQ_KIND_BITS) - 1)<<CV_SEQ_ELTYPE_BITS)
+
+/* types of sequences */
+#define CV_SEQ_KIND_GENERIC     (0 << CV_SEQ_ELTYPE_BITS)
+#define CV_SEQ_KIND_CURVE       (1 << CV_SEQ_ELTYPE_BITS)
+#define CV_SEQ_KIND_BIN_TREE    (2 << CV_SEQ_ELTYPE_BITS)
+
+/* types of sparse sequences (sets) */
+#define CV_SEQ_KIND_GRAPH       (3 << CV_SEQ_ELTYPE_BITS)
+#define CV_SEQ_KIND_SUBDIV2D    (4 << CV_SEQ_ELTYPE_BITS)
+
+#define CV_SEQ_FLAG_SHIFT       (CV_SEQ_KIND_BITS + CV_SEQ_ELTYPE_BITS)
+
+/* flags for curves */
+#define CV_SEQ_FLAG_CLOSED     (1 << CV_SEQ_FLAG_SHIFT)
+#define CV_SEQ_FLAG_SIMPLE     (2 << CV_SEQ_FLAG_SHIFT)
+#define CV_SEQ_FLAG_CONVEX     (4 << CV_SEQ_FLAG_SHIFT)
+#define CV_SEQ_FLAG_HOLE       (8 << CV_SEQ_FLAG_SHIFT)
+
+/* flags for graphs */
+#define CV_GRAPH_FLAG_ORIENTED (1 << CV_SEQ_FLAG_SHIFT)
+
+#define CV_GRAPH               CV_SEQ_KIND_GRAPH
+#define CV_ORIENTED_GRAPH      (CV_SEQ_KIND_GRAPH|CV_GRAPH_FLAG_ORIENTED)
+
+/* point sets */
+#define CV_SEQ_POINT_SET       (CV_SEQ_KIND_GENERIC| CV_SEQ_ELTYPE_POINT)
+#define CV_SEQ_POINT3D_SET     (CV_SEQ_KIND_GENERIC| CV_SEQ_ELTYPE_POINT3D)
+#define CV_SEQ_POLYLINE        (CV_SEQ_KIND_CURVE  | CV_SEQ_ELTYPE_POINT)
+#define CV_SEQ_POLYGON         (CV_SEQ_FLAG_CLOSED | CV_SEQ_POLYLINE )
+#define CV_SEQ_CONTOUR         CV_SEQ_POLYGON
+#define CV_SEQ_SIMPLE_POLYGON  (CV_SEQ_FLAG_SIMPLE | CV_SEQ_POLYGON  )
+
+/* chain-coded curves */
+#define CV_SEQ_CHAIN           (CV_SEQ_KIND_CURVE  | CV_SEQ_ELTYPE_CODE)
+#define CV_SEQ_CHAIN_CONTOUR   (CV_SEQ_FLAG_CLOSED | CV_SEQ_CHAIN)
+
+/* binary tree for the contour */
+#define CV_SEQ_POLYGON_TREE    (CV_SEQ_KIND_BIN_TREE  | CV_SEQ_ELTYPE_TRIAN_ATR)
+
+/* sequence of the connected components */
+#define CV_SEQ_CONNECTED_COMP  (CV_SEQ_KIND_GENERIC  | CV_SEQ_ELTYPE_CONNECTED_COMP)
+
+/* sequence of the integer numbers */
+#define CV_SEQ_INDEX           (CV_SEQ_KIND_GENERIC  | CV_SEQ_ELTYPE_INDEX)
+
+#define CV_SEQ_ELTYPE( seq )   ((seq)->flags & CV_SEQ_ELTYPE_MASK)
+#define CV_SEQ_KIND( seq )     ((seq)->flags & CV_SEQ_KIND_MASK )
+
+/* flag checking */
+#define CV_IS_SEQ_INDEX( seq )      ((CV_SEQ_ELTYPE(seq) == CV_SEQ_ELTYPE_INDEX) && \
+                                     (CV_SEQ_KIND(seq) == CV_SEQ_KIND_GENERIC))
+
+#define CV_IS_SEQ_CURVE( seq )      (CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE)
+#define CV_IS_SEQ_CLOSED( seq )     (((seq)->flags & CV_SEQ_FLAG_CLOSED) != 0)
+#define CV_IS_SEQ_CONVEX( seq )     (((seq)->flags & CV_SEQ_FLAG_CONVEX) != 0)
+#define CV_IS_SEQ_HOLE( seq )       (((seq)->flags & CV_SEQ_FLAG_HOLE) != 0)
+#define CV_IS_SEQ_SIMPLE( seq )     ((((seq)->flags & CV_SEQ_FLAG_SIMPLE) != 0) || \
+                                    CV_IS_SEQ_CONVEX(seq))
+
+/* type checking macros */
+#define CV_IS_SEQ_POINT_SET( seq ) \
+    ((CV_SEQ_ELTYPE(seq) == CV_32SC2 || CV_SEQ_ELTYPE(seq) == CV_32FC2))
+
+#define CV_IS_SEQ_POINT_SUBSET( seq ) \
+    (CV_IS_SEQ_INDEX( seq ) || CV_SEQ_ELTYPE(seq) == CV_SEQ_ELTYPE_PPOINT)
+
+#define CV_IS_SEQ_POLYLINE( seq )   \
+    (CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE && CV_IS_SEQ_POINT_SET(seq))
+
+#define CV_IS_SEQ_POLYGON( seq )   \
+    (CV_IS_SEQ_POLYLINE(seq) && CV_IS_SEQ_CLOSED(seq))
+
+#define CV_IS_SEQ_CHAIN( seq )   \
+    (CV_SEQ_KIND(seq) == CV_SEQ_KIND_CURVE && (seq)->elem_size == 1)
+
+#define CV_IS_SEQ_CONTOUR( seq )   \
+    (CV_IS_SEQ_CLOSED(seq) && (CV_IS_SEQ_POLYLINE(seq) || CV_IS_SEQ_CHAIN(seq)))
+
+#define CV_IS_SEQ_CHAIN_CONTOUR( seq ) \
+    (CV_IS_SEQ_CHAIN( seq ) && CV_IS_SEQ_CLOSED( seq ))
+
+#define CV_IS_SEQ_POLYGON_TREE( seq ) \
+    (CV_SEQ_ELTYPE (seq) ==  CV_SEQ_ELTYPE_TRIAN_ATR &&    \
+    CV_SEQ_KIND( seq ) ==  CV_SEQ_KIND_BIN_TREE )
+
+#define CV_IS_GRAPH( seq )    \
+    (CV_IS_SET(seq) && CV_SEQ_KIND((CvSet*)(seq)) == CV_SEQ_KIND_GRAPH)
+
+#define CV_IS_GRAPH_ORIENTED( seq )   \
+    (((seq)->flags & CV_GRAPH_FLAG_ORIENTED) != 0)
+
+#define CV_IS_SUBDIV2D( seq )  \
+    (CV_IS_SET(seq) && CV_SEQ_KIND((CvSet*)(seq)) == CV_SEQ_KIND_SUBDIV2D)
+
+/****************************************************************************************/
+/*                            Sequence writer & reader                                  */
+/****************************************************************************************/
+
+#define CV_SEQ_WRITER_FIELDS()                                     \
+    int          header_size;                                      \
+    CvSeq*       seq;        /* the sequence written */            \
+    CvSeqBlock*  block;      /* current block */                   \
+    char*        ptr;        /* pointer to free space */           \
+    char*        block_min;  /* pointer to the beginning of block*/\
+    char*        block_max;  /* pointer to the end of block */
+
+typedef struct CvSeqWriter
+{
+    CV_SEQ_WRITER_FIELDS()
+}
+CvSeqWriter;
+
+
+#define CV_SEQ_READER_FIELDS()                                      \
+    int          header_size;                                       \
+    CvSeq*       seq;        /* sequence, beign read */             \
+    CvSeqBlock*  block;      /* current block */                    \
+    char*        ptr;        /* pointer to element be read next */  \
+    char*        block_min;  /* pointer to the beginning of block */\
+    char*        block_max;  /* pointer to the end of block */      \
+    int          delta_index;/* = seq->first->start_index   */      \
+    char*        prev_elem;  /* pointer to previous element */
+
+
+typedef struct CvSeqReader
+{
+    CV_SEQ_READER_FIELDS()
+}
+CvSeqReader;
+
+/****************************************************************************************/
+/*                                Operations on sequences                               */
+/****************************************************************************************/
+
+#define  CV_SEQ_ELEM( seq, elem_type, index )                    \
+/* assert gives some guarantee that <seq> parameter is valid */  \
+(   assert(sizeof((seq)->first[0]) == sizeof(CvSeqBlock) &&      \
+    (seq)->elem_size == sizeof(elem_type)),                      \
+    (elem_type*)((seq)->first && (unsigned)index <               \
+    (unsigned)((seq)->first->count) ?                            \
+    (seq)->first->data + (index) * sizeof(elem_type) :           \
+    cvGetSeqElem( (CvSeq*)(seq), (index) )))
+#define CV_GET_SEQ_ELEM( elem_type, seq, index ) CV_SEQ_ELEM( (seq), elem_type, (index) )
+
+/* macro that adds element to sequence */
+#define CV_WRITE_SEQ_ELEM_VAR( elem_ptr, writer )     \
+{                                                     \
+    if( (writer).ptr >= (writer).block_max )          \
+    {                                                 \
+        cvCreateSeqBlock( &writer);                   \
+    }                                                 \
+    memcpy((writer).ptr, elem_ptr, (writer).seq->elem_size);\
+    (writer).ptr += (writer).seq->elem_size;          \
+}
+
+#define CV_WRITE_SEQ_ELEM( elem, writer )             \
+{                                                     \
+    assert( (writer).seq->elem_size == sizeof(elem)); \
+    if( (writer).ptr >= (writer).block_max )          \
+    {                                                 \
+        cvCreateSeqBlock( &writer);                   \
+    }                                                 \
+    assert( (writer).ptr <= (writer).block_max - sizeof(elem));\
+    memcpy((writer).ptr, &(elem), sizeof(elem));      \
+    (writer).ptr += sizeof(elem);                     \
+}
+
+
+/* move reader position forward */
+#define CV_NEXT_SEQ_ELEM( elem_size, reader )                 \
+{                                                             \
+    if( ((reader).ptr += (elem_size)) >= (reader).block_max ) \
+    {                                                         \
+        cvChangeSeqBlock( &(reader), 1 );                     \
+    }                                                         \
+}
+
+
+/* move reader position backward */
+#define CV_PREV_SEQ_ELEM( elem_size, reader )                \
+{                                                            \
+    if( ((reader).ptr -= (elem_size)) < (reader).block_min ) \
+    {                                                        \
+        cvChangeSeqBlock( &(reader), -1 );                   \
+    }                                                        \
+}
+
+/* read element and move read position forward */
+#define CV_READ_SEQ_ELEM( elem, reader )                       \
+{                                                              \
+    assert( (reader).seq->elem_size == sizeof(elem));          \
+    memcpy( &(elem), (reader).ptr, sizeof((elem)));            \
+    CV_NEXT_SEQ_ELEM( sizeof(elem), reader )                   \
+}
+
+/* read element and move read position backward */
+#define CV_REV_READ_SEQ_ELEM( elem, reader )                     \
+{                                                                \
+    assert( (reader).seq->elem_size == sizeof(elem));            \
+    memcpy(&(elem), (reader).ptr, sizeof((elem)));               \
+    CV_PREV_SEQ_ELEM( sizeof(elem), reader )                     \
+}
+
+
+#define CV_READ_CHAIN_POINT( _pt, reader )                              \
+{                                                                       \
+    (_pt) = (reader).pt;                                                \
+    if( (reader).ptr )                                                  \
+    {                                                                   \
+        CV_READ_SEQ_ELEM( (reader).code, (reader));                     \
+        assert( ((reader).code & ~7) == 0 );                            \
+        (reader).pt.x += (reader).deltas[(int)(reader).code][0];        \
+        (reader).pt.y += (reader).deltas[(int)(reader).code][1];        \
+    }                                                                   \
+}
+
+#define CV_CURRENT_POINT( reader )  (*((CvPoint*)((reader).ptr)))
+#define CV_PREV_POINT( reader )     (*((CvPoint*)((reader).prev_elem)))
+
+#define CV_READ_EDGE( pt1, pt2, reader )               \
+{                                                      \
+    assert( sizeof(pt1) == sizeof(CvPoint) &&          \
+            sizeof(pt2) == sizeof(CvPoint) &&          \
+            reader.seq->elem_size == sizeof(CvPoint)); \
+    (pt1) = CV_PREV_POINT( reader );                   \
+    (pt2) = CV_CURRENT_POINT( reader );                \
+    (reader).prev_elem = (reader).ptr;                 \
+    CV_NEXT_SEQ_ELEM( sizeof(CvPoint), (reader));      \
+}
+
+/************ Graph macros ************/
+
+/* returns next graph edge for given vertex */
+#define  CV_NEXT_GRAPH_EDGE( edge, vertex )                              \
+     (assert((edge)->vtx[0] == (vertex) || (edge)->vtx[1] == (vertex)),  \
+      (edge)->next[(edge)->vtx[1] == (vertex)])
+
+
+
+/****************************************************************************************\
+*             Data structures for persistence (a.k.a serialization) functionality        *
+\****************************************************************************************/
+
+/* "black box" file storage */
+typedef struct CvFileStorage CvFileStorage;
+
+/* storage flags */
+#define CV_STORAGE_READ          0
+#define CV_STORAGE_WRITE         1
+#define CV_STORAGE_WRITE_TEXT    CV_STORAGE_WRITE
+#define CV_STORAGE_WRITE_BINARY  CV_STORAGE_WRITE
+#define CV_STORAGE_APPEND        2
+
+/* list of attributes */
+typedef struct CvAttrList
+{
+    const char** attr; /* NULL-terminated array of (attribute_name,attribute_value) pairs */
+    struct CvAttrList* next; /* pointer to next chunk of the attributes list */
+}
+CvAttrList;
+
+CV_INLINE CvAttrList cvAttrList( const char** attr CV_DEFAULT(NULL),
+                                 CvAttrList* next CV_DEFAULT(NULL) )
+{
+    CvAttrList l;
+    l.attr = attr;
+    l.next = next;
+
+    return l;
+}
+
+struct CvTypeInfo;
+
+#define CV_NODE_NONE        0
+#define CV_NODE_INT         1
+#define CV_NODE_INTEGER     CV_NODE_INT
+#define CV_NODE_REAL        2
+#define CV_NODE_FLOAT       CV_NODE_REAL
+#define CV_NODE_STR         3
+#define CV_NODE_STRING      CV_NODE_STR
+#define CV_NODE_REF         4 /* not used */
+#define CV_NODE_SEQ         5
+#define CV_NODE_MAP         6
+#define CV_NODE_TYPE_MASK   7
+
+#define CV_NODE_TYPE(flags)  ((flags) & CV_NODE_TYPE_MASK)
+
+/* file node flags */
+#define CV_NODE_FLOW        8 /* used only for writing structures to YAML format */
+#define CV_NODE_USER        16
+#define CV_NODE_EMPTY       32
+#define CV_NODE_NAMED       64
+
+#define CV_NODE_IS_INT(flags)        (CV_NODE_TYPE(flags) == CV_NODE_INT)
+#define CV_NODE_IS_REAL(flags)       (CV_NODE_TYPE(flags) == CV_NODE_REAL)
+#define CV_NODE_IS_STRING(flags)     (CV_NODE_TYPE(flags) == CV_NODE_STRING)
+#define CV_NODE_IS_SEQ(flags)        (CV_NODE_TYPE(flags) == CV_NODE_SEQ)
+#define CV_NODE_IS_MAP(flags)        (CV_NODE_TYPE(flags) == CV_NODE_MAP)
+#define CV_NODE_IS_COLLECTION(flags) (CV_NODE_TYPE(flags) >= CV_NODE_SEQ)
+#define CV_NODE_IS_FLOW(flags)       (((flags) & CV_NODE_FLOW) != 0)
+#define CV_NODE_IS_EMPTY(flags)      (((flags) & CV_NODE_EMPTY) != 0)
+#define CV_NODE_IS_USER(flags)       (((flags) & CV_NODE_USER) != 0)
+#define CV_NODE_HAS_NAME(flags)      (((flags) & CV_NODE_NAMED) != 0)
+
+#define CV_NODE_SEQ_SIMPLE 256
+#define CV_NODE_SEQ_IS_SIMPLE(seq) (((seq)->flags & CV_NODE_SEQ_SIMPLE) != 0)
+
+typedef struct CvString
+{
+    int len;
+    char* ptr;
+}
+CvString;
+
+/* all the keys (names) of elements in the readed file storage
+   are stored in the hash to speed up the lookup operations */
+typedef struct CvStringHashNode
+{
+    unsigned hashval;
+    CvString str;
+    struct CvStringHashNode* next;
+}
+CvStringHashNode;
+
+typedef struct CvGenericHash CvFileNodeHash;
+
+/* basic element of the file storage - scalar or collection */
+typedef struct CvFileNode
+{
+    int tag;
+    struct CvTypeInfo* info; /* type information
+            (only for user-defined object, for others it is 0) */
+    union
+    {
+        double f; /* scalar floating-point number */
+        int i;    /* scalar integer number */
+        CvString str; /* text string */
+        CvSeq* seq; /* sequence (ordered collection of file nodes) */
+        CvFileNodeHash* map; /* map (collection of named file nodes) */
+    } data;
+}
+CvFileNode;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+typedef int (CV_CDECL *CvIsInstanceFunc)( const void* struct_ptr );
+typedef void (CV_CDECL *CvReleaseFunc)( void** struct_dblptr );
+typedef void* (CV_CDECL *CvReadFunc)( CvFileStorage* storage, CvFileNode* node );
+typedef void (CV_CDECL *CvWriteFunc)( CvFileStorage* storage, const char* name,
+                                      const void* struct_ptr, CvAttrList attributes );
+typedef void* (CV_CDECL *CvCloneFunc)( const void* struct_ptr );
+#ifdef __cplusplus
+}
+#endif
+
+typedef struct CvTypeInfo
+{
+    int flags;
+    int header_size;
+    struct CvTypeInfo* prev;
+    struct CvTypeInfo* next;
+    const char* type_name;
+    CvIsInstanceFunc is_instance;
+    CvReleaseFunc release;
+    CvReadFunc read;
+    CvWriteFunc write;
+    CvCloneFunc clone;
+}
+CvTypeInfo;
+
+
+/**** System data types ******/
+
+typedef struct CvPluginFuncInfo
+{
+    void** func_addr;
+    void* default_func_addr;
+    const char* func_names;
+    int search_modules;
+    int loaded_from;
+}
+CvPluginFuncInfo;
+
+typedef struct CvModuleInfo
+{
+    struct CvModuleInfo* next;
+    const char* name;
+    const char* version;
+    CvPluginFuncInfo* func_tab;
+}
+CvModuleInfo;
+
+#endif /*_CXCORE_TYPES_H_*/
+
+/* End of file. */
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/include/DSP_fltoq15.h c6accel_1_00_00_04_async/dsp/libs/include/DSP_fltoq15.h
--- c6accel_1_00_00_04_async0/dsp/libs/include/DSP_fltoq15.h	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/libs/include/DSP_fltoq15.h	2010-08-14 17:17:18.000000000 -0500
@@ -0,0 +1,29 @@
+/* ======================================================================= */
+/* DSP_fltoq15.h -- Float to Q15 conversion                                */
+/*                  Optimized C Implementation (w/ Intrinsics)             */
+/*                                                                         */
+/* Rev 0.0.1                                                               */
+/*                                                                         */
+/* ----------------------------------------------------------------------- */
+/*            Copyright (c) 2007 Texas Instruments, Incorporated.          */
+/*                           All Rights Reserved.                          */
+/* ======================================================================= */
+
+#ifndef _DSP_FLTOQ15_H_
+#define _DSP_FLTOQ15_H_ 1
+
+void DSP_fltoq15 (
+    const float *restrict flt,  /* Input float array    */
+    short *restrict q15,        /* Output Q15 array     */
+    short nx                    /* Number of elements   */
+);
+
+#endif /* _DSP_FLTOQ15_H_ */
+
+/* ======================================================================= */
+/*  End of file:  DSP_fltoq15.h                                            */
+/* ----------------------------------------------------------------------- */
+/*            Copyright (c) 2007 Texas Instruments, Incorporated.          */
+/*                           All Rights Reserved.                          */
+/* ======================================================================= */
+
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/include/dsplib64plus.h c6accel_1_00_00_04_async/dsp/libs/include/dsplib64plus.h
--- c6accel_1_00_00_04_async0/dsp/libs/include/dsplib64plus.h	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/dsp/libs/include/dsplib64plus.h	2010-08-14 17:17:18.000000000 -0500
@@ -13,4 +13,5 @@
 #include "DSP_ifft32x32.h"
 #include "DSP_iir.h"
 #include "DSP_mat_mul.h"
-
+#include "DSP_fltoq15.h"
+#include "DSP_q15tofl.h"
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/include/DSP_q15tofl.h c6accel_1_00_00_04_async/dsp/libs/include/DSP_q15tofl.h
--- c6accel_1_00_00_04_async0/dsp/libs/include/DSP_q15tofl.h	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/libs/include/DSP_q15tofl.h	2010-08-14 17:17:18.000000000 -0500
@@ -0,0 +1,29 @@
+/* ======================================================================= */
+/* DSP_q15tofl.h -- Q15 to Float conversion                                */
+/*                  Optimized C Implementation (w/ Intrinsics)             */
+/*                                                                         */
+/* Rev 0.0.1                                                               */
+/*                                                                         */
+/* ----------------------------------------------------------------------- */
+/*            Copyright (c) 2007 Texas Instruments, Incorporated.          */
+/*                           All Rights Reserved.                          */
+/* ======================================================================= */
+
+#ifndef _DSP_Q15TOFL_H_
+#define _DSP_Q15TOFL_H_ 1
+
+void DSP_q15tofl (
+    const short *restrict q15,  /* Input Q15 array      */
+    float *restrict flt,        /* Output float array   */
+    short nx                    /* Number of elements   */
+);
+
+#endif /* _DSP_Q15TOFL_H_ */
+
+/* ======================================================================= */
+/*  End of file:  DSP_q15tofl.h                                            */
+/* ----------------------------------------------------------------------- */
+/*            Copyright (c) 2007 Texas Instruments, Incorporated.          */
+/*                           All Rights Reserved.                          */
+/* ======================================================================= */
+
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/include/imglib64plus.h c6accel_1_00_00_04_async/dsp/libs/include/imglib64plus.h
--- c6accel_1_00_00_04_async0/dsp/libs/include/imglib64plus.h	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/dsp/libs/include/imglib64plus.h	2010-08-14 17:17:18.000000000 -0500
@@ -61,4 +61,6 @@
 #include"IMG_yc_demux_be16_16.h"
 #include"IMG_yc_demux_le16_8.h"
 #include"IMG_yc_demux_le16_16.h"
-#include"IMG_ycbcr422pl_to_rgb565.h"
+#include"IMG_ycbcr422pl_to_rgb565.h"
+//Added by Pramod
+#include"IMG_sobel_3x3_8_16.h"
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/include/IMG_sobel_3x3_8_16.h c6accel_1_00_00_04_async/dsp/libs/include/IMG_sobel_3x3_8_16.h
--- c6accel_1_00_00_04_async0/dsp/libs/include/IMG_sobel_3x3_8_16.h	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/libs/include/IMG_sobel_3x3_8_16.h	2010-08-14 17:17:18.000000000 -0500
@@ -0,0 +1,130 @@
+/* ======================================================================== */
+/*  TEXAS INSTRUMENTS, INC.                                                 */
+/*                                                                          */
+/*  IMGLIB-2  DSP Image/Video Processing Library                            */
+/*                                                                          */
+/*      Release:        Revision 2.0.1                                      */
+/*      Snapshot date:  6-May-2008                                          */
+/*                                                                          */
+/*  This library contains proprietary intellectual property of Texas        */
+/*  Instruments, Inc.  The library and its source code are protected by     */
+/*  various copyrights, and portions may also be protected by patents or    */
+/*  other legal protections.                                                */
+/*                                                                          */
+/*  This software is licensed for use with Texas Instruments TMS320         */
+/*  family DSPs.  This license was provided to you prior to installing      */
+/*  the software.  You may review this license by consulting the file       */
+/*  TI_license.PDF which accompanies the files in this library.             */
+/* ------------------------------------------------------------------------ */
+/*          Copyright (C) 2008 Texas Instruments, Incorporated.             */
+/*                          All Rights Reserved.                            */
+/* ======================================================================== */
+/* ======================================================================== */
+/*  TEXAS INSTRUMENTS, INC.                                                 */
+/*                                                                          */
+/*  NAME                                                                    */
+/*      sobel_3x3_8                                                         */
+/*                                                                          */
+/*  USAGE                                                                   */
+/*      This routine is C-callable and can be called as:                    */
+/*                                                                          */
+/*      void sobel_3x3_8                                                    */
+/*      (                                                                   */
+/*          const unsigned char *in_data,      // Input image data  //      */
+/*          unsigned char       *out_data,     // Output image data //      */ 
+/*          short cols, short rows             // Image dimensions  //      */ 
+/*      )                                                                   */
+/*                                                                          */
+/*      The sobel filter is applied to the input image.  The input image    */ 
+/*      dimensions are given by the arguments 'cols' and 'rows'.  The       */
+/*      output image is 'cols' pixels wide and 'rows - 2' pixels tall.      */
+/*                                                                          */
+/*  DESCRIPTION                                                             */
+/*                                                                          */
+/*      To see how the implementation is going to work on the input         */
+/*      buffer, lets imagine we have the following input buffer:            */  
+/*      lets imagine we have the following input buffer:                    */
+/*                                                                          */
+/*              yyyyyyyyyyyyyyyy                                            */
+/*              yxxxxxxxxxxxxxxy                                            */
+/*              yxxxxxxxxxxxxxxy                                            */
+/*              yxxxxxxxxxxxxxxy                                            */
+/*              yxxxxxxxxxxxxxxy                                            */
+/*              yyyyyyyyyyyyyyyy                                            */
+/*                                                                          */
+/*      The output buffer would be:                                         */
+/*                                                                          */
+/*              tXXXXXXXXXXXXXXz                                            */
+/*              zXXXXXXXXXXXXXXz                                            */
+/*              zXXXXXXXXXXXXXXz                                            */
+/*              zXXXXXXXXXXXXXXt                                            */  
+/*                                                                          */
+/*      Where:                                                              */
+/*                                                                          */
+/*          X = sobel(x)    The algorithm is applied to that pixel.         */
+/*                          The correct output is obtained, the data        */ 
+/*                          around the pixels we work on is used            */
+/*                                                                          */
+/*          t               Whatever was in the output buffer in that       */
+/*                          position is kept there.                         */
+/*                                                                          */
+/*          z = sobel(y)    The algorithm is applied to that pixel.         */
+/*                          The output is not meaningful, because the       */
+/*                          necessary data to process the pixel is not      */
+/*                          available.  This is because for each output     */
+/*                          pixel we need input pixels from the right and   */
+/*                          from the left of the output pixel.  But this    */ 
+/*                          data doesn't exist.                             */
+/*                                                                          */
+/*      This means that we will only process (rows-2) lines.  Then, we      */
+/*      will process all the pixels inside each line. Even though the       */
+/*      results for the first and last pixels in each line will not         */
+/*      be relevant, it makes the control much simpler and ends up          */
+/*      saving cycles.                                                      */
+/*                                                                          */ 
+/*      Also the first pixel in the first processed line and the            */ 
+/*      last pixel in the last processed line will not be computed.         */ 
+/*      It is not necessary, since the results would be bogus.              */
+/*                                                                          */
+/*      The following horizontal and vertical masks that are                */
+/*      applied to the input buffer to obtain one output pixel.             */
+/*                                                                          */
+/*          Horizontal:                                                     */
+/*              -1 -2 -1                                                    */
+/*               0  0  0                                                    */
+/*               1  2  1                                                    */
+/*                                                                          */
+/*          Vertical:                                                       */
+/*              -1  0  1                                                    */
+/*              -2  0  2                                                    */
+/*              -1  0  1                                                    */
+/*                                                                          */
+/*  ASSUMPTIONS                                                             */
+/*      (rows * cols) must be a multiple of 8                               */
+/*      The input image width must be even (eg. 'cols' must be even).       */
+/*                                                                          */
+/*  NOTES                                                                   */
+/*      The values of the left-most and right-most pixels on each line      */
+/*      of the output are not well-defined.                                 */
+/* ------------------------------------------------------------------------ */
+/*            Copyright (c) 2008 Texas Instruments, Incorporated.           */
+/*                           All Rights Reserved.                           */
+/* ======================================================================== */
+#ifndef IMG_SOBEL_3x3_8_I_H_
+#define IMG_SOBEL_3x3_8_I_H_ 1
+
+void IMG_sobel_3x3_8_16
+(
+    const unsigned char *restrict in,   /* Input image data   */
+    unsigned short       *restrict out,  /* Output image data  */
+    short cols, short rows              /* Image dimensions   */
+);
+
+#endif
+/* ======================================================================== */
+/*  End of file:  IMG_sobel_3x3_8_i.h                                       */
+/* ------------------------------------------------------------------------ */
+/*            Copyright (c) 2008 Texas Instruments, Incorporated.           */
+/*                           All Rights Reserved.                           */
+/* ======================================================================== */
+
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/include/VLIB_prototypes.h c6accel_1_00_00_04_async/dsp/libs/include/VLIB_prototypes.h
--- c6accel_1_00_00_04_async0/dsp/libs/include/VLIB_prototypes.h	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/dsp/libs/include/VLIB_prototypes.h	2010-08-14 17:17:18.000000000 -0500
@@ -0,0 +1,1048 @@
+/*******************************************************************************
+**+--------------------------------------------------------------------------+**
+**|                            ****                                          |**
+**|                            ****                                          |**
+**|                            ******o***                                    |**
+**|                      ********_///_****                                   |**
+**|                      ***** /_//_/ ****                                   |**
+**|                       ** ** (__/ ****                                    |**
+**|                           *********                                      |**
+**|                            ****                                          |**
+**|                            ***                                           |**
+**|                                                                          |**
+**|         Copyright (c) 2007-2012 Texas Instruments Incorporated           |**
+**|                        ALL RIGHTS RESERVED                               |**
+**|                                                                          |**
+**| Permission to use, copy, modify, or distribute this software,            |**
+**| whether in part or in whole, for any purpose is forbidden without        |**
+**| a signed licensing agreement and NDA from Texas Instruments              |**
+**| Incorporated (TI).                                                       |**
+**|                                                                          |**
+**| TI makes no representation or warranties with respect to the             |**
+**| performance of this computer program, and specifically disclaims         |**
+**| any responsibility for any damages, special or consequential,            |**
+**| connected with the use of this program.                                  |**
+**|                                                                          |**
+**+--------------------------------------------------------------------------+**
+*******************************************************************************/
+ 
+
+#ifndef VLIB_PROTO
+
+#define VLIB_PROTO
+
+#ifdef WIN32
+#define restrict    
+#endif
+
+typedef struct {
+	int area;
+  	int xsum; 
+  	int ysum;
+
+  	int xmin;
+  	int ymin;
+  	int xmax;
+  	int ymax;  
+} VLIB_CC;
+
+typedef int VLIB_CCHandle; 
+
+// Background Model Constants
+#define IIR_ALPHA_S32         0x00001000    // SQ0.31
+#define IIR_ALPHA_S16         0x10       	// SQ0.15
+#define CAMERA_NOISE_S32      0x00A00000    // SQ16.15
+#define CAMERA_NOISE_S16      0x0A00     	// SQ12.3
+#define THRESHOLD_FACTOR_S32  0x31fffff9    // SQ4.27
+#define THRESHOLD_FACTOR_S16  0x31ff        // SQ4.11
+
+typedef enum 
+{
+	VLIB_NO_ERROR = 0,
+	VLIB_ERR_INPUT_INVALID = 1,
+	VLIB_ERR_INPUT_NEGATIVE = 2,
+	VLIB_ERR_INPUT_EXCEEDED_RANGE = 3,
+	VLIB_ERR_MEMORY_EXCEEDED_BOUNDARY = 4,
+	VLIB_ERR_MEMORY_ALLOCATION_FAILURE = 5,
+	VLIB_ERR_MEMORY_POINTER_NULL = 6,
+	VLIB_ERR_DMA_FAILURE = 7,
+	VLIB_ERR_FILE_OPEN_FAILURE = 8,
+	VLIB_ERR_FILE_READ_FAILURE = 9,
+	VLIB_ERR_FILE_WRITE_FAILURE = 10,
+	VLIB_ERR_FILE_CLOSE_FAILURE = 11,
+	VLIB_ERR_FILE_FORMAT_FAILURE = 12,
+	VLIB_WARNING_LOW_MEMORY = 13
+
+} VLIB_STATUS;
+
+int VLIB_doublethresholding
+(
+signed short * restrict pInMag, 
+unsigned char *edgeMap, 
+unsigned int * restrict strongEdgeListPtr,
+int * numStrongEdges,
+unsigned short width, 
+unsigned short pitch, 
+unsigned short height,
+unsigned char loThresh,
+unsigned char hiThresh,
+unsigned int  block_offset
+);
+
+int VLIB_edgeRelaxation
+(
+unsigned char *edgeMap, 
+unsigned int * restrict strongEdgeListPtr,
+int * numStrongEdges,
+unsigned short width
+);
+
+int VLIB_houghLineFromList
+(
+unsigned short * restrict pEdgeMapList, 
+unsigned short * restrict pOutHoughSpace, 
+unsigned short outBlkWidth,              
+unsigned short outBlkHeight,             
+unsigned int listSize,
+unsigned short thetaRange, 
+unsigned short rhoMaxLength,
+const signed short *pSIN,
+const signed short *pCOS,
+unsigned short * restrict ping,
+unsigned short * restrict pong,
+unsigned short * restrict pang,
+unsigned short * restrict peng
+);
+
+int VLIB_mixtureOfGaussiansS16
+(
+const unsigned char* restrict Im, 
+short* restrict wt, 
+short* restrict mu, 
+short* restrict var, 
+unsigned char* restrict compNum,
+unsigned char* restrict updateMask8,
+unsigned int* restrict Im_mask, 
+const int im_size, 
+const short alpha, 
+const short rho, 
+const short delta, 
+const short T, 
+const short ini_wt, 
+const short ini_var
+);
+
+int VLIB_imagePyramid16
+(
+unsigned short * restrict pIn, 
+unsigned short  inCols,
+unsigned short  inRows,
+unsigned short* restrict pOut
+);
+
+int VLIB_imagePyramid8
+(
+unsigned char * restrict pIn, 
+unsigned short  inCols,
+unsigned short  inRows,
+unsigned char* restrict pOut
+);
+
+int VLIB_integralImage16
+(
+unsigned short* restrict pIn, 
+unsigned short  inCols,
+unsigned short  inRows,
+unsigned int* restrict pLastLine, 
+unsigned int* restrict pOut
+);
+
+int VLIB_integralImage8
+(
+unsigned char* restrict pIn, 
+unsigned short  inCols,
+unsigned short  inRows,
+unsigned int* restrict pLastLine,   
+unsigned int* restrict pOut
+);
+
+int VLIB_mixtureOfGaussiansS32
+(
+const unsigned char* restrict Im, 
+short* restrict wt, 
+int* restrict mu, 
+int* restrict var, 
+unsigned char* restrict compNum,
+unsigned char* restrict updateMask8,	
+unsigned int* restrict Im_mask, 
+const int im_size, 
+const short alpha, 
+const int rho, 
+const int delta, 
+const short T, 
+const short ini_wt, 
+const int ini_var
+);
+
+int VLIB_subtractBackgroundS16
+(
+unsigned int * restrict output32packed,
+const unsigned char * restrict newestData, 
+const short * restrict currentMean, 
+const short * restrict currentVar, 
+const short thresholdGlobal, 
+const short thresholdFactor,
+const unsigned int frameSize
+);
+
+int VLIB_subtractBackgroundS32
+(
+unsigned int * restrict output32packed, 
+const unsigned char * restrict newestData, 
+const int * restrict currentMean, 
+const int * restrict currentVar, 
+const int thresholdGlobal, 
+const int thresholdFactor,
+const unsigned int frameSize
+);
+
+int VLIB_updateEWRMeanS16
+(
+short * restrict currentMean, 
+const unsigned char * restrict newestData, 
+const unsigned int * restrict foreground, 
+const short weight, 
+const unsigned int frameSize
+);
+
+int VLIB_updateEWRMeanS32
+(
+int * currentMean, 
+unsigned char * newestData, 
+unsigned int * foreground, 
+unsigned int weight, 
+int frameSize
+);
+
+int VLIB_updateEWRVarianceS16
+(
+short * restrict currentVar, 
+const short * restrict currentMean, 
+const unsigned char * restrict newestData, 
+const unsigned int * restrict foreground32packed, 
+const short weight, 
+const unsigned int frameSize
+);
+
+int VLIB_updateEWRVarianceS32
+(
+int * restrict currentVar, 
+const int * restrict currentMean, 
+const unsigned char * restrict newestData, 
+const unsigned int * restrict foreground32packed, 
+const int weight, 
+const unsigned int frameSize
+);
+
+int VLIB_updateUWRMeanS16
+(
+short * restrict updatedMean, 
+const short * restrict currentMean, 
+const unsigned char * restrict newestData, 
+const unsigned char * restrict oldestData, 
+const unsigned int * restrict newestForeground32packed, 
+const unsigned int * restrict oldestForeground32packed, 
+const unsigned int pixelCount, 
+const unsigned char frameCount
+);
+
+int VLIB_updateUWRVarianceS16
+(
+short * restrict updatedVar, 
+const short * restrict previousVar, 
+const short * restrict updatedMean, 
+const short * restrict previousMean, 
+const unsigned char * restrict newestData, 
+const unsigned int * restrict newestForeground32packed, 
+const unsigned int * restrict oldestForeground32packed, 
+const unsigned int pixelCount, 
+const unsigned char frameCount
+);
+
+
+void VLIB_erode_bin_square  
+(
+const unsigned char *restrict in_data, 
+unsigned char       *restrict out_data, 
+int cols,
+int pitch
+);
+
+void VLIB_dilate_bin_cross  
+(
+    const unsigned char *restrict in_data, 
+    unsigned char       *restrict out_data, 
+    int cols,
+    int pitch
+);
+
+void VLIB_dilate_bin_mask  
+(
+    const unsigned char * in_data, 
+    unsigned char       * out_data, 
+    const char          * mask, 
+    int cols,
+    int pitch
+);
+
+void VLIB_dilate_bin_square  
+(
+    const unsigned char *restrict in_data, 
+    unsigned char       *restrict out_data, 
+    int cols,
+    int pitch
+);
+
+void VLIB_dilate_bin_square  
+(
+    const unsigned char *restrict in_data, 
+    unsigned char       *restrict out_data, 
+    int cols,
+    int pitch
+);
+
+void VLIB_erode_bin_mask  
+(
+    const unsigned char * in_data, 
+    unsigned char       * out_data, 
+    const char          * mask, 
+    int cols,
+    int pitch
+);
+
+
+int VLIB_nonMaxSuppress_7x7_S16
+(
+const short * restrict im,
+int width, 
+int height,
+short thresh,
+unsigned char * restrict out
+);
+
+int VLIB_harrisScore_7x7
+(
+const short * restrict gradX, 
+const short * restrict gradY,	
+int width, 
+int height, 
+short * restrict outm,
+short k,
+unsigned char * buffer
+);
+
+int VLIB_histogram_1D_Init_U8
+(
+unsigned char * restrict binEdges, 								  	
+const int numBins,
+unsigned char * restrict histArray
+);
+
+int VLIB_histogram_1D_Init_U16
+(
+unsigned short * restrict binEdges, 								  	
+const int numBins,
+unsigned short * restrict histArray 
+);
+
+int VLIB_nonMaxSuppress_3x3_S16
+(
+const short * restrict im, 
+int width, 
+int height,
+short thresh,
+unsigned char * restrict out
+);
+
+
+int VLIB_weightedHistogram_1D_U8
+(
+unsigned char* restrict X, 
+const int numX,								   			 
+const int numBins,
+unsigned short* restrict binWeight,
+unsigned char* restrict histArray,
+unsigned short* restrict H1,
+unsigned short* restrict H2,
+unsigned short* restrict H3,
+unsigned short* restrict H
+);
+
+int VLIB_weightedHistogram_1D_U16_c
+(
+unsigned short* restrict X, 
+const int numX,								   			 
+const int numBins,
+unsigned short* restrict binWeight,
+unsigned short* restrict histArray,
+unsigned short* restrict H1,
+unsigned short* restrict H
+);
+
+int VLIB_weightedHistogram_nD_U16
+(
+unsigned short* restrict X, 
+const int numX,
+const int dimX,
+unsigned short* binWeight,	
+unsigned short* restrict numBins,
+unsigned short* restrict normVals,
+unsigned short* restrict scrap,
+unsigned short* H1,
+unsigned short* H
+);
+
+int VLIB_histogram_1D_U8
+( 
+unsigned char* restrict X, 
+const int numX,								   			 
+const int numBins,
+const unsigned short binWeight,
+unsigned char* restrict histArray,
+unsigned short* restrict H1,
+unsigned short* restrict H2,
+unsigned short* restrict H3,
+unsigned short* restrict H
+);
+
+int VLIB_histogram_1D_U16
+(
+unsigned short* restrict X, 
+const int numX,								   			 
+const int numBins,
+const unsigned short binWeight,
+unsigned short* restrict histArray,
+unsigned short* restrict H1,
+unsigned short* restrict H
+);
+	
+
+int VLIB_histogram_nD_U16
+(
+unsigned short* restrict X, 
+const int numX,
+const int dimX,
+unsigned short binWeight,	
+unsigned short* restrict numBins,
+unsigned short* restrict normVals,
+unsigned short* restrict scrap,
+unsigned short* H1,
+unsigned short* H
+);
+
+int VLIB_recursiveFilterHoriz1stOrder
+(
+unsigned char * out, 
+const unsigned char * in, 
+const int width,
+const int height,
+const short weight,
+const unsigned char * boundaryLeft,
+const unsigned char * boundaryRight,
+unsigned char * scratch
+);
+
+int VLIB_recursiveFilterVert1stOrder
+(
+unsigned char *out, 
+const unsigned char *in, 
+const int width,
+const int height,
+const short weight,
+const unsigned char * boundaryTop,
+const unsigned char * boundaryBottom,
+unsigned char *scratch
+);
+
+int VLIB_trackFeaturesLucasKanade_7x7
+(
+const unsigned char * restrict im1,
+const unsigned char * restrict im2,
+const short * restrict gradX,
+const short * restrict gradY,
+int width, 
+int height,	
+int nfeatures,
+short * restrict x,
+short * restrict y,
+short * outx,
+short * outy,
+int max_iters,
+const unsigned char * restrict scratch
+);
+
+int VLIB_nonMaxSuppress_5x5_S16
+(
+const short * restrict im, 
+int width, 
+int height,
+short thresh,
+unsigned char * restrict out
+);
+
+int VLIB_initMeanWithLumaS16
+(
+short * restrict runningMean,
+const unsigned char * restrict lumaFrame, 
+const unsigned int pixelCount
+);
+
+int VLIB_initMeanWithLumaS32
+(
+int * restrict runningMean,
+const unsigned char * restrict lumaFrame, 
+const unsigned int pixelCount
+);
+
+
+int VLIB_initVarWithConstS16
+(
+short * restrict runningVar, 
+const short constVar, 
+const unsigned int pixelCount
+);
+
+int VLIB_initVarWithConstS32
+(
+int * restrict runningVar, 
+const int constVar, 
+const unsigned int pixelCount
+);
+
+int VLIB_gradientV5x5PyramidKernel_8
+(
+unsigned char* restrict pIn,
+short* restrict pB,     
+unsigned short  width,      
+unsigned short  pitch,      
+unsigned short  height, 
+unsigned char* restrict pOut
+);  
+
+int VLIB_gradientH5x5PyramidKernel_8
+(
+unsigned char* restrict pIn,  
+short* restrict pB,     
+unsigned short  width,        
+unsigned short  pitch, 
+unsigned short  height,        
+unsigned char* restrict pOut
+);
+
+int VLIB_gauss5x5PyramidKernel_16
+( 
+unsigned short* restrict pIn,  
+unsigned int* restrict pB,     
+unsigned short  width,         
+unsigned short  pitch,
+unsigned short  height,          
+unsigned short* restrict pOut
+);
+
+int VLIB_gauss5x5PyramidKernel_8
+(
+unsigned char* restrict pIn, 
+unsigned short* restrict pB, 
+unsigned short  width,       
+unsigned short  pitch,   
+unsigned short  height,     
+unsigned char* restrict pOut
+);
+
+
+int VLIB_createCCMap8Bit
+(
+VLIB_CCHandle * handle, 
+unsigned char * restrict pOutMap,
+const unsigned short  outCols,                        
+const unsigned short  outRows
+);
+
+int VLIB_getNumCCs
+(
+VLIB_CCHandle * handle, 
+int *numCCs
+);
+
+int VLIB_getCCFeatures
+(
+VLIB_CCHandle * handle, 
+VLIB_CC *cc,
+short listIndex
+);
+
+int VLIB_createConnectedComponentsList
+(
+VLIB_CCHandle * handle, 
+unsigned short  width,
+unsigned short  rowsInImg,
+int *p32BitPackedFGMask,
+int  minBlobArea,
+int  connected8Flag
+);
+
+int VLIB_initConnectedComponentsList
+(
+VLIB_CCHandle * handle,
+void *pBuf, 
+int  bytes
+);
+
+int
+VLIB_calcConnectedComponentsMaxBufferSize
+(
+short imgWidth, 
+short imgHeight,	
+int minArea,
+int *maxBytesRequired
+);
+
+int 
+VLIB_GetSizeOfCCHandle
+(
+void
+);
+
+int VLIB_xyGradientsAndMagnitude
+(
+unsigned char * restrict pInBlk, 
+signed short * restrict pBufGradX,
+signed short * restrict pBufGradY,
+signed short * restrict pBufMag,
+unsigned short width, 
+unsigned short height
+);
+
+int VLIB_nonMaximumSuppressionCanny(short * restrict pInMag, 
+	                            short * restrict pInGradX, 
+	                            short * restrict pInGradY, 
+	                            unsigned char * restrict pOut,
+	                            unsigned short width,
+                                unsigned short pitch,
+	                            unsigned short height) ;
+
+
+void VLIB_bhattacharyaDistance_U32
+(
+unsigned short* restrict X, 
+unsigned short* restrict Y, 
+int N,
+unsigned int* D
+);
+
+
+#define mD_2x4 (2)
+#define sD_2x4 (4)
+
+typedef struct VLIB_kalmanFilter_2x4{
+
+
+	short transition[sD_2x4*sD_2x4];	// QS15 
+	// state transition matrix, A
+
+	short errorCov[sD_2x4*sD_2x4];	// QS15
+	// a priori error covariance matrix, P
+
+	short predictedErrorCov[sD_2x4*sD_2x4];	// QS15 
+	// predicted error covariance matrix, P1
+				 	
+	short state[sD_2x4];	// QS10.5
+	// state of the process, X
+
+	short predictedState[sD_2x4];	// QS10.5
+	// predicted state of the process, X1
+
+	short measurement[mD_2x4*sD_2x4];	// QS16 (U8)
+	// measurement matrix (relating state to measurement), H
+
+	short processNoiseCov[sD_2x4*sD_2x4];	// QS13.2
+	// process noise covariance matrix, Q
+
+	short measurementNoiseCov[mD_2x4*mD_2x4];	// QS16
+	// measurement noise covariance matrix, R
+
+	short kalmanGain[sD_2x4*mD_2x4];	// QS0.15
+	// Kalman gain, K
+
+	short temp1[sD_2x4*sD_2x4];
+	short temp2[sD_2x4*sD_2x4];
+	short temp3[sD_2x4*sD_2x4];
+
+
+} VLIB_kalmanFilter_2x4;
+
+
+void VLIB_kalmanFilter_2x4_Predict
+(
+VLIB_kalmanFilter_2x4 * KF
+);
+
+void VLIB_kalmanFilter_2x4_Correct
+(
+VLIB_kalmanFilter_2x4 * KF, 
+short * restrict Z, 
+short * restrict Residual
+);
+
+#define mD_4x6 (4)
+#define sD_4x6 (6)
+
+typedef struct VLIB_kalmanFilter_4x6{
+
+
+	short transition[sD_4x6*sD_4x6];	
+	// state transition matrix, A
+
+	short errorCov[sD_4x6*sD_4x6];	
+	// a priori error covariance matrix, P
+
+	short predictedErrorCov[sD_4x6*sD_4x6];	
+	// predicted error covariance matrix, P1
+				 	
+	short state[sD_4x6];	
+	// state of the process, X
+
+	short predictedState[sD_4x6];	
+	// predicted state of the process, X1
+
+	short measurement[mD_4x6*sD_4x6];	
+	// measurement matrix (relating state to measurement), H
+
+	short processNoiseCov[sD_4x6*sD_4x6];	
+	// process noise covariance matrix, Q
+
+	short measurementNoiseCov[mD_4x6*mD_4x6];	
+	// measurement noise covariance matrix, R
+
+	short kalmanGain[sD_4x6*mD_4x6];	
+	// Kalman gain, K
+
+	short temp1[sD_4x6*sD_4x6];
+	short temp2[sD_4x6*sD_4x6];
+	short temp3[sD_4x6*sD_4x6];
+	int tempBuffers[mD_4x6*mD_4x6*2];
+
+	int scaleFactor;
+	// Scales the matrix M = (H*P1*H' + R) to ensure that its inverse
+	//	does not overflow 32 bits.
+	//	The scaling is done by right shifting each element of M by the 
+	//	quantity assigned to scaleFactor.
+	//	The computed inverse is then scaled back to ensure the correct result based on
+	//  the identity inv(M) = inv(M/k)/k
+
+} VLIB_kalmanFilter_4x6;
+
+#pragma STRUCT_ALIGN(VLIB_kalmanFilter_4x6, 64);
+
+void matrixInverse_4x4
+(
+short* output, 
+short* source, 
+int* buffer, 
+short factor
+);
+
+void VLIB_kalmanFilter_4x6_Correct
+(
+VLIB_kalmanFilter_4x6 * KF, 
+short * restrict Z, 
+short * restrict Residual
+);
+	
+void VLIB_kalmanFilter_4x6_Predict
+(
+VLIB_kalmanFilter_4x6 * KF
+);	
+
+int VLIB_convertUYVYint_to_HSLpl
+(
+const unsigned char *yc,      
+int width,                    
+int pitch,                    
+int height,
+const short coeff[5],         
+const unsigned short div_table[510],
+unsigned short *restrict H,   
+unsigned char  *restrict S,   
+unsigned char  *restrict L    
+);
+
+int VLIB_convertUYVYint_to_LABpl
+(
+const unsigned char *yc,      
+int width,                    
+int pitch,                    
+int height,
+const short coeff[5],         
+float whitePoint[3],          	
+float  *restrict L,     
+float  *restrict a,     
+float  *restrict b      
+);
+
+
+int VLIB_convertUYVYint_to_RGBpl
+(
+const unsigned char *yc,     
+int width,                   
+int pitch,                   
+int height,
+const short coeff[5],        
+unsigned char *restrict r,   
+unsigned char *restrict g,   
+unsigned char *restrict b    
+);
+
+int VLIB_convertUYVYint_to_YUVpl
+(
+const unsigned char *yc,      
+int width,                    
+int pitch,                   
+int height,                  
+unsigned char *restrict y,   
+unsigned char *restrict cr,  
+unsigned char *restrict cb   
+);
+
+int VLIB_extractLumaFromUYUV
+(
+unsigned char* restrict pInUYVY, 
+unsigned short  inCols,
+unsigned short  inPitch,
+unsigned short  inRows,
+unsigned char* restrict pOutY
+);
+
+int VLIB_convertUYVYsemipl_to_YUVpl
+(
+const unsigned char *crcb,   
+int width,                   
+int pitch,                   
+int height,                  
+unsigned char *restrict cr,  
+unsigned char *restrict cb   
+);
+
+int VLIB_initUYVYint_to_LABpl_LUT
+(
+const int d,                 
+const short coeff[5],        
+const float whitePoint[3],   
+unsigned short *Lab          
+);
+
+
+int VLIB_convertUYVYint_to_LABpl_LUT
+(
+unsigned char * restrict yc,  
+int width,                    
+int pitch,                    
+int height,
+int d,
+unsigned short * restrict LabExt,           
+unsigned short * restrict L,
+unsigned short * restrict a,
+unsigned short * restrict b
+);
+
+int VLIB_convertUYVYpl_to_YUVint
+(
+const unsigned char *restrict y,    
+const unsigned char *restrict cr,   
+const unsigned char *restrict cb,   
+int width,                          
+int pitch,                    
+int height,                   
+unsigned char *restrict yc          
+);
+
+
+void VLIB_simplex_3D
+(
+int (*func)(short[], void *), 
+short* restrict start,			
+short* restrict init_step,		
+int MaxIteration,
+int EPSILON, 					
+short* restrict v,				
+int* restrict f,				
+short* restrict vr,				
+short* restrict ve,				
+short* restrict vc,				
+short* restrict vm,				
+void* addtlArgs,				
+short* restrict minPoint,		
+int* restrict minValue		   
+);
+                               
+void VLIB_simplex
+(
+int (*func)(short[], void *), 
+short* restrict start,			
+short* restrict init_step,		
+int N, 						
+short N_INV,					
+int MaxIteration,
+int EPSILON, 					
+short* restrict v,				
+int* restrict f,				
+short* restrict vr,				
+short* restrict ve,				
+short* restrict vc,				
+short* restrict vm,				
+void* addtlArgs,				
+short* restrict minPoint,		
+int* restrict minValue			   
+);
+
+void VLIB_legendreMoments
+(
+const short* restrict Im, 
+short* restrict LMoments, 
+short* restrict LPoly,  
+const int Order,  
+const int ImH,
+const short Factor1
+);
+
+void VLIB_legendreMoments_Init
+(
+short* LPoly, 
+const int Order, 
+const int ImH, 
+short* Factor
+);
+
+void VLIB_normalFlow_16
+(
+short * imDiff,		
+short * Emag, 		
+short * Ex,			
+short * Ey,			
+short * LUT,		
+short T,			
+int numEls,		
+short * normalFlowU,
+short * normalFlowV
+);
+
+int VLIB_recursiveFilterHoriz1stOrderS16
+(
+short * out, 
+const short * in, 
+const int width,
+const int height,
+const short weight,
+const short * boundaryLeft,
+const short * boundaryRight,
+short * scratch
+);
+						   				   
+int VLIB_recursiveFilterVert1stOrderS16
+(
+short *out, 
+const short *in, 
+const int width,
+const int height,
+const short weight,
+const short * boundaryTop,
+const short * boundaryBottom,
+short * scratch
+);
+						   		 
+int VLIB_extract8bitBackgroundS16
+(
+const short * restrict BGmodel, 
+unsigned char * restrict BGimage,
+const unsigned int pixelCount
+);
+							    
+int VLIB_unpackMask32
+(
+const unsigned int * restrict mask32packed, 
+unsigned char * restrict maskImage,
+const unsigned int pixelCount
+);
+					
+int VLIB_packMask32
+(
+const unsigned char * restrict maskImage,
+unsigned int * restrict mask32packed, 
+const unsigned int pixelCount
+);
+			  	  
+int VLIB_L1DistanceS16
+( 
+short* restrict X,
+short* restrict Y, 
+int d,
+unsigned int* restrict L1D 
+);
+
+int VLIB_disparity_SAD_firstRow
+(
+const unsigned char *restrict pLeft,
+const unsigned char *restrict pRight,
+unsigned short *restrict pCost, 
+unsigned short *restrict pMinCost, 
+unsigned char *restrict pScratch, 
+char *restrict pDisparity,  
+int displacement, 
+int width, 
+int pitch,
+int windowSize
+);
+
+int VLIB_disparity_SAD
+(
+const unsigned char *restrict pLeft,
+const unsigned char *restrict pRight,
+unsigned short *restrict pCost, 
+unsigned short *restrict pMinCost, 
+char *restrict pDisparity,  
+int displacement, 
+int width, 
+int pitch,
+int windowSize
+);
+
+int VLIB_disparity_SAD16
+(
+const unsigned short *restrict pLeft,
+const unsigned short *restrict pRight,
+unsigned short *restrict pCost, 
+unsigned short *restrict pMinCost, 
+char *restrict pDisparity,  
+int displacement, 
+int width, 
+int pitch,
+int windowSize
+);
+
+int VLIB_disparity_SAD_firstRow16
+(
+const unsigned short *restrict pLeft,
+const unsigned short *restrict pRight,
+unsigned short *restrict pCost, 
+unsigned short *restrict minCost, 
+unsigned short *restrict pScratch, 
+char *restrict pDisparity,  
+int displacement, 
+int width, 
+int pitch,
+int windowSize
+);
+
+#endif
+
+
diff -uNr c6accel_1_00_00_04_async0/dsp/libs/ReadME.txt c6accel_1_00_00_04_async/dsp/libs/ReadME.txt
--- c6accel_1_00_00_04_async0/dsp/libs/ReadME.txt	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/dsp/libs/ReadME.txt	2010-08-14 17:17:18.000000000 -0500
@@ -13,6 +13,8 @@
 
 * C64P_LIBPLUS :
    This library contains library kernel that currently not part of standard offerings and is included to provide additional functionalities 
-   with C6Accel.                        
+   with C6Accel.   
+
+* VLIB_V_2_1 DSP Vision Library Release version 2.1 ( Added by Pramod Poudel)                   
 
-The include directory contains header files corresponding to the functions contained in these versions of the libraries. 
\ No newline at end of file
+The include directory contains header files corresponding to the functions contained in these versions of the libraries. 
Binary files c6accel_1_00_00_04_async0/dsp/libs/vlib.l64p and c6accel_1_00_00_04_async/dsp/libs/vlib.l64p differ
diff -uNr c6accel_1_00_00_04_async0/Makefile c6accel_1_00_00_04_async/Makefile
--- c6accel_1_00_00_04_async0/Makefile	2010-07-26 16:18:35.000000000 -0500
+++ c6accel_1_00_00_04_async/Makefile	2010-08-14 17:17:19.000000000 -0500
@@ -1,165 +1,24 @@
 include Rules.make
 
-COMPONENTS:=$(DMAI_INSTALL_DIR) $(LPM_INSTALL_DIR) $(LINK_INSTALL_DIR) $(XDAIS_INSTALL_DIR) $(CMEM_INSTALL_DIR) $(FC_INSTALL_DIR) $(CE_INSTALL_DIR) $(XDC_INSTALL_DIR) $(BIOSUTILS_INSTALL_DIR) $(BIOS_INSTALL_DIR) $(CODEC_INSTALL_DIR)
+.PHONY:	all clean c6accel c6accels_clean install
 
-REPOSITORIES:=$(addsuffix /packages, $(COMPONENTS))
+all:
+	$(MAKE) -C dsp
+	$(MAKE) -C soc
+
+clean:
+	$(MAKE) -C dsp clean
+	$(MAKE) -C soc clean
 
-CHECKLIST:=$(REPOSITORIES) $(CODEGEN_INSTALL_DIR)/bin/cl6x $(MVTOOL_PREFIX)gcc $(LINUXKERNEL_INSTALL_DIR)/Documentation $(DEMO_INSTALL_DIR)/$(PLATFORM) $(UBOOT_INSTALL_DIR)/doc
-
-.PHONY:	all clean  c6accel c6accel_clean install
-
-#==============================================================================
-# Set up platform dependent variables.
-#==============================================================================
-ifeq ($(PLATFORM),dm6446)
-LINUXKERNEL_CONFIG=davinci_dm644x_defconfig
-LINUXSAMPLES_PLATFORM=dm644x
-DSPLINK_CONFIG=--platform=DAVINCI --nodsp=1 --dspcfg_0=DM6446GEMSHMEM --dspos_0=DSPBIOS5XX --gppos=MVL5G --comps=ponslrm
-DSPLINK_MODULE=$(LINK_INSTALL_DIR)/packages/dsplink/gpp/export/BIN/Linux/DAVINCI/RELEASE/dsplinkk.ko
-else
-ifeq ($(PLATFORM),dm6467)
-LINUXKERNEL_CONFIG=davinci_dm6467_defconfig
-LINUXSAMPLES_PLATFORM=dm646x
-DSPLINK_CONFIG=--platform=DAVINCIHD --nodsp=1 --dspcfg_0=DM6467GEMSHMEM --dspos_0=DSPBIOS5XX --gppos=MVL5G --comps=ponslrm
-DSPLINK_MODULE=$(LINK_INSTALL_DIR)/packages/dsplink/gpp/export/BIN/Linux/DAVINCIHD/RELEASE/dsplinkk.ko
-else
-ifeq ($(PLATFORM),omap3530)
-LINUXKERNEL_CONFIG=omap3_evm_defconfig
-UBOOT_CONFIG=omap3_evm_config
-LINUXSAMPLES_PLATFORM=omap3530
-DSPLINK_CONFIG=--platform=OMAP3530 --nodsp=1 --dspcfg_0=OMAP3530SHMEM --dspos_0=DSPBIOS5XX --gppos=OMAPLSP --comps=ponslrmc
-DSPLINK_MODULE=$(LINK_INSTALL_DIR)/packages/dsplink/gpp/export/BIN/Linux/OMAP3530/RELEASE/dsplinkk.ko
-else
-ifeq ($(PLATFORM),dm355)
-LINUXKERNEL_CONFIG=davinci_dm355_defconfig
-LINUXSAMPLES_PLATFORM=dm355
-else
-ifeq ($(PLATFORM),omapl138)
-LINUXKERNEL_CONFIG=da850_omapl138_defconfig
-LINUXSAMPLES_PLATFORM=
-DSPLINK_CONFIG= --platform=OMAPL138 --nodsp=1 --dspcfg_0=OMAPL138GEMSHMEM --dspos_0=DSPBIOS5XX --gppos=ARM --comps=ponslrmc --DspTskMode=1
-DSPLINK_MODULE=$(LINK_INSTALL_DIR)/dsplink/gpp/export/BIN/Linux/OMAPL138/RELEASE/dsplinkk.ko
-else
-	$(error PLATFORM not set correctly: $(PLATFORM))
-endif
-endif
-endif
-endif
-
-#==============================================================================
-# The default build target.
-#==============================================================================
-all:	c6accel
-
-#==============================================================================
-# Clean up the targets built by 'make all'.
-#==============================================================================
-clean:	c6accel_clean 
-#==============================================================================
-# Build everything rebuildable.
-#==============================================================================
-everything: all
-
-#==============================================================================
-# Clean up all targets.
-#==============================================================================
-clobber:    clean
+install:
+	$(MAKE) -C dsp install
+	$(MAKE) -C soc install
 
-#==============================================================================
-# A help message target.
-#==============================================================================
 help:
 	@echo
 	@echo "Available build targets are:"
 	@echo
-	@echo "    all             : Build the components below"
-	@echo "    clean           : Remove files generated by the 'all' target"
-	@echo
-	@echo "    c6accel         : Build c6accel codec servers for $(PLATFORM)"
-	@echo "    c6accel_clean   : Remove generated codec server files"
-	@echo
-	@echo
-	@echo "    install         : Install binaries to $(EXEC_DIR)"
-	@echo
-
-#==============================================================================
-# Target for listing information about the DVSDK components.
-#==============================================================================
-info:	check
-	@LINUXKERNEL_INSTALL_DIR="$(LINUXKERNEL_INSTALL_DIR)" CODEGEN_INSTALL_DIR="$(CODEGEN_INSTALL_DIR)" GCC_PREFIX="$(MVTOOL_PREFIX)" XDC_INSTALL_DIR="$(XDC_INSTALL_DIR)" REPOSITORIES="$(REPOSITORIES)" $(DVSDK_INSTALL_DIR)/bin/info.sh 
-
-#==============================================================================
-# Target for checking that the Rules.make file is set up properly.
-#==============================================================================
-check:
-	@CHECKLIST="$(CHECKLIST)" $(DVSDK_INSTALL_DIR)/bin/check.sh
-
-
-#==============================================================================
-# Build the codec servers for the configured platform. Also, an
-# explicit cleanup target is defined.
-#==============================================================================
-c6accel:
-ifneq ($(PLATFORM),dm355)
-	$(MAKE) -C $(C6ACCEL_INSTALL_DIR)/../dsp DVSDK_INSTALL_DIR=$(DVSDK_INSTALL_DIR) BIOS_INSTALL_DIR=$(BIOS_INSTALL_DIR) XDC_INSTALL_DIR=$(XDC_INSTALL_DIR) CE_INSTALL_DIR=$(CE_INSTALL_DIR) FC_INSTALL_DIR=$(FC_INSTALL_DIR) CMEM_INSTALL_DIR=$(CMEM_INSTALL_DIR) CODEC_INSTALL_DIR=$(CODEC_INSTALL_DIR) BIOSUTILS_INSTALL_DIR=$(BIOSUTILS_INSTALL_DIR) XDAIS_INSTALL_DIR=$(XDAIS_INSTALL_DIR) LINK_INSTALL_DIR=$(LINK_INSTALL_DIR) PLATFORM_XDC=$(PLATFORM_XDC) XDCARGS=\"prod\"
-	$(MAKE) -C $(C6ACCEL_INSTALL_DIR) DVSDK_INSTALL_DIR=$(DVSDK_INSTALL_DIR) BIOS_INSTALL_DIR=$(BIOS_INSTALL_DIR) XDC_INSTALL_DIR=$(XDC_INSTALL_DIR) CE_INSTALL_DIR=$(CE_INSTALL_DIR) FC_INSTALL_DIR=$(FC_INSTALL_DIR) CMEM_INSTALL_DIR=$(CMEM_INSTALL_DIR) CODEC_INSTALL_DIR=$(CODEC_INSTALL_DIR) BIOSUTILS_INSTALL_DIR=$(BIOSUTILS_INSTALL_DIR) XDAIS_INSTALL_DIR=$(XDAIS_INSTALL_DIR) LINK_INSTALL_DIR=$(LINK_INSTALL_DIR) PLATFORM_XDC=$(PLATFORM_XDC) XDCARGS=\"prod\"
-endif
-
-c6accel_clean:
-ifneq ($(PLATFORM),dm355)
-	$(MAKE) -C $(C6ACCEL_INSTALL_DIR)/../dsp DVSDK_INSTALL_DIR=$(DVSDK_INSTALL_DIR) BIOS_INSTALL_DIR=$(BIOS_INSTALL_DIR) XDC_INSTALL_DIR=$(XDC_INSTALL_DIR) CE_INSTALL_DIR=$(CE_INSTALL_DIR) FC_INSTALL_DIR=$(FC_INSTALL_DIR) CMEM_INSTALL_DIR=$(CMEM_INSTALL_DIR) CODEC_INSTALL_DIR=$(CODEC_INSTALL_DIR) BIOSUTILS_INSTALL_DIR=$(BIOSUTILS_INSTALL_DIR) XDAIS_INSTALL_DIR=$(XDAIS_INSTALL_DIR) LINK_INSTALL_DIR=$(LINK_INSTALL_DIR) PLATFORM_XDC=$(PLATFORM_XDC) XDCARGS=\"prod\" clean
-	$(MAKE) -C $(C6ACCEL_INSTALL_DIR) DVSDK_INSTALL_DIR=$(DVSDK_INSTALL_DIR) BIOS_INSTALL_DIR=$(BIOS_INSTALL_DIR) XDC_INSTALL_DIR=$(XDC_INSTALL_DIR) CE_INSTALL_DIR=$(CE_INSTALL_DIR) FC_INSTALL_DIR=$(FC_INSTALL_DIR) CMEM_INSTALL_DIR=$(CMEM_INSTALL_DIR) CODEC_INSTALL_DIR=$(CODEC_INSTALL_DIR) BIOSUTILS_INSTALL_DIR=$(BIOSUTILS_INSTALL_DIR) XDAIS_INSTALL_DIR=$(XDAIS_INSTALL_DIR) LINK_INSTALL_DIR=$(LINK_INSTALL_DIR) PLATFORM_XDC=$(PLATFORM_XDC) XDCARGS=\"prod\" clean
-endif
-
-
-#==============================================================================
-# Install the built binaries to the target file system.
-#==============================================================================
-install:
-	@echo
-	@echo Creating $(EXEC_DIR_C6ACCEL)
-	@mkdir -p $(EXEC_DIR_C6ACCEL)
-	@mkdir -p $(EXEC_DIR_C6ACCEL)/test_files
-
-
-ifeq ($(PLATFORM),omap3530)
-	@echo
-	@echo Copying kernel modules to target file system: $(EXEC_DIR_C6ACCEL)/
-	@echo Copying cmemk.ko
-	@install -m 755 $(CMEM_INSTALL_DIR)/packages/ti/sdo/linuxutils/cmem/src/module/cmemk.ko $(EXEC_DIR_C6ACCEL)/
-	@echo Copying dsplinkk.ko
-	@install -m 755 $(LINK_INSTALL_DIR)/dsplink/gpp/export/BIN/Linux/OMAP3530/RELEASE/dsplinkk.ko $(EXEC_DIR_C6ACCEL)/
-	@echo Copying lpm_omap3530.ko
-	@install -m 755 $(LPM_INSTALL_DIR)/packages/ti/bios/power/modules/omap3530/lpm/lpm_omap3530.ko $(EXEC_DIR_C6ACCEL)/
-	@echo Copying sdmak.ko
-	@install -m 755 $(CMEM_INSTALL_DIR)/packages/ti/sdo/linuxutils/sdma/src/module/sdmak.ko $(EXEC_DIR_C6ACCEL)/
-	@echo Copying c6accel codec servers from $(C6ACCEL_INSTALL_DIR)
-	@install -m 755 $(C6ACCEL_INSTALL_DIR)/packages/ti/c6accel_unitservers/omap3530/c6accel_omap3530.x64P $(EXEC_DIR_C6ACCEL)/
-	@echo Copying c6accel test app from $(C6ACCEL_INSTALL_DIR)
-	@install -m 755 $(C6ACCEL_INSTALL_DIR)/app/c6accel_app $(EXEC_DIR_C6ACCEL)/
-	@echo Copying testfile from $(C6ACCEL_INSTALL_DIR)
-	@install -m 755 $(C6ACCEL_INSTALL_DIR)/app/test_files/* $(EXEC_DIR_C6ACCEL)/test_files
-	@chmod -x $(EXEC_DIR_C6ACCEL)/*.x64P $(EXEC_DIR_C6ACCEL)/*.ko 
-	@chmod +x $(EXEC_DIR_C6ACCEL)/c6accel_app
-	@install -m 755 $(C6ACCEL_INSTALL_DIR)/app/omap3530/loadmodules_omap3530_c6accel.sh $(EXEC_DIR_C6ACCEL)
-	@chmod +x $(EXEC_DIR_C6ACCEL)/loadmodules_omap3530_c6accel.sh
-endif
-ifeq ($(PLATFORM),omapl138)
+	@echo "    all		   : Build c6accel"
+	@echo "    clean	   : Remove files generated by the 'all' target"
+	@echo "    install	   : Install generated binaries to $(EXEC_DIR)"
 	@echo
-	@echo Copying kernel modules to target file system: $(EXEC_DIR_C6ACCEL)/
-	@echo Copying cmemk.ko
-	@install -m 755 $(CMEM_INSTALL_DIR)/packages/ti/sdo/linuxutils/cmem/src/module/cmemk.ko $(EXEC_DIR_C6ACCEL)/
-	@echo Copying dsplinkk.ko
-	@install -m 755 $(LINK_INSTALL_DIR)/dsplink/gpp/export/BIN/Linux/OMAPL138/RELEASE/dsplinkk.ko $(EXEC_DIR_C6ACCEL)/
-	@echo Copying c6accel codec servers from $(C6ACCEL_INSTALL_DIR)
-	@install -m 755 $(C6ACCEL_INSTALL_DIR)/packages/ti/c6accel_unitservers/omapl138/c6accel_omapl138.x674 $(EXEC_DIR_C6ACCEL)/
-	@echo Copying c6accel test app from $(C6ACCEL_INSTALL_DIR)
-	@install -m 755 $(C6ACCEL_INSTALL_DIR)/app/c6accel_app $(EXEC_DIR_C6ACCEL)/
-	@echo Copying testfile from $(C6ACCEL_INSTALL_DIR)
-	@install -m 755 $(C6ACCEL_INSTALL_DIR)/app/test_files/* $(EXEC_DIR_C6ACCEL)/test_files
-	@chmod -x $(EXEC_DIR_C6ACCEL)/*.x674 $(EXEC_DIR_C6ACCEL)/*.ko 
-	@chmod +x $(EXEC_DIR_C6ACCEL)/c6accel_app
-	@install -m 755 $(C6ACCEL_INSTALL_DIR)/app/omapl138/loadmodules_omapl138_c6accel.sh $(EXEC_DIR_C6ACCEL)
-	@chmod +x $(EXEC_DIR_C6ACCEL)/loadmodules_omapl138_c6accel.sh
-endif
-endif
diff -uNr c6accel_1_00_00_04_async0/Rules.make c6accel_1_00_00_04_async/Rules.make
--- c6accel_1_00_00_04_async0/Rules.make	2010-07-28 06:08:34.000000000 -0500
+++ c6accel_1_00_00_04_async/Rules.make	2010-08-14 17:17:19.000000000 -0500
@@ -8,44 +8,42 @@
 #
 
 # Define target platform.
-PLATFORM=omapl138
+PLATFORM=omap3530
 
 ifeq ($(PLATFORM),omapl138)
 # Where the DVSDK is installed.
-DVSDK_INSTALL_DIR  	= /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138
+DVSDK_INSTALL_DIR=$(HOME)/OMAP-L138_arm_1_00_00_11
 
 # Where the Codec Engine package is installed.
-CE_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/codec-engine_2_25_02_11
+CE_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/codec_engine_2_25_00_05
 
 # Where the XDAIS package is installed.
-XDAIS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdais_6_25_02_11
+XDAIS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdais_6_25_01_08
 
 # Where the DSP Link package is installed.
-LINK_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dsplink_1_65_00_02
+LINK_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dsplink_linux_1_65_00_02
 
 # Where the CMEM (contiguous memory allocator) package is installed.
-CMEM_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/linuxutils_2_25_02_08
+CMEM_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/linuxutils_2_25_01_06
 
 # Where the EDMA3 Low Level Driver is installed.
-EDMA3_LLD_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/edma3lld_01_11_00_03
+EDMA3_LLD_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/REL_EDMA3_LLD_BIOS5_01_11_00_03
 
 # Where the TI C6x codegen tool is installed.
-CODEGEN_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/cgt6x_6_1_14
+CODEGEN_INSTALL_DIR=$(HOME)/TI_CGT_C6000_6.1.9
 
 # Where the RTSC tools package is installed.
-XDC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdctools_3_16_03_36
+XDC_INSTALL_DIR=$(HOME)/xdctools_3_16_01_27
 
 # Where Framework Components product is installed.
-FC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/framework-components_2_25_01_05
+FC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/framework_components_2_25_00_04
 
 # Where DSP/BIOS is installed.
-BIOS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dspbios_5_41_03_17
+BIOS_INSTALL_DIR=$(HOME)/bios_5_41_02_14/
 
 # Where biosutils package is installed.
 BIOSUTILS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/biosutils_1_02_02
 
-SERVER_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/codecs-omapl138_1_10_00_01
-
 # RTSC platform
 PLATFORM_XDC = ti.platforms.evmOMAPL138
 
@@ -56,42 +54,9 @@
 DSP_ISA = 674
 
 else
-
-# Where the DVSDK is installed.
-DVSDK_INSTALL_DIR=$(HOME)/ti-dvsdk_dm3730-am3715-evm_4_00_07142010
-
-# Where the Codec Engine package is installed.
-CE_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/codec-engine_2_25_02_11
-
-# Where the XDAIS package is installed.
-XDAIS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdais_6_25_02_11
-
-# Where the DSP Link package is installed.
-LINK_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dsplink_1_65_00_02
-
-# Where the CMEM (contiguous memory allocator) package is installed.
-CMEM_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/linuxutils_2_25_02_08
-
-# Where the EDMA3 Low Level Driver is installed.
-EDMA3_LLD_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/edma3_lld_01_11_00_03
-
-# Where the TI C6x codegen tool is installed.
-CODEGEN_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/cgt6x_6_1_14
-
-# Where the RTSC tools package is installed.
-XDC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdctools_3_16_03_36
-
-# Where Framework Components product is installed.
-FC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/framework-components_2_25_01_05
-
-# Where DSP/BIOS is installed.
-BIOS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dspbios_5_41_03_17
-
-# Where biosutils package is installed.
-BIOSUTILS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/biosutils_1_02_02
-
-# Where the local power manager is installed.
-LPM_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/local-power-manager_1_24_02_09
+
+#inhirit Rules.make from base dir
+include $(PACKAGE_DIR)/Rules.make
 
 # RTSC platform
 PLATFORM_XDC = ti.platforms.evm3530
@@ -104,18 +69,22 @@
 
 endif
 
-C6ACCEL_INSTALL_DIR=  $(DVSDK_INSTALL_DIR)/c6accel_1_00_00_04_async/soc
+# Where C6ACCEL package is installed 
+#C6ACCEL_INSTALL_DIR=  = $(DVSDK_INSTALL_DIR)/c6accel_1_00_00_01/soc
+C6ACCEL_INSTALL_DIR=$(SERVER_DIR)/..
 
 # The prefix to be added before the GNU compiler tools (optionally including
 # path), i.e. "arm_v5t_le-" or "/opt/bin/arm_v5t_le-".
-CSTOOL_DIR=/data/opt/vendors/codesourcery/lite/arm-2009q1-203
-CSTOOL_PREFIX=$(CSTOOL_DIR)/bin/arm-none-linux-gnueabi-
-MVTOOL_PREFIX=$(CSTOOL_PREFIX)
+#CSTOOL_DIR=$(HOME)/arm-2009q1/
+#CSTOOL_DIR=/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/i686-linux/usr
+#CSTOOL_PREFIX=$(CSTOOL_DIR)/bin/arm-none-linux-gnueabi-
+CSTOOL_PREFIX=$(CROSS_COMPILE)
+MVTOOL_PREFIX=$(CSTOOL_PREFIX)
+
 
 # Where to copy the resulting executables and data to (when executing 'make
 # install') in a proper file structure. This EXEC_DIR should either be visible
 # from the target, or you will have to copy this (whole) directory onto the
 # target filesystem.
-EXEC_DIR                   = /data/filesys/iain/arago-l138/home/root
-EXEC_DIR_C6ACCEL = $(EXEC_DIR)/c6accel
-
+#EXEC_DIR=$(HOME)/c6accel/$(PLATFORM)
+EXEC_DIR=/home/jars/beagleboard/c6accel
diff -uNr c6accel_1_00_00_04_async0/Rules.make~ c6accel_1_00_00_04_async/Rules.make~
--- c6accel_1_00_00_04_async0/Rules.make~	2010-07-28 05:13:31.000000000 -0500
+++ c6accel_1_00_00_04_async/Rules.make~	1969-12-31 18:00:00.000000000 -0600
@@ -1,121 +0,0 @@
-#
-#  ======== Rules.make ========
-#  This file specified variables used by the makefiles. After editing this file
-#  you should not have to modify any of Makefiles to build this product.
-#
-#  The DVSDK_INSTALL_DIR variable is a local support variable only used in
-#  this file and does not need to be set if individual components are used.
-#
-
-# Define target platform.
-PLATFORM=omapl138
-
-ifeq ($(PLATFORM),omapl138)
-# Where the DVSDK is installed.
-DVSDK_INSTALL_DIR  	= /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138
-
-# Where the Codec Engine package is installed.
-CE_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/codec-engine_2_25_02_11
-
-# Where the XDAIS package is installed.
-XDAIS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdais_6_25_02_11
-
-# Where the DSP Link package is installed.
-LINK_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dsplink_1_65_00_02
-
-# Where the CMEM (contiguous memory allocator) package is installed.
-CMEM_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/linuxutils_2_25_02_08
-
-# Where the EDMA3 Low Level Driver is installed.
-EDMA3_LLD_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/edma3lld_01_11_00_03
-
-# Where the TI C6x codegen tool is installed.
-CODEGEN_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/cgt6x_6_1_14
-
-# Where the RTSC tools package is installed.
-XDC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdctools_3_16_03_36
-
-# Where Framework Components product is installed.
-FC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/framework-components_2_25_01_05
-
-# Where DSP/BIOS is installed.
-BIOS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dspbios_5_41_03_17
-
-# Where biosutils package is installed.
-BIOSUTILS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/biosutils_1_02_02
-
-SERVER_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/codecs-omapl138_1_10_00_01
-
-# RTSC platform
-PLATFORM_XDC = ti.platforms.evmOMAPL138
-
-# ARM Instruction set
-ARM_ISA = armv5t
-
-# DSP Instruction set
-DSP_ISA = 674
-
-else
-
-# Where the DVSDK is installed.
-DVSDK_INSTALL_DIR=$(HOME)/ti-dvsdk_dm3730-am3715-evm_4_00_07142010
-
-# Where the Codec Engine package is installed.
-CE_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/codec-engine_2_25_02_11
-
-# Where the XDAIS package is installed.
-XDAIS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdais_6_25_02_11
-
-# Where the DSP Link package is installed.
-LINK_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dsplink_1_65_00_02
-
-# Where the CMEM (contiguous memory allocator) package is installed.
-CMEM_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/linuxutils_2_25_02_08
-
-# Where the EDMA3 Low Level Driver is installed.
-EDMA3_LLD_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/edma3_lld_01_11_00_03
-
-# Where the TI C6x codegen tool is installed.
-CODEGEN_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/cgt6x_6_1_14
-
-# Where the RTSC tools package is installed.
-XDC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/xdctools_3_16_03_36
-
-# Where Framework Components product is installed.
-FC_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/framework-components_2_25_01_05
-
-# Where DSP/BIOS is installed.
-BIOS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/dspbios_5_41_03_17
-
-# Where biosutils package is installed.
-BIOSUTILS_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/biosutils_1_02_02
-
-# Where the local power manager is installed.
-LPM_INSTALL_DIR=$(DVSDK_INSTALL_DIR)/local-power-manager_1_24_02_09
-
-# RTSC platform
-PLATFORM_XDC = ti.platforms.evm3530
-
-# ARM Instruction set
-ARM_ISA = armv7-a
-
-# DSP Instruction set
-DSP_ISA = 64P
-
-endif
-
-C6ACCEL_INSTALL_DIR=  $(DVSDK_INSTALL_DIR)/c6accel_1_00_00_04/soc
-
-# The prefix to be added before the GNU compiler tools (optionally including
-# path), i.e. "arm_v5t_le-" or "/opt/bin/arm_v5t_le-".
-CSTOOL_DIR=/data/opt/vendors/codesourcery/lite/arm-2009q1-203
-CSTOOL_PREFIX=$(CSTOOL_DIR)/bin/arm-none-linux-gnueabi-
-MVTOOL_PREFIX=$(CSTOOL_PREFIX)
-
-# Where to copy the resulting executables and data to (when executing 'make
-# install') in a proper file structure. This EXEC_DIR should either be visible
-# from the target, or you will have to copy this (whole) directory onto the
-# target filesystem.
-EXEC_DIR                   = /data/filesys/iain/arago-l138/home/root
-EXEC_DIR_C6ACCEL = $(EXEC_DIR)/c6accel
-
diff -uNr c6accel_1_00_00_04_async0/soc/app/Makefile c6accel_1_00_00_04_async/soc/app/Makefile
--- c6accel_1_00_00_04_async0/soc/app/Makefile	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/app/Makefile	2010-08-14 17:17:15.000000000 -0500
@@ -27,9 +27,9 @@
 # Target tools
 XDC_TARGET	= gnu.targets.arm.GCArmv5T
 
-CROSS_COMPILE	= $(CSTOOL_PREFIX)
+#CROSS_COMPILE	= $(CSTOOL_PREFIX)
 
-export CROSS_COMPILE
+#export CROSS_COMPILE
 export CODEGEN_INSTALL_DIR
 export XDCPATH
 export PLATFORM_XDC
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw.c c6accel_1_00_00_04_async/soc/c6accelw/c6accelw.c
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw.c	2010-07-29 10:02:14.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw.c	2010-08-15 23:03:16.000000000 -0500
@@ -2881,10 +2881,131 @@
     return status;
 
 }
+
+/* This function defination is added by Pramod */
+/*
+int C6ACCEL_IMG_sobel_3x3_8_16(C6accel_Handle hC6accel, const unsigned char *in_data, unsigned short *out_data, short cols, short rows)
+Arguments
+* hC6accel C6accel Handle
+* in_data[ ] Input image of size cols * rows.
+* out_data[ ] Output image of size cols * (rows-2).
+* cols Number of columns in the input image. Must be multiple of 2.
+* rows Number of rows in the input image. cols * (rows-2) must be multiple of 8.
+
+Return value:  API returns status of the function call.
+               ==1 Pass
+               <0  Fail
+
+Description This routine applies horizontal and vertical Sobel edge detection masks to the input image and
+produces an output image which is two rows shorter than the input image.Within each row of the output,
+the first and the last pixel will not contain meaningful results.
+
+*/
+int C6accel_IMG_sobel_3x3_8_16
+(   C6accel_Handle hC6accel,
+    const unsigned char *restrict in,   /* Input image data   */
+    unsigned short       *restrict out,  /* Output image data  */
+    short cols, short rows              /* Image dimensions   */
+#ifdef SUPPORT_ASYNC
+    ,E_CALL_TYPE callType
+#endif
+)
+{
+    XDM1_BufDesc                inBufDesc;
+    XDM1_BufDesc                outBufDesc;
+    XDAS_Int32                  InArg_Buf_size;
+    IC6Accel_InArgs             *CInArgs;
+    UNIVERSAL_OutArgs           uniOutArgs;
+    int status;
+    /* Define pointer to function parameter structure */
+    IMG_sobel_3x3_8_16_Params      *fp0;
+    XDAS_Int8 *pAlloc;
+
+    ACQUIRE_CODEC_ENGINE;
+
+    /* Allocate the InArgs structure as it varies in size
+    (Needs to be changed everytime we make a API call)*/
+    InArg_Buf_size=  sizeof(Fxn_struct)+
+                     sizeof(IMG_sobel_3x3_8_16_Params)+
+                     sizeof(CInArgs->size)+
+                     sizeof(CInArgs->Num_fxns);
+
+    /* Request contiguous heap memory allocation for the extended input structure */
+    pAlloc = (XDAS_Int8 *)Memory_alloc(InArg_Buf_size, &wrapperMemParams);
+    CInArgs= (IC6Accel_InArgs *)pAlloc;
+
+    /* Initialize .size fields for dummy input and output arguments */
+    uniOutArgs.size = sizeof(uniOutArgs);
+
+    /* Set up buffers to pass buffers in and out to alg  */
+    inBufDesc.numBufs = 1;
+    outBufDesc.numBufs = 1;
+
+    /* Fill in input/output buffer descriptor parameters and manage ARM cache*/
+    /* See wrapper_c6accel_i.h for more details of operation                 */
+    CACHE_WB_INV_INPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(in,0,cols * rows*sizeof(char));
+    CACHE_INV_OUTPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(out,0,cols * rows*sizeof(short));
+
+     /* Initialize the extended InArgs structure */
+    CInArgs->Num_fxns=1;
+    CInArgs->size= InArg_Buf_size;
+
+    /* Set function Id and parameter pointers for first function call */
+    CInArgs->fxn[0].FxnID= IMG_SOBEL_3X3_8_16_FXN_ID;
+    CInArgs->fxn[0].Param_ptr_offset=sizeof(CInArgs->size)+sizeof(CInArgs->Num_fxns)+sizeof(Fxn_struct);
+
+    /* Initialize pointers to function parameters */
+    fp0 = (IMG_sobel_3x3_8_16_Params *)((XDAS_Int8*)CInArgs + CInArgs->fxn[0].Param_ptr_offset);
+
+    /* Fill in the fields in the parameter structure */
+    fp0->indata_InArrID1= INBUF0;
+    fp0->outdata_OutArrID1= OUTBUF0;
+    fp0->Col= cols;
+    fp0->Row= rows;
+
+#ifdef SUPPORT_ASYNC
+    /* Call the actual algorithm */
+    if (callType == ASYNC)
+      {
+
+       //Update async structure
+       if (c6accelAsyncParams.asyncCallCount!=0)
+          { status = UNIVERSAL_EFAIL;
+            printf("Async call failed as %d are still pending\n",c6accelAsyncParams.asyncCallCount);
+          }
+       else
+          {c6accelAsyncParams.asyncCallCount++;
+           memcpy(&(c6accelAsyncParams.inBufs),&inBufDesc, sizeof (XDM1_BufDesc));
+ //           memcpy(&(c6accelAsyncParams.inOutBufs),&inOutBufs, sizeof (XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.outBufs), &outBufDesc,sizeof(XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.inArgs), CInArgs,sizeof(UNIVERSAL_InArgs));
+           memcpy(&(c6accelAsyncParams.outArgs),&uniOutArgs,sizeof(UNIVERSAL_OutArgs));
+           c6accelAsyncParams.pBuf = pAlloc;
+           c6accelAsyncParams.pBufSize = InArg_Buf_size;
+
+           status = UNIVERSAL_processAsync(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+           }
+      }
+     else
+       {
+#endif
+         // Sync call
+        status = UNIVERSAL_process(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+        /* Free the InArgs structure */
+        Memory_free(pAlloc, InArg_Buf_size, &wrapperMemParams);
+#ifdef SUPPORT_ASYNC
+        }
+#endif 
+
+    RELEASE_CODEC_ENGINE;
+
+    return status;
+
+}
 
 
 /*
-int C6ACCEL_IMG_sobel_3x3_16(C6accel_Handle hC6accel,constant unsigned short *restrict 3x3 unsigned input in, unsigned short *restrict out, short cols, short rows)
+int C6ACCEL_IMG_sobel_3x3_16(C6accel_Handle hC6accel,constant unsigned short *restrict in, unsigned short *restrict out, short cols, short rows)
 
 Arguments
 * hC6accel C6accel Handle
@@ -10490,6 +10611,559 @@
     return status;  
 
 }
+
+
+/* This function defination is added by Pramod */
+/*
+void C6Accel_VLIB_integralImage8(C6accel_Handle hC6accel, unsigned char * restrict ptr_pIn, unsigned short inCols, unsigned short inRows, unsigned int * 												restrict ptr_pLastLine, unsigned int * restrict ptr_pOut)
+Arguments
+* hC6accel C6accel Handle
+* pIn[inColsxinRows] Pointer to inCols x inRows 8 bit Image.
+* inCols No of columns in image.
+* inRows No of rows in image
+* pLastLine[inColsx1] Pointer to complex 32-bit carry-over buffer.
+* pOut[inColsxinRows] Pointer to complex 32-bit output integral image.
+
+Return value:  API returns status of the function call.
+               ==1 Pass
+               <0  Fail
+
+Object classification may be done by calculating image features (such as moments and/or wavelets) on a
+region of interest and feeding them to a classifier (such as k-NN or SVM). Integral image is an important
+step in calculation of a common type of image features, over-complete Haar wavelets [ 2 ]. Integral image
+values may be used as features themselves.
+
+
+Special Requirements
+
+The arguments pIn, pOut, and pLastLine must be 64-bit aligned. For the fixed-width version the width is
+assumed to be 640 pixels.
+* pIn is a pointer to an (inCols  inRows) array of unsigned char data.
+* pLastLine is a pointer to an (inCols  1) array of unsigned int data.
+* pOut is a pointer to an (inCols  inRows) array of unsigned int data.
+
+*/
+
+int C6accel_VLIB_integralImage8(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_pIn,             /* array of unsigned char data       */
+                          unsigned short inCols,                        /* number of columns                 */
+			  unsigned short inRows,			/* number of rows                    */
+                          unsigned int * restrict ptr_pLastLine,        /* array of unsigned int data        */
+                          unsigned int * restrict ptr_pOut              /* array of unsigned int output data */
+#ifdef SUPPORT_ASYNC
+                          ,E_CALL_TYPE callType)
+#else 
+)
+#endif
+{
+    XDM1_BufDesc                inBufDesc;
+    XDM1_BufDesc                outBufDesc;
+    XDAS_Int32                  InArg_Buf_size;
+    IC6Accel_InArgs             *CInArgs;
+    UNIVERSAL_OutArgs           uniOutArgs;
+    Int                         status;
+
+    /* Define pointer to function parameter structure */
+    VLIB_integralImage8_Params  *fp0;
+    XDAS_Int8                   *pAlloc;
+
+    ACQUIRE_CODEC_ENGINE;
+
+    /* Allocate the InArgs structure as it varies in size
+    (Needs to be changed everytime we make a API call)*/
+    InArg_Buf_size=  sizeof(Fxn_struct)+
+                     sizeof(VLIB_integralImage8_Params)+
+                     sizeof(CInArgs->size)+
+                     sizeof(CInArgs->Num_fxns);
+
+    /* Request contiguous heap memory allocation for the extended input structure */
+    pAlloc = (XDAS_Int8 *)Memory_alloc(InArg_Buf_size, &wrapperMemParams);
+    CInArgs= (IC6Accel_InArgs *)pAlloc;
+
+    /* Initialize .size fields for dummy input and output arguments */
+    uniOutArgs.size    = sizeof(uniOutArgs);
+
+    /* Set up buffers to pass buffers in and out to alg  */
+    inBufDesc.numBufs  = 2;
+    outBufDesc.numBufs = 1;
+
+    /* Fill in input/output buffer descriptor parameters and manage ARM cache*/
+    /* See wrapper_c6accel_i.h for more details of operation                 */
+    CACHE_WB_INV_INPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(ptr_pIn,0,inCols*inRows*sizeof(char));
+    CACHE_WB_INV_INPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(ptr_pLastLine,1,inCols*sizeof(int));
+    CACHE_INV_OUTPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(ptr_pOut,0,inCols*inRows*sizeof(int));
+
+
+    /* Initialize the extended InArgs structure */
+    CInArgs->Num_fxns = 1;
+    CInArgs->size     = InArg_Buf_size;
+
+    /* Set function Id and parameter pointers for first function call */
+    CInArgs->fxn[0].FxnID     = VLIB_INTEGRALIMAGE_8_FXN_ID;
+    CInArgs->fxn[0].Param_ptr_offset = sizeof(CInArgs->size)+sizeof(CInArgs->Num_fxns)+sizeof(Fxn_struct);
+
+     /* Initialize pointers to function parameters */
+    fp0 = (VLIB_integralImage8_Params *)((XDAS_Int8*)CInArgs + CInArgs->fxn[0].Param_ptr_offset);
+
+    /* Fill in the fields in the parameter structure */
+    fp0->pIn_InArrID1        = INBUF0;
+    fp0->inCols              = inCols;
+    fp0->inRows              = inRows;
+    fp0->pLastLine_InArrID2  = INBUF1;
+    fp0->pOut_OutArrID1      = OUTBUF0;
+
+#ifdef SUPPORT_ASYNC
+    /* Call the actual algorithm */
+    if (callType == ASYNC)
+      {
+
+       //Update async structure
+       if (c6accelAsyncParams.asyncCallCount!=0)
+          { status = UNIVERSAL_EFAIL;
+            printf("Async call failed as %d are still pending\n",c6accelAsyncParams.asyncCallCount);
+          }
+       else
+          {c6accelAsyncParams.asyncCallCount++;
+           memcpy(&(c6accelAsyncParams.inBufs),&inBufDesc, sizeof (XDM1_BufDesc));
+ //           memcpy(&(c6accelAsyncParams.inOutBufs),&inOutBufs, sizeof (XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.outBufs), &outBufDesc,sizeof(XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.inArgs), CInArgs,sizeof(UNIVERSAL_InArgs));
+           memcpy(&(c6accelAsyncParams.outArgs),&uniOutArgs,sizeof(UNIVERSAL_OutArgs));
+           c6accelAsyncParams.pBuf = pAlloc;
+           c6accelAsyncParams.pBufSize = InArg_Buf_size;
+
+           status = UNIVERSAL_processAsync(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+           }
+      }
+     else
+       {
+#endif
+         // Sync call
+        status = UNIVERSAL_process(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+        /* Free the InArgs structure */
+        Memory_free(pAlloc, InArg_Buf_size, &wrapperMemParams);
+#ifdef SUPPORT_ASYNC
+        }
+#endif 
+
+    RELEASE_CODEC_ENGINE;
+
+    return status;
+
+}
+
+/* This function defination is added by Pramod */
+/*
+int C6accel_RGB_To_Y(C6accel_Handle hC6accel, unsigned char * restrict ptr_src, unsigned char * restrict ptr_dst, unsigned int count)
+Arguments
+* hC6accel C6accel Handle
+* ptr_src[ ] Input RGB image of count pixels.
+* ptr_dst[ ] Output Greyscale image of count pixels.
+* count Total pixel count.
+
+Return value:  API returns status of the function call.
+               ==1 Pass
+               <0  Fail
+
+Description This routine converts input RGB image to Greyscale Image using following formula
+
+  		Y = 0.299 * R + 0.587 * G + 0.114 * B
+
+
+*/
+int C6accel_RGB_To_Y(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_src,       /* Pointer to input image in RGB format */
+                          unsigned char * restrict ptr_dst,       /* Pointer to Greyscale output image    */
+			  unsigned int count			  /* Total number of pixels               */
+#ifdef SUPPORT_ASYNC
+                          ,E_CALL_TYPE callType)
+#else 
+)
+#endif
+
+{
+    XDM1_BufDesc                inBufDesc;
+    XDM1_BufDesc                outBufDesc;
+    XDAS_Int32                  InArg_Buf_size;
+    IC6Accel_InArgs             *CInArgs;
+    UNIVERSAL_OutArgs           uniOutArgs;
+    int status;
+    /* Define pointer to function parameter structure */
+    IMG_RGB_To_Y_Params      *fp0;
+    XDAS_Int8 *pAlloc;
+
+    ACQUIRE_CODEC_ENGINE;
+
+    /* Allocate the InArgs structure as it varies in size
+    (Needs to be changed everytime we make a API call)*/
+    InArg_Buf_size=  sizeof(Fxn_struct)+
+                     sizeof(IMG_RGB_To_Y_Params)+
+                     sizeof(CInArgs->size)+
+                     sizeof(CInArgs->Num_fxns);
+
+    /* Request contiguous heap memory allocation for the extended input structure */
+    pAlloc = (XDAS_Int8 *)Memory_alloc(InArg_Buf_size, &wrapperMemParams);
+    CInArgs= (IC6Accel_InArgs *)pAlloc;
+
+    /* Initialize .size fields for dummy input and output arguments */
+    uniOutArgs.size = sizeof(uniOutArgs);
+
+    /* Set up buffers to pass buffers in and out to alg  */
+    inBufDesc.numBufs = 1;
+    outBufDesc.numBufs = 1;
+
+    /* Fill in input/output buffer descriptor parameters and manage ARM cache*/
+    /* See wrapper_c6accel_i.h for more details of operation                 */
+    CACHE_WB_INV_INPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(ptr_src,0,3*count*sizeof(char));
+    CACHE_INV_OUTPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(ptr_dst,0,count*sizeof(short));
+
+     /* Initialize the extended InArgs structure */
+    CInArgs->Num_fxns=1;
+    CInArgs->size= InArg_Buf_size;
+
+    /* Set function Id and parameter pointers for first function call */
+    CInArgs->fxn[0].FxnID= IMG_RGB_TO_Y_FXN_ID;
+    CInArgs->fxn[0].Param_ptr_offset=sizeof(CInArgs->size)+sizeof(CInArgs->Num_fxns)+sizeof(Fxn_struct);
+
+    /* Initialize pointers to function parameters */
+    fp0 = (IMG_RGB_To_Y_Params *)((XDAS_Int8*)CInArgs + CInArgs->fxn[0].Param_ptr_offset);
+
+    /* Fill in the fields in the parameter structure */
+    fp0->src_InArrID1= INBUF0;
+    fp0->dst_OutArrID1= OUTBUF0;
+    fp0->count= count;
+
+#ifdef SUPPORT_ASYNC
+    /* Call the actual algorithm */
+    if (callType == ASYNC)
+      {
+
+       //Update async structure
+       if (c6accelAsyncParams.asyncCallCount!=0)
+          { status = UNIVERSAL_EFAIL;
+            printf("Async call failed as %d are still pending\n",c6accelAsyncParams.asyncCallCount);
+          }
+       else
+          {c6accelAsyncParams.asyncCallCount++;
+           memcpy(&(c6accelAsyncParams.inBufs),&inBufDesc, sizeof (XDM1_BufDesc));
+ //           memcpy(&(c6accelAsyncParams.inOutBufs),&inOutBufs, sizeof (XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.outBufs), &outBufDesc,sizeof(XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.inArgs), CInArgs,sizeof(UNIVERSAL_InArgs));
+           memcpy(&(c6accelAsyncParams.outArgs),&uniOutArgs,sizeof(UNIVERSAL_OutArgs));
+           c6accelAsyncParams.pBuf = pAlloc;
+           c6accelAsyncParams.pBufSize = InArg_Buf_size;
+
+           status = UNIVERSAL_processAsync(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+           }
+      }
+     else
+       {
+#endif
+         // Sync call
+        status = UNIVERSAL_process(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+        /* Free the InArgs structure */
+        Memory_free(pAlloc, InArg_Buf_size, &wrapperMemParams);
+#ifdef SUPPORT_ASYNC
+        }
+#endif 
+
+    RELEASE_CODEC_ENGINE;
+
+    return status;
+
+}
+
+
+/* This function defination is added by Pramod */
+/*
+int C6accel_RGB_To_Y_IMG_sobel_3x3_8_16(C6accel_Handle hC6accel, unsigned char * restrict ptr_src, unsigned char * restrict ptr_dst, unsigned int count,
+					const unsigned char *restrict in, unsigned short *restrict out, short cols, short rows)
+Arguments
+* hC6accel C6accel Handle
+* ptr_src[ ] Input RGB image of count pixels.
+* ptr_dst[ ] Output Greyscale image of count pixels.
+* count Total pixel count.
+* ptr_in[ ] Input Greyscale image.
+* ptr_out[ ] Output sobel filtered image.
+* cols[ ] Number of columns in image.
+* rows[ ] Number of rows in image.
+
+Return value:  API returns status of the function call.
+               ==1 Pass
+               <0  Fail
+
+Description This routine converts input RGB image to Greyscale Image using formula as described below followed by sobel_3x3_8_16 filter.
+
+  		Y = 0.299 * R + 0.587 * G + 0.114 * B
+
+
+*/
+int C6accel_RGB_To_Y_IMG_sobel_3x3_8_16(C6accel_Handle hC6accel,
+                          		unsigned char * restrict ptr_src,       /* Pointer to input image in RGB format */
+                          		unsigned char * restrict ptr_dst,       /* Pointer to Greyscale output image    */
+			  		unsigned int count,			/* Total number of pixels               */
+			  		const unsigned char *restrict in,       /* Input image data   */
+                               		unsigned short       *restrict out,     /* Output image data  */
+                               		short cols, short rows                  /* Image dimensions   */
+
+#ifdef SUPPORT_ASYNC
+                          		,E_CALL_TYPE callType)
+#else 
+)
+#endif
+{
+
+    XDM1_BufDesc                inBufDesc;
+    XDM1_BufDesc                outBufDesc;
+    XDAS_Int32                  InArg_Buf_size;
+    IC6Accel_InArgs             *CInArgs;
+    UNIVERSAL_OutArgs           uniOutArgs;
+    int status;
+    /* Define pointer to function parameter structure */
+    IMG_RGB_To_Y_Params       *fp0;
+    IMG_sobel_3x3_8_16_Params *fp1;
+    XDAS_Int8 *pAlloc;
+
+    ACQUIRE_CODEC_ENGINE;
+
+    /* Allocate the InArgs structure as it varies in size
+    (Needs to be changed everytime we make a API call).
+     In this case we need to consider all the _Params size */
+    InArg_Buf_size=  (2*sizeof( Fxn_struct))+
+                     sizeof(IMG_RGB_To_Y_Params)+
+		     sizeof(IMG_sobel_3x3_8_16_Params)+
+                     sizeof(CInArgs->size)+
+                     sizeof(CInArgs->Num_fxns);
+
+    /* Request contiguous heap memory allocation for the extended input structure */
+    pAlloc = (XDAS_Int8 *)Memory_alloc(InArg_Buf_size, &wrapperMemParams);
+    CInArgs= (IC6Accel_InArgs *)pAlloc;
+
+    /* Initialize .size fields for dummy input and output arguments */
+    uniOutArgs.size = sizeof(uniOutArgs);
+
+    /* Set up buffers to pass buffers in and out to alg  */
+    inBufDesc.numBufs = 2;
+    outBufDesc.numBufs = 2; /* I am cheating DSP by telling one in/out buffer as out buffer */
+
+    /* Fill in input/output buffer descriptor parameters and manage ARM cache*/
+    /* See wrapper_c6accel_i.h for more details of operation                 */
+    CACHE_WB_INV_INPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(ptr_src,0,3*count*sizeof(char));
+    CACHE_INV_OUTPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(ptr_dst,0,rows* cols *sizeof(char));
+    CACHE_WB_INV_INPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(ptr_dst,1,rows*cols*sizeof(char));
+    CACHE_INV_OUTPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(out,1,rows* cols *sizeof(short));
+
+     /* Initialize the extended InArgs structure */
+    CInArgs->Num_fxns=2;  //***
+    CInArgs->size= InArg_Buf_size;
+
+    /* Set function Id and parameter pointers for first function call */
+    CInArgs->fxn[0].FxnID= IMG_RGB_TO_Y_FXN_ID;
+    CInArgs->fxn[0].Param_ptr_offset=sizeof(CInArgs->size)+sizeof(CInArgs->Num_fxns)+ (2 * sizeof(Fxn_struct)); /* 2 is due to fact that we are 															chaining 2 functions    */
+
+    /* Set function Id and parameter pointers for second function call */
+    CInArgs->fxn[1].FxnID= IMG_SOBEL_3X3_8_16_FXN_ID;
+    CInArgs->fxn[1].Param_ptr_offset=CInArgs->fxn[0].Param_ptr_offset+sizeof(IMG_RGB_To_Y_Params);
+
+    
+    /* Initialize pointers to function parameters */
+    fp0 = (IMG_RGB_To_Y_Params *)((XDAS_Int8*)CInArgs + CInArgs->fxn[0].Param_ptr_offset);
+    fp1 = (IMG_sobel_3x3_8_16_Params *)((XDAS_Int8*)CInArgs + CInArgs->fxn[1].Param_ptr_offset);
+
+
+    /* Fill in the fields in the parameter structure of function 1 */
+    fp0->src_InArrID1= INBUF0;
+    fp0->dst_OutArrID1= OUTBUF0;
+    fp0->count= count;
+
+    /* Fill in the fields in the parameter structure of function 2 */
+    fp1->indata_InArrID1= INBUF1;
+    fp1->outdata_OutArrID1= OUTBUF1;
+    fp1->Col= cols;
+    fp1->Row= rows;
+
+#ifdef SUPPORT_ASYNC
+    /* Call the actual algorithm */
+    if (callType == ASYNC)
+      {
+
+       //Update async structure
+       if (c6accelAsyncParams.asyncCallCount!=0)
+          { status = UNIVERSAL_EFAIL;
+            printf("Async call failed as %d are still pending\n",c6accelAsyncParams.asyncCallCount);
+          }
+       else
+          {c6accelAsyncParams.asyncCallCount++;
+           memcpy(&(c6accelAsyncParams.inBufs),&inBufDesc, sizeof (XDM1_BufDesc));
+ //           memcpy(&(c6accelAsyncParams.inOutBufs),&inOutBufs, sizeof (XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.outBufs), &outBufDesc,sizeof(XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.inArgs), CInArgs,sizeof(UNIVERSAL_InArgs));
+           memcpy(&(c6accelAsyncParams.outArgs),&uniOutArgs,sizeof(UNIVERSAL_OutArgs));
+           c6accelAsyncParams.pBuf = pAlloc;
+           c6accelAsyncParams.pBufSize = InArg_Buf_size;
+
+           status = UNIVERSAL_processAsync(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+           }
+      }
+     else
+       {
+#endif
+         // Sync call
+        status = UNIVERSAL_process(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+        /* Free the InArgs structure */
+        Memory_free(pAlloc, InArg_Buf_size, &wrapperMemParams);
+#ifdef SUPPORT_ASYNC
+        }
+#endif 
+
+    RELEASE_CODEC_ENGINE;
+
+    return status;
+
+}
+
+/*
+void C6Accel_DSP_dft_f(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_src,       
+                          unsigned char * restrict ptr_dst,       
+			  int dxtType,				  
+			  int nonZeroRows, 
+			  )   
+Arguments
+* hC6accel C6accel 		Handle
+* ptr_src[]        		Pointer to input Array
+* ptr_dst[]        		Pointer to output arrary   
+* dxtType	   		Type of action to take 
+* nonZeroRows      		Count of non-zero rows for finding DFT
+
+
+Return value:  API returns status of the function call.
+               ==0 Pass
+               <0  Fail
+
+Description This routine computes a complex forward/inverse mixed radix FFT with rounding and digit reversal.
+Input data x[ ], output data y[ ]. The output is returned in the separate array
+ptr_dst[ ] in normal order. Each complex value is stored with interleaved real and imaginary parts. The code uses a
+special ordering of FFT coefficients (also called twiddle factors) and memory accesses to improve performance in the presence of cache.
+
+Special Requirements
+
+In-place computation is not allowed.
+The size of the FFT, nx, must be a power of 2 or 4, and 16 = nx = 65536.
+The arrays for the complex input data x[ ], complex output data y[ ], and twiddle factors w[ ] must be double-word aligned.
+The input and output data are complex, with the real/imaginary components stored in adjacent locations in the array.
+*/
+int C6accel_DSP_dft_f(C6accel_Handle hC6accel,
+                          void * restrict ptr_src,       /* Pointer to input image */
+                          void * restrict ptr_dst,       /* Pointer to Greyscale output image    */
+			  int dxtType,				  /* Type of action to take */
+			  int nonZeroRows 			  /* Count of non-zero rows */
+			  
+#ifdef SUPPORT_ASYNC
+                          		,E_CALL_TYPE callType)
+#else 
+)
+#endif
+{
+    XDM1_BufDesc                inBufDesc;
+    XDM1_BufDesc                outBufDesc;
+    XDAS_Int32                  InArg_Buf_size;
+    IC6Accel_InArgs             *CInArgs;
+    UNIVERSAL_OutArgs           uniOutArgs;
+    int status;
+    IplImage *tempImage = (IplImage *) ptr_src;
+    /* Define pointer to function parameter structure */
+    DSP_dft_f_Params      *fp0;
+    XDAS_Int8 *pAlloc;
+
+    ACQUIRE_CODEC_ENGINE;
+
+    /* Allocate the InArgs structure as it varies in size
+    (Needs to be changed everytime we make a API call)*/
+    InArg_Buf_size=  sizeof(Fxn_struct)+
+                     sizeof(DSP_dft_f_Params)+
+                     sizeof(CInArgs->size)+
+                     sizeof(CInArgs->Num_fxns);
+
+    /* Request contiguous heap memory allocation for the extended input structure */
+    pAlloc = (XDAS_Int8 *)Memory_alloc(InArg_Buf_size, &wrapperMemParams);
+    CInArgs= (IC6Accel_InArgs *)pAlloc;
+
+    /* Initialize .size fields for dummy input and output arguments */
+    uniOutArgs.size = sizeof(uniOutArgs);
+
+    /* Set up buffers to pass buffers in and out to alg  */
+    inBufDesc.numBufs = 1;
+    outBufDesc.numBufs = 1;
+
+    /* Fill in input/output buffer descriptor parameters and manage ARM cache*/
+    /* See wrapper_c6accel_i.h for more details of operation                 */
+    int size = tempImage->widthStep * tempImage->height;
+    CACHE_WB_INV_INPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(tempImage->imageData,0,size);
+   
+    tempImage = (IplImage *)ptr_dst;
+    size = tempImage->widthStep * tempImage->height;
+    CACHE_INV_OUTPUT_BUFFERS_AND_SETUP_FOR_C6ACCEL(tempImage->imageData,0,size);
+
+     /* Initialize the extended InArgs structure */
+    CInArgs->Num_fxns=1;
+    CInArgs->size= InArg_Buf_size;
+
+    /* Set function Id and parameter pointers for first function call */
+    CInArgs->fxn[0].FxnID= DSP_DFT_F_FXN_ID;
+    CInArgs->fxn[0].Param_ptr_offset=sizeof(CInArgs->size)+sizeof(CInArgs->Num_fxns)+sizeof(Fxn_struct);
+
+    /* Initialize pointers to function parameters */
+    fp0 = (DSP_dft_f_Params *)((XDAS_Int8*)CInArgs + CInArgs->fxn[0].Param_ptr_offset);
+
+    /* Fill in the fields in the parameter structure */
+    fp0->src_InArrID1= INBUF0;
+    fp0->dst_OutArrID1= OUTBUF0;
+    fp0->dxtType= dxtType;
+    fp0->nonZeroRows= nonZeroRows;
+    memcpy(&(fp0->src),ptr_src,sizeof(IplImage));
+    memcpy(&(fp0->dst),ptr_dst,sizeof(IplImage));
+
+
+#ifdef SUPPORT_ASYNC
+    /* Call the actual algorithm */
+    if (callType == ASYNC)
+      {
+
+       //Update async structure
+       if (c6accelAsyncParams.asyncCallCount!=0)
+          { status = UNIVERSAL_EFAIL;
+            printf("Async call failed as %d are still pending\n",c6accelAsyncParams.asyncCallCount);
+          }
+       else
+          {c6accelAsyncParams.asyncCallCount++;
+           memcpy(&(c6accelAsyncParams.inBufs),&inBufDesc, sizeof (XDM1_BufDesc));
+ //           memcpy(&(c6accelAsyncParams.inOutBufs),&inOutBufs, sizeof (XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.outBufs), &outBufDesc,sizeof(XDM1_BufDesc));
+           memcpy(&(c6accelAsyncParams.inArgs), CInArgs,sizeof(UNIVERSAL_InArgs));
+           memcpy(&(c6accelAsyncParams.outArgs),&uniOutArgs,sizeof(UNIVERSAL_OutArgs));
+           c6accelAsyncParams.pBuf = pAlloc;
+           c6accelAsyncParams.pBufSize = InArg_Buf_size;
+
+           status = UNIVERSAL_processAsync(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+           }
+      }
+     else
+       {
+#endif
+         // Sync call
+        status = UNIVERSAL_process(hC6accel->hUni, &inBufDesc, &outBufDesc, NULL,(UNIVERSAL_InArgs *)CInArgs, &uniOutArgs);
+        /* Free the InArgs structure */
+        Memory_free(pAlloc, InArg_Buf_size, &wrapperMemParams);
+#ifdef SUPPORT_ASYNC
+        }
+#endif 
+
+    RELEASE_CODEC_ENGINE;
+
+    return status;
+}
+
 
 /*
  *
@@ -10505,8 +11179,8 @@
 
        Status = UNIVERSAL_processWait(hC6accel->hUni, &(c6accelAsyncParams.inBufs), &(c6accelAsyncParams.outBufs), NULL,
         &(c6accelAsyncParams.inArgs), &(c6accelAsyncParams.outArgs), UNIVERSAL_FOREVER);
-
-
+       if(Status != 0)
+	 printf("Error: DSP Sync Error\n");
         /* Free the InArgs structure */
         Memory_free(c6accelAsyncParams.pBuf, c6accelAsyncParams.pBufSize, &wrapperMemParams);
 
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/build.cfg c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/build.cfg
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/build.cfg	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/build.cfg	1969-12-31 18:00:00.000000000 -0600
@@ -1,12 +0,0 @@
-if (pkg.$vers.length >= 3) {
-    pkg.$vers.push(Packages.xdc.services.global.Vers.getDate(xdc.csd() + '/..'));
-}
-
-pkg.build.libraries = [
-];
-
-pkg.build.libDesc = [
-];
-if ('suffix' in xdc.om['xdc.IPackage$$LibDesc']) {
-}
-
Binary files c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/c6accelw_config.ccs and c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/c6accelw_config.ccs differ
Binary files c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/c6accelw_config.class and c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/c6accelw_config.class differ
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/c6accelw_config.java c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/c6accelw_config.java
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/c6accelw_config.java	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/c6accelw_config.java	1969-12-31 18:00:00.000000000 -0600
@@ -1,139 +0,0 @@
-/*
- *  Do not modify this file; it is automatically 
- *  generated and any modifications will be overwritten.
- *
- * @(#) xdc-t50
- */
-import java.util.*;
-import org.mozilla.javascript.*;
-import xdc.services.intern.xsr.*;
-import xdc.services.spec.*;
-
-public class c6accelw_config
-{
-    static final String VERS = "@(#) xdc-t50\n";
-
-    static final Proto.Elm $$T_Bool = Proto.Elm.newBool();
-    static final Proto.Elm $$T_Num = Proto.Elm.newNum();
-    static final Proto.Elm $$T_Str = Proto.Elm.newStr();
-    static final Proto.Elm $$T_Obj = Proto.Elm.newObj();
-
-    static final Proto.Fxn $$T_Met = new Proto.Fxn(null, null, 0, -1, false);
-    static final Proto.Map $$T_Map = new Proto.Map($$T_Obj);
-    static final Proto.Arr $$T_Vec = new Proto.Arr($$T_Obj);
-
-    static final XScriptO $$DEFAULT = Value.DEFAULT;
-    static final Object $$UNDEF = Undefined.instance;
-
-    static final Proto.Obj $$Package = (Proto.Obj)Global.get("$$Package");
-    static final Proto.Obj $$Module = (Proto.Obj)Global.get("$$Module");
-    static final Proto.Obj $$Instance = (Proto.Obj)Global.get("$$Instance");
-    static final Proto.Obj $$Params = (Proto.Obj)Global.get("$$Params");
-
-    static final Object $$objFldGet = Global.get("$$objFldGet");
-    static final Object $$objFldSet = Global.get("$$objFldSet");
-    static final Object $$proxyGet = Global.get("$$proxyGet");
-    static final Object $$proxySet = Global.get("$$proxySet");
-    static final Object $$delegGet = Global.get("$$delegGet");
-    static final Object $$delegSet = Global.get("$$delegSet");
-
-    Scriptable xdcO;
-    Session ses;
-    Value.Obj om;
-
-    boolean isROV;
-    boolean isCFG;
-
-    Proto.Obj pkgP;
-    Value.Obj pkgV;
-
-    ArrayList<Object> imports = new ArrayList<Object>();
-    ArrayList<Object> loggables = new ArrayList<Object>();
-    ArrayList<Object> mcfgs = new ArrayList<Object>();
-    ArrayList<Object> proxies = new ArrayList<Object>();
-    ArrayList<Object> sizes = new ArrayList<Object>();
-    ArrayList<Object> tdefs = new ArrayList<Object>();
-
-    void $$IMPORTS()
-    {
-        Global.callFxn("loadPackage", xdcO, "xdc");
-        Global.callFxn("loadPackage", xdcO, "xdc.corevers");
-    }
-
-    void $$OBJECTS()
-    {
-        pkgP = (Proto.Obj)om.bind("c6accelw_config.Package", new Proto.Obj());
-        pkgV = (Value.Obj)om.bind("c6accelw_config", new Value.Obj("c6accelw_config", pkgP));
-    }
-
-    void $$SINGLETONS()
-    {
-        pkgP.init("c6accelw_config.Package", (Proto.Obj)om.findStrict("xdc.IPackage.Module", "c6accelw_config"));
-        Scriptable cap = (Scriptable)Global.callFxn("loadCapsule", xdcO, "c6accelw_config/package.xs");
-        om.bind("xdc.IPackage$$capsule", cap);
-        Object fxn;
-                fxn = Global.get(cap, "init");
-                if (fxn != null) pkgP.addFxn("init", (Proto.Fxn)om.findStrict("xdc.IPackage$$init", "c6accelw_config"), fxn);
-                fxn = Global.get(cap, "close");
-                if (fxn != null) pkgP.addFxn("close", (Proto.Fxn)om.findStrict("xdc.IPackage$$close", "c6accelw_config"), fxn);
-                fxn = Global.get(cap, "validate");
-                if (fxn != null) pkgP.addFxn("validate", (Proto.Fxn)om.findStrict("xdc.IPackage$$validate", "c6accelw_config"), fxn);
-                fxn = Global.get(cap, "exit");
-                if (fxn != null) pkgP.addFxn("exit", (Proto.Fxn)om.findStrict("xdc.IPackage$$exit", "c6accelw_config"), fxn);
-                fxn = Global.get(cap, "getLibs");
-                if (fxn != null) pkgP.addFxn("getLibs", (Proto.Fxn)om.findStrict("xdc.IPackage$$getLibs", "c6accelw_config"), fxn);
-                fxn = Global.get(cap, "getSects");
-                if (fxn != null) pkgP.addFxn("getSects", (Proto.Fxn)om.findStrict("xdc.IPackage$$getSects", "c6accelw_config"), fxn);
-        pkgP.bind("$capsule", cap);
-        pkgV.init2(pkgP, "c6accelw_config", Value.DEFAULT, false);
-        pkgV.bind("$name", "c6accelw_config");
-        pkgV.bind("$category", "Package");
-        pkgV.bind("$$qn", "c6accelw_config.");
-        pkgV.bind("$vers", Global.newArray());
-        Value.Map atmap = (Value.Map)pkgV.getv("$attr");
-        atmap.seal("length");
-        imports.clear();
-        pkgV.bind("$imports", imports);
-        StringBuilder sb = new StringBuilder();
-        sb.append("var pkg = xdc.om['c6accelw_config'];\n");
-        sb.append("if (pkg.$vers.length >= 3) {\n");
-            sb.append("pkg.$vers.push(Packages.xdc.services.global.Vers.getDate(xdc.csd() + '/..'));\n");
-        sb.append("}\n");
-        sb.append("pkg.build.libraries = [\n");
-        sb.append("];\n");
-        sb.append("pkg.build.libDesc = [\n");
-        sb.append("];\n");
-        sb.append("if('suffix' in xdc.om['xdc.IPackage$$LibDesc']) {\n");
-        sb.append("}\n");
-        Global.eval(sb.toString());
-    }
-
-    void $$INITIALIZATION()
-    {
-        Value.Obj vo;
-
-        if (isCFG) {
-        }//isCFG
-        Global.callFxn("init", pkgV);
-        ((Value.Arr)om.findStrict("$packages", "c6accelw_config")).add(pkgV);
-    }
-
-    public void exec( Scriptable xdcO, Session ses )
-    {
-        this.xdcO = xdcO;
-        this.ses = ses;
-        om = (Value.Obj)xdcO.get("om", null);
-
-        Object o = om.geto("$name");
-        String s = o instanceof String ? (String)o : null;
-        isCFG = s != null && s.equals("cfg");
-        isROV = s != null && s.equals("rov");
-
-        $$IMPORTS();
-        $$OBJECTS();
-        if (isROV) {
-        }//isROV
-        $$SINGLETONS();
-        $$INITIALIZATION();
-    }
-}
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.c c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.c
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.c	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,96 +0,0 @@
-/*
- *  Do not modify this file; it is automatically 
- *  generated and any modifications will be overwritten.
- *
- * @(#) xdc-t50
- */
-
-#define __nested__
-#define __config__
-
-#include <xdc/std.h>
-
-/*
- * ======== GENERATED SECTIONS ========
- *     
- *     MODULE INCLUDES
- *     
- *     <module-name> INTERNALS
- *     <module-name> INHERITS
- *     <module-name> VTABLE
- *     <module-name> PATCH TABLE
- *     <module-name> DECLARATIONS
- *     <module-name> OBJECT OFFSETS
- *     <module-name> TEMPLATES
- *     <module-name> INITIALIZERS
- *     <module-name> FUNCTION STUBS
- *     <module-name> PROXY BODY
- *     <module-name> OBJECT DESCRIPTOR
- *     <module-name> SYSTEM FUNCTIONS
- *     <module-name> PRAGMAS
- *     
- *     INITIALIZATION ENTRY POINT
- *     PROGRAM GLOBALS
- *     CLINK DIRECTIVES
- */
-
-
-/*
- * ======== MODULE INCLUDES ========
- */
-
-
-
-/*
- * ======== xdc.cfg.Program TEMPLATE ========
- */
-
-/*
- *  ======== __ASM__ ========
- *  Define absolute path to program's assembly directory
- */
-xdc__META(__ASM__, "@(#)__ASM__ = /usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T");
-
-/*
- *  ======== __ISA__ ========
- *  Define the ISA of this executable.  This symbol is used by platform
- *  specific "exec" commands that support more than one ISA; e.g., gdb
- */
-xdc__META(__ISA__, "@(#)__ISA__ = v5T");
-
-/*
- *  ======== __PLAT__ ========
- *  Define the name of the platform that can run this executable.  This
- *  symbol is used by platform independent "exec" commands
- */
-xdc__META(__PLAT__, "@(#)__PLAT__ = ti.platforms.evm3530");
-
-/*
- *  ======== __TARG__ ========
- *  Define the name of the target used to build this executable.
- */
-xdc__META(__TARG__, "@(#)__TARG__ = gnu.targets.arm.GCArmv5T");
-
-
-/*
- * ======== PROGRAM GLOBALS ========
- */
-
-
-/*
- * ======== CLINK DIRECTIVES ========
- */
-
-#ifdef __ti__
-#define PRAGMA(x) _Pragma(#x)
-#define xdc__clink_constant(var) \
-PRAGMA(DATA_SECTION(var, ".const:" #var))  \
-asm("   .sect \".const:" #var "\"\n"  \
-  "   .clink\n"  \
-  "   .sect \"[0].const:" #var "\"\n"  \
-  "   .clink\n"  \
-  "   .sect \"[1].const:" #var "\"\n"  \
-  "   .clink")
-
-#endif
-
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg	1969-12-31 18:00:00.000000000 -0600
@@ -1,489 +0,0 @@
-/*
- *  ======== package/cfg/c6accelw_xv5T.cfg ========
- *  This generated configuration script runs the user's configuration script
- *  the context of a specific target and platform in order to generate
- *  all the files necessary to create an executable; e.g., linker command
- *  files, static C/C++ data structures, etc.
- */
-
-/*
- *  ======== _runescape ========
- *  Recursive unescape to decode serialized strings
- */
-function _runescape(obj) {
-    for (var i in obj) {
-        if (obj[i] != null) {
-            if (typeof obj[i] == 'string') {
-                obj[i] = unescape(obj[i]);
-            }
-            else if (typeof obj[i] == 'object') {
-                _runescape(obj[i]);
-            }
-        }
-    }
-}
-
-/*
- *  ======== _getPlatCfg ========
- */
-function _getPlatCfg() {
-    var tmp = {};
-    _runescape(tmp);
-    return (tmp);
-}
-/*
- *  ======== _cfginit ========
- */
-function _cfginit() {
-    xdc.loadPackage('xdc.services.intern.cmd');
-    var prog = xdc.om['xdc.cfg.Program'];
-
-    /* initialize prog attrs from build model */
-    var build = {
-        releases: {
-            0: {
-                name: "c6accelw_config",
-                attrs: {
-                    prefix: "",
-                    label: "default"
-                },
-                otherFiles: {}
-            }
-        },
-        target: {
-            $name:"gnu.targets.arm.GCArmv5T",
-            name: "GCArmv5T",
-            suffix: "v5T",
-            compatibleSuffixes: {
-                $name:"gnu.targets.arm.GCArmv5T/compatibleSuffixes",
-                0: "470MV",
-                1: "v5t"
-            },
-            isa: "v5T",
-            model: {
-                $name:"gnu.targets.arm.GCArmv5T/model",
-                endian: "little"
-            },
-            os: "Linux",
-            rts: "gnu.targets.arm.rtsv5T",
-            dllExt: ".so",
-            platform: "ti.platforms.evm3530",
-            platforms: {
-                $name:"gnu.targets.arm.GCArmv5T/platforms",
-                0: "ti.platforms.evm3530"
-            },
-            version: "gnu.targets.arm.GCArmv5T%7B1%2C0%2C4.2%2C3",
-            debugGen: {
-                $name:"gnu.targets.arm.GCArmv5T/debugGen",
-            },
-            extensions: {
-                $name:"gnu.targets.arm.GCArmv5T/extensions",
-                ".asm": {
-                    $name:"gnu.targets.arm.GCArmv5T/extensions/'.asm'",
-                    suf: ".asm",
-                    typ: "asm"
-                },
-                ".c": {
-                    $name:"gnu.targets.arm.GCArmv5T/extensions/'.c'",
-                    suf: ".c",
-                    typ: "c"
-                },
-                ".cpp": {
-                    $name:"gnu.targets.arm.GCArmv5T/extensions/'.cpp'",
-                    suf: ".cpp",
-                    typ: "cpp"
-                },
-                ".cxx": {
-                    $name:"gnu.targets.arm.GCArmv5T/extensions/'.cxx'",
-                    suf: ".cxx",
-                    typ: "cpp"
-                },
-                ".C": {
-                    $name:"gnu.targets.arm.GCArmv5T/extensions/'.C'",
-                    suf: ".C",
-                    typ: "cpp"
-                },
-                ".cc": {
-                    $name:"gnu.targets.arm.GCArmv5T/extensions/'.cc'",
-                    suf: ".cc",
-                    typ: "cpp"
-                }
-            },
-            versionMap: {
-                $name:"gnu.targets.arm.GCArmv5T/versionMap",
-                "gcc3.2": "1%2C0%2C3.2%2C0"
-            },
-            alignDirectiveSupported: false,
-            rootDir: "/home/a0272049/arm-2008q1",
-            profiles: {
-                $name:"gnu.targets.arm.GCArmv5T/profiles",
-                debug: {
-                    $name:"gnu.targets.arm.GCArmv5T/profiles/'debug'",
-                    compileOpts: {
-                        $name:"gnu.targets.arm.GCArmv5T/profiles/'debug'/compileOpts",
-                        copts: "-g",
-                        defs: "-D_DEBUG_%3D1"
-                    },
-                    linkOpts: "-g",
-                    filters: {
-                        $name:"gnu.targets.arm.GCArmv5T/profiles/'debug'/filters",
-                    }
-                },
-                release: {
-                    $name:"gnu.targets.arm.GCArmv5T/profiles/'release'",
-                    compileOpts: {
-                        $name:"gnu.targets.arm.GCArmv5T/profiles/'release'/compileOpts",
-                        copts: "-O2"
-                    },
-                    linkOpts: "",
-                    filters: {
-                        $name:"gnu.targets.arm.GCArmv5T/profiles/'release'/filters",
-                    }
-                },
-                profile: {
-                    $name:"gnu.targets.arm.GCArmv5T/profiles/'profile'",
-                    compileOpts: {
-                        $name:"gnu.targets.arm.GCArmv5T/profiles/'profile'/compileOpts",
-                        copts: "-g%20-pg"
-                    },
-                    linkOpts: "-pg",
-                    filters: {
-                        $name:"gnu.targets.arm.GCArmv5T/profiles/'profile'/filters",
-                    }
-                },
-                coverage: {
-                    $name:"gnu.targets.arm.GCArmv5T/profiles/'coverage'",
-                    compileOpts: {
-                        $name:"gnu.targets.arm.GCArmv5T/profiles/'coverage'/compileOpts",
-                        copts: "-fprofile-arcs%20-ftest-coverage"
-                    },
-                    linkOpts: "",
-                    filters: {
-                        $name:"gnu.targets.arm.GCArmv5T/profiles/'coverage'/filters",
-                    }
-                }
-            },
-            sectMap: {
-                $name:"gnu.targets.arm.GCArmv5T/sectMap",
-            },
-            stdInclude: "gnu/targets/arm/std.h",
-            stdTypes: {
-                $name:"gnu.targets.arm.GCArmv5T/stdTypes",
-                t_IArg: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_IArg",
-                    size: 4,
-                    align: 4
-                },
-                t_Char: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Char",
-                    size: 1,
-                    align: 1
-                },
-                t_Double: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Double",
-                    size: 8,
-                    align: 4
-                },
-                t_Float: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Float",
-                    size: 4,
-                    align: 4
-                },
-                t_Fxn: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Fxn",
-                    size: 4,
-                    align: 4
-                },
-                t_Int: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Int",
-                    size: 4,
-                    align: 4
-                },
-                t_Int8: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Int8",
-                    size: 1,
-                    align: 1
-                },
-                t_Int16: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Int16",
-                    size: 2,
-                    align: 2
-                },
-                t_Int32: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Int32",
-                    size: 4,
-                    align: 4
-                },
-                t_Int40: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Int40",
-                },
-                t_Int64: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Int64",
-                    size: 8,
-                    align: 4
-                },
-                t_Long: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Long",
-                    size: 4,
-                    align: 4
-                },
-                t_LDouble: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_LDouble",
-                    size: 8,
-                    align: 4
-                },
-                t_LLong: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_LLong",
-                    size: 8,
-                    align: 4
-                },
-                t_Ptr: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Ptr",
-                    size: 4,
-                    align: 4
-                },
-                t_Short: {
-                    $name:"gnu.targets.arm.GCArmv5T/stdTypes/t_Short",
-                    size: 2,
-                    align: 2
-                }
-            },
-            bitsPerChar: 8,
-            GCCVERS: "4.2.3",
-            GCCTARG: "arm-none-linux-gnueabi",
-            LONGNAME: "bin/arm-none-linux-gnueabi-gcc",
-            CYGWIN: false,
-            noStdLinkScript: false,
-            ar: {
-                $name:"gnu.targets.arm.GCArmv5T/ar",
-                cmd: "%24%28rootDir%29/%24%28GCCTARG%29/bin/ar",
-                opts: "cr"
-            },
-            arOpts: {
-                $name:"gnu.targets.arm.GCArmv5T/arOpts",
-                prefix: "",
-                suffix: ""
-            },
-            lnk: {
-                $name:"gnu.targets.arm.GCArmv5T/lnk",
-                cmd: "%24%28rootDir%29/%24%28LONGNAME%29",
-                opts: ""
-            },
-            lnkOpts: {
-                $name:"gnu.targets.arm.GCArmv5T/lnkOpts",
-                prefix: "",
-                suffix: "-lstdc++%20-L%24%28rootDir%29/%24%28GCCTARG%29/lib"
-            },
-            cc: {
-                $name:"gnu.targets.arm.GCArmv5T/cc",
-                cmd: "%24%28rootDir%29/%24%28LONGNAME%29%20-c%20-MD%20-MF%20%24@.dep",
-                opts: "-march%3Darmv5t"
-            },
-            ccOpts: {
-                $name:"gnu.targets.arm.GCArmv5T/ccOpts",
-                prefix: "-fPIC%20-Wunused",
-                suffix: "-Dfar%3D%20"
-            },
-            asm: {
-                $name:"gnu.targets.arm.GCArmv5T/asm",
-                cmd: "%24%28rootDir%29/%24%28LONGNAME%29%20-c%20-x%20assembler",
-                opts: "-march%3Darmv5t"
-            },
-            asmOpts: {
-                $name:"gnu.targets.arm.GCArmv5T/asmOpts",
-                prefix: "",
-                suffix: ""
-            },
-            includeOpts: ""
-        },
-        test: {},
-        cfgArgsEncoded: true,
-        cfgArgs: "null",
-        cfgScript: "/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw.cfg",
-        cfgHome: "c6accelw_config",
-        profile: "release"
-    };
-    build.target.findSuffix = function findSuffix(pkg) {
-        if (arguments.length < 1) {
-            throw new Error("The function ITarget.findSuffix() requires an " + "argument");
-        }
-        var suffixMap = {};
-        if ("build" in pkg) {
-            var build = pkg.build;
-            if (build.libraries.length != 0) {
-                if (build.libDesc[0].suffix != undefined) {
-                    for (var i = 0; i < build.libDesc.length; i++) {
-                        suffixMap[build.libDesc[i].suffix] = "";
-                    }
-                } else {
-                    for (var i = 0; i < build.libDesc.length; i++) {
-                        if (build.libDesc[i].target == prog.build.target.$name) {
-                            suffixMap[prog.build.target.suffix] = "";
-                            break;
-                        }
-                    }
-                }
-            }
-        } else {
-            if ("length" in pkg) {
-                for (var i = 0; i < pkg.length; i++) {
-                    suffixMap[pkg[i]] = "";
-                }
-            } else {
-                throw new Error("An invalid argument type supplied to " + "ITarget.findSuffix()");
-            }
-        }
-        var compTargs = [];
-        for (var prop in this.compatibleSuffixes) {
-            compTargs[prop] = this.compatibleSuffixes[prop];
-        }
-        if (this.suffix in suffixMap) {
-            return (this.suffix);
-        }
-        if (compTargs.length < 1) {
-            return (null);
-        }
-        for (var i = 0; i < compTargs.length; i++) {
-            if (compTargs[i] in suffixMap) {
-                return (compTargs[i]);
-            }
-        }
-        return (null);
-    };
-
-    build.target.selectSuffix = function selectSuffix(list) {
-        var suffixMap = {};
-        for (var i = 0; i < list.length; i++) {
-            suffixMap[list[i]] = "";
-        }
-        var compTargs = [];
-        for (var prop in this.compatibleSuffixes) {
-            compTargs[prop] = this.compatibleSuffixes[prop];
-        }
-        if (this.suffix in suffixMap) {
-            return (this.suffix);
-        }
-        if (compTargs.length < 1) {
-            return (null);
-        }
-        for (var i = 0; i < compTargs.length; i++) {
-            if (compTargs[i] in suffixMap) {
-                return (compTargs[i]);
-            }
-        }
-        return (null);
-    };
-
-    _runescape(build);
-    build.cfgArgs = null;
-    prog.build = build;
-    
-    prog.name = "c6accelw.xv5T";
-
-    prog.endian = prog.build.target.model.endian;
-
-    /* use the platform package's Platform module */
-    var Platform = xdc.useModule("ti.platforms.evm3530.Platform");
-    var platParams = _getPlatCfg();
-    for (var prop in platParams) {
-        if (!(prop in Platform.PARAMS)) {
-            delete platParams[prop];
-        }
-    }
-    prog.platformName = "ti.platforms.evm3530";
-    prog.platform = Platform.create("", _getPlatCfg(), platParams);
-    /* record the executable's package name */
-    prog.buildPackage = "c6accelw_config";
-
-    /* record build-model information required during config generation */
-    prog.$$bind("$$isasm", 0);
-    prog.$$bind("$$isrom", 0);
-    prog.$$bind("$$gentab", [
-    ]);
-    
-    /* bind prog to an appropriate execution context */
-    prog.cpu = prog.platform.getExeContext(prog);
-
-    /* import the target's run-time support pkg */
-    xdc.loadPackage("gnu.targets.arm.rtsv5T");
-}
-    
-/* function to import the cfg script's package */
-function _userscript($$legacy, script) {
-    var home;
-    var spath;
-    home = xdc.loadPackage("c6accelw_config");
-    
-    xdc.om.$$bind('$homepkg', home);
-
-    if (script != null) {
-        utils.evaluateScript(script);
-    }
-    else {
-        /* load & run program cfg script and monitor all loaded files */
-        _runCfg("/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw.cfg", spath, "package/cfg/c6accelw_xv5T",  
-                 false, 
-                 false,
-                 _getPlatCfg());
-    }                           
-
-
-    /*
-     *  ======== _runCfg ========
-     *  Run a user supplied configuration script and prevent user's script from
-     *  overwriting the global variable prog.
-     */
-    function _runCfg(cfgScript, path, programName, legacyTcf, legacyCfg,
-        platParams)
-    {
-        if (legacyTcf) {
-            /* save current global variables */
-            var $save = {prog: utils.global.prog, Program: Program};
-    
-            /* initialize global variables for legacy config scripts */
-            environment["config.programName"] = programName;
-            environment["config.platform"] = Program.platformName;
-            utils.seedPath = environment["config.importPath"];
-            utils.loadPlatform.params = platParams;
-            Program = $$legacy.Program;     /* defined in cfg.tci */
-            
-            /* run legacy config script with prog == to RTSC Program; this
-             * allows legacy script to read build atributes from RTSC model
-             * before re-creating the prog object
-             */
-            utils.loadCapsule(cfgScript, false, path);  
-    
-            /* restore global variables; now prog == TCOM prog because
-             * utils.loadPlatform() creates the TCOM prog object.
-             */
-            $$legacy.prog = utils.global.prog;  /* in case XDC wants it */
-            utils.global.prog = $save.prog;
-            Program = $save.Program;
-    
-            /* run XDC configuration script, if it exists */
-            if (legacyCfg) {
-                utils.importFile(cfgScript.replace(/\.tcf/, ".cfg"), path);
-            }
-        }
-        else {
-            utils.loadCapsule(cfgScript, false, path);
-        }
-    }
-}
-    
-function _postinit() {
-
-    var cout = null;
-
-    var prog = xdc.om['xdc.cfg.Program'];
-    /* get the exec command for this executable */
-    if (prog.execCmd == null) {
-        prog.execCmd = prog.platform.getExecCmd(prog,
-            xdc.om["ti.platforms.evm3530"].packageBase);
-    }
-    cout = "define EXEC." + prog.name + '\n\n';
-    cout += prog.execCmd;
-    cout += "\nendef\n\n";
-
-    utils.genDep("package/cfg/c6accelw_xv5T", "c6accelw_config", utils.loadedFiles, cout, null);
-}
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg.dot c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg.dot
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg.dot	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg.dot	1969-12-31 18:00:00.000000000 -0600
@@ -1,116 +0,0 @@
-digraph configuration {
-    size="7.5,10";
-    rankdir=LR;
-    ranksep=".50 equally";
-    concentrate=true;
-    compound=true;
-    label="\nConfiguration for c6accelw_config/c6accelw.xv5T"
-  node [font=Helvetica, fontsize=14, fontcolor=black];  subgraph cluster0 {label=""; __cfg [label="/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw.cfg", color=white, fontcolor=blue];
-    node [font=Helvetica, fontsize=10];    subgraph cluster1 {
-        label="";
-        xdc_services_global__top [shape=box,label="xdc.services.global\n1, 0, 0", color=white];
-        xdc_services_global__bot [shape=point,label="", style=invis];
-        xdc_services_global_Clock [style=filled,fillcolor=lightgray, label="Clock"];
-        xdc_services_global__top -> xdc_services_global_Clock[style=invis];
-        xdc_services_global_Clock -> xdc_services_global__bot[style=invis];
-    }
-    subgraph cluster2 {
-        label="";
-        xdc__top [shape=box,label="xdc\n1, 1, 1", color=white];
-    }
-    subgraph cluster3 {
-        label="";
-        xdc_corevers__top [shape=box,label="xdc.corevers\n16, 0, 1, 0", color=white];
-    }
-    subgraph cluster4 {
-        label="";
-        xdc_shelf__top [shape=box,label="xdc.shelf\n1, 0, 0", color=white];
-    }
-    subgraph cluster5 {
-        label="";
-        xdc_services_spec__top [shape=box,label="xdc.services.spec\n1, 0, 0, 0", color=white];
-    }
-    subgraph cluster6 {
-        label="";
-        xdc_services_intern_xsr__top [shape=box,label="xdc.services.intern.xsr\n1, 0, 0", color=white];
-    }
-    subgraph cluster7 {
-        label="";
-        xdc_services_intern_gen__top [shape=box,label="xdc.services.intern.gen\n1, 0, 0, 0", color=white];
-    }
-    subgraph cluster8 {
-        label="";
-        xdc_services_intern_cmd__top [shape=box,label="xdc.services.intern.cmd\n1, 0, 0, 0", color=white];
-    }
-    subgraph cluster9 {
-        label="";
-        xdc_rov__top [shape=box,label="xdc.rov\n1, 0, 0", color=white];
-        xdc_rov__bot [shape=point,label="", style=invis];
-    }
-    subgraph cluster10 {
-        label="";
-        xdc_runtime__top [shape=box,label="xdc.runtime\n2, 0, 0, 0", color=white];
-        xdc_runtime__bot [shape=point,label="", style=invis];
-    }
-    subgraph cluster11 {
-        label="";
-        gnu_targets_arm_rtsv5T__top [shape=box,label="gnu.targets.arm.rtsv5T\n1, 0, 0, 0", color=white];
-    }
-    subgraph cluster12 {
-        label="";
-        ti_catalog_arm__top [shape=box,label="ti.catalog.arm\n1, 0, 1, 0", color=white];
-        ti_catalog_arm__bot [shape=point,label="", style=invis];
-        ti_catalog_arm_OMAP3530 [style=filled,fillcolor=lightgray, label="OMAP3530"];
-        ti_catalog_arm__top -> ti_catalog_arm_OMAP3530[style=invis];
-        ti_catalog_arm_OMAP3530 -> ti_catalog_arm__bot[style=invis];
-    }
-    subgraph cluster13 {
-        label="";
-        ti_catalog__top [shape=box,label="ti.catalog\n1, 0, 0", color=white];
-    }
-    subgraph cluster14 {
-        label="";
-        xdc_platform__top [shape=box,label="xdc.platform\n1, 0, 1, 0", color=white];
-        xdc_platform__bot [shape=point,label="", style=invis];
-        xdc_platform_ExeContext [style=filled,fillcolor=lightgray, label="ExeContext"];
-        xdc_platform__top -> xdc_platform_ExeContext[style=invis];
-        xdc_platform_ExeContext -> xdc_platform__bot[style=invis];
-        xdc_platform_Utils [style=filled,fillcolor=lightgray, label="Utils"];
-        xdc_platform__top -> xdc_platform_Utils[style=invis];
-        xdc_platform_Utils -> xdc_platform__bot[style=invis];
-    }
-    subgraph cluster15 {
-        label="";
-        xdc_cfg__top [shape=box,label="xdc.cfg\n1, 0, 2, 0", color=white];
-        xdc_cfg__bot [shape=point,label="", style=invis];
-        xdc_cfg_Program [style=filled,fillcolor=lightgray, label="Program"];
-        xdc_cfg__top -> xdc_cfg_Program[style=invis];
-        xdc_cfg_Program -> xdc_cfg__bot[style=invis];
-        xdc_cfg_Main [style=filled,fillcolor=lightgray, label="Main"];
-        xdc_cfg__top -> xdc_cfg_Main[style=invis];
-        xdc_cfg_Main -> xdc_cfg__bot[style=invis];
-    }
-    subgraph cluster16 {
-        label="";
-        ti_catalog_c6000__top [shape=box,label="ti.catalog.c6000\n1, 0, 0, 0", color=white];
-        ti_catalog_c6000__bot [shape=point,label="", style=invis];
-    }
-    subgraph cluster17 {
-        label="";
-        ti_platforms_evm3530__top [shape=box,label="ti.platforms.evm3530\n1, 0, 0", color=white];
-        ti_platforms_evm3530__bot [shape=point,label="", style=invis];
-        ti_platforms_evm3530_Platform [style=filled,fillcolor=lightgray, label="Platform"];
-        ti_platforms_evm3530__top -> ti_platforms_evm3530_Platform[style=invis];
-        ti_platforms_evm3530_Platform -> ti_platforms_evm3530__bot[style=invis];
-    }
-    subgraph cluster18 {
-        label="";
-        c6accelw_config__top [shape=box,label="c6accelw_config\n", color=white];
-    }
-  }
-  node [font=Helvetica, fontsize=10];
-    gnu_targets_arm_GCArmv5T__1_0_3__4_3 [shape=record,label="gnu.targets.arm.GCArmv5T|1,0,3.4,3",style=filled, fillcolor=lightgrey];
-    gnu_targets_arm_rtsv5T__top -> gnu_targets_arm_GCArmv5T__1_0_3__4_3 [ltail=cluster11];
-    gnu_targets_arm_GCArmv5T__1_0_4__2_3 [shape=record,label="gnu.targets.arm.GCArmv5T|1,0,4.2,3",style=filled, fillcolor=lightgrey];
-    c6accelw_config__top -> gnu_targets_arm_GCArmv5T__1_0_4__2_3 [ltail=cluster18];
-}
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg.xml c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg.xml
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg.xml	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.cfg.xml	1969-12-31 18:00:00.000000000 -0600
@@ -1,814 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  This file conforms to the DTD xdc/cfg/configuration.dtd -->
-<configuration name="c6accelw_config/c6accelw.xv5T"
-    platformName="ti.platforms.evm3530"
-    globalSection="null"
-    sysStack="4096"
-    stack="4096"
-    heap="4096"
-    argSize="512"
-    execCmd="@%24%28ECHO%29%20ti.platforms.evm3530%20platform%20package%20cannot%20execute%20c6accelw.xv5T%20on%20Linux%0A@%24%28ECHO%29%20Check%20for%20updates%20to%20this%20package%20at%3A%0A@%24%28ECHO%29%20https%3A//www-a.ti.com/downloads/sds_support/targetcontent/rtsc/index.html%0A%09%3A"
-    endian="little"
-    codeModel="null"
-    dataModel="null">
-<targets>
-    <target name="gnu.targets.arm.GCArmv5T"
-            version="1,0,3.4,3"
-            usedby="gnu.targets.arm.rtsv5T"/>
-    <target name="gnu.targets.arm.GCArmv5T"
-            version="1,0,4.2,3"
-            usedby="c6accelw_config"/>
-</targets>
-<imports>
-    <package name="xdc.services.global" version="1, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-        <module name="xdc.services.global.Clock"
-                used="true"
-                uses="">
-            <feature name="enable" type="boolean" value="false"/>
-            <feature name="showMemory" type="boolean" value="false"/>
-        </module>
-        <module name="xdc.services.global.Trace"
-                used="false"
-                uses="">
-        </module>
-    </package>
-    <package name="xdc" version="1, 1, 1" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="xdc.corevers" version="16, 0, 1, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="xdc.shelf" version="1, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="xdc.services.spec" version="1, 0, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="xdc.services.intern.xsr" version="1, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="xdc.services.intern.gen" version="1, 0, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="xdc.services.intern.cmd" version="1, 0, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="xdc.rov" version="1, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-        <module name="xdc.rov.Model"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.rov.Program"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.rov.StructureDecoder"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.rov.StateReader"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.rov.ViewXml"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.rov.ViewInfo"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.rov.OFReader"
-                used="false"
-                uses="">
-        </module>
-    </package>
-    <package name="xdc.runtime" version="2, 0, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-        <module name="xdc.runtime.Assert"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Core"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Defaults"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Diags"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Error"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Gate"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.GateNull"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Log"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.LoggerBuf"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.LoggerSys"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Main"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Memory"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.HeapMin"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.HeapStd"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Startup"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.System"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.SysStd"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.SysMin"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Text"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Timestamp"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.TimestampNull"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.TimestampStd"
-                used="false"
-                uses="">
-        </module>
-        <module name="xdc.runtime.Types"
-                used="false"
-                uses="">
-        </module>
-    </package>
-    <package name="gnu.targets.arm.rtsv5T" version="1, 0, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="ti.catalog.arm" version="1, 0, 1, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-        <module name="ti.catalog.arm.TMS470R10"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320C5912"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320C1030"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320CDM6446"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320CDM6467"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320CDM355"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320DM357"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320DM365"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320CDM510"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP2430"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP2431"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP2530"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP2531"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3403"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3405"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3503"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3505"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3515"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3517"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3425"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3525"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320C3430"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAP3530"
-                used="true"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320DA828"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320DA830"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAPL137"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.CortexM3"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS570PSF762"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320DA840"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAPL108"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAPL118"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.OMAPL138"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.arm.TMS320CDM740"
-                used="false"
-                uses="">
-        </module>
-    </package>
-    <package name="ti.catalog" version="1, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-    </package>
-    <package name="xdc.platform" version="1, 0, 1, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-        <module name="xdc.platform.ExeContext"
-                used="true"
-                uses="">
-        </module>
-        <module name="xdc.platform.Utils"
-                used="true"
-                uses="">
-        </module>
-    </package>
-    <package name="xdc.cfg" version="1, 0, 2, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-        <module name="xdc.cfg.Program"
-                used="true"
-                uses="">
-            <feature name="gen" type="xdc.cfg.Program.GenerationOptions" value="%7BdebuggerFiles%3A%20undefined%7D"><struct id="xdc.cfg.Program/gen">
-  <field name="debuggerFiles">undefined</field>
-</struct>
-            </feature>
-            <feature name="globalSection" type="object" value="null"/>
-            <feature name="sysStack" type="number" value="4096"/>
-            <feature name="stack" type="number" value="4096"/>
-            <feature name="heap" type="number" value="4096"/>
-            <feature name="argSize" type="number" value="512"/>
-            <feature name="execCmd" type="string" value="@%24%28ECHO%29%20ti.platforms.evm3530%20platform%20package%20cannot%20execute%20c6accelw.xv5T%20on%20Linux%0A@%24%28ECHO%29%20Check%20for%20updates%20to%20this%20package%20at%3A%0A@%24%28ECHO%29%20https%3A//www-a.ti.com/downloads/sds_support/targetcontent/rtsc/index.html%0A%09%3A"/>
-            <feature name="linkTemplate" type="object" value="null"/>
-            <feature name="main" type="undefined" value="undefined"/>
-            <feature name="sectMap" type="object" value="%5B%0A%0A%5D">
-            </feature>
-            <feature name="system" type="undefined" value="undefined"/>
-            <feature name="name" type="string" value="c6accelw.xv5T"/>
-            <feature name="buildPackage" type="string" value="c6accelw_config"/>
-            <feature name="endian" type="string" value="little"/>
-            <feature name="codeModel" type="object" value="null"/>
-            <feature name="dataModel" type="object" value="null"/>
-            <feature name="build" type="object" value="%5Bobject%20Object%5D"/>
-            <feature name="cpu" type="xdc.platform.IExeContext.Instance" value="%7Bid%3A%201%2C%20catalogName%3A%20ti.catalog.arm%2C%20deviceName%3A%20OMAP3530%2C%20revision%3A%20%2C%20clockRate%3A%200x14a%2C%20board%3A%20%7Bid%3A%200%2C%20boardName%3A%20evm3530%2C%20boardFamily%3A%20evm3530%2C%20boardRevision%3A%20null%7D%2C%20attrs%3A%20xdc.services.intern.xsr.Value%24Obj@10e434d%3A%3A%28xdc.platform.ICpuDataSheet.Instance%29ti.catalog.arm.OMAP3530.Instance%230%2C%20memoryMap%3A%20%5B%0A%5B%27SRAM%27%2C%20%7Bcomment%3A%20On-Chip%20SRAM%2C%20name%3A%20SRAM%2C%20space%3A%20code/data%2C%20page%3A%20undefined%2C%20base%3A%200x40200000%2C%20len%3A%200x10000%2C%20access%3A%20RWX%7D%5D%2C%0A%5B%27DDR2%27%2C%20%7Bcomment%3A%20undefined%2C%20name%3A%20DDR2%2C%20space%3A%20undefined%2C%20page%3A%20undefined%2C%20base%3A%200x80000000%2C%20len%3A%200x8000000%2C%20access%3A%20undefined%7D%5D%0A%5D%7D"/>
-            <feature name="platformName" type="string" value="ti.platforms.evm3530"/>
-            <feature name="platform" type="xdc.platform.IPlatform.Instance" value="%7BexternalMemoryMap%3A%20%5B%0A%5B%27DDR2%27%2C%20%7Bcomment%3A%20undefined%2C%20name%3A%20DDR2%2C%20space%3A%20undefined%2C%20page%3A%20undefined%2C%20base%3A%200x80000000%2C%20len%3A%200x8000000%2C%20access%3A%20undefined%7D%5D%0A%5D%2C%20customMemoryMap%3A%20%5B%0A%0A%5D%2C%20renameMap%3A%20%5B%0A%0A%5D%2C%20dataMemory%3A%20DDR2%2C%20codeMemory%3A%20DDR2%2C%20stackMemory%3A%20DDR2%2C%20sectMap%3A%20%5B%0A%0A%5D%7D"/>
-            <feature name="global" type="object" value="%5B%0A%0A%5D">
-            </feature>
-            <feature name="symbol" type="object" value="%5B%0A%5B%27xdc_runtime_Startup__EXECFXN__C%27%2C%200x0%5D%2C%0A%5B%27xdc_runtime_Startup__RESETFXN__C%27%2C%200x0%5D%2C%0A%5B%27xdc_runtime_Startup_exec__E%27%2C%200x0%5D%2C%0A%5B%27xdc_runtime_Startup_reset__I%27%2C%200x0%5D%0A%5D"><map id="xdc.cfg.Program/symbol" length="4">
-  <entry key="xdc_runtime_Startup__EXECFXN__C">0x0</entry>
-  <entry key="xdc_runtime_Startup__RESETFXN__C">0x0</entry>
-  <entry key="xdc_runtime_Startup_exec__E">0x0</entry>
-  <entry key="xdc_runtime_Startup_reset__I">0x0</entry>
-</map>
-            </feature>
-            <feature name="fixedCodeAddr" type="number" value="0"/>
-            <feature name="fixedDataAddr" type="number" value="0"/>
-            <feature name="loadFixedDataAddr" type="undefined" value="undefined"/>
-            <feature name="loadRom" type="boolean" value="false"/>
-        </module>
-        <module name="xdc.cfg.Main"
-                used="true"
-                uses="">
-        </module>
-    </package>
-    <package name="ti.catalog.c6000" version="1, 0, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-        <module name="ti.catalog.c6000.TMS320C6452"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM647"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM648"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTNETV2685"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6428"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6711"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6711B"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6712"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6713"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6211"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6211B"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6410"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6411"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6412"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6413"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6414"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6415"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6416"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6418"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6421"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6424"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM640"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM641"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM642"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDA700"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDA705"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDA707"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDA710"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDA700SIM"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA442"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA444"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA446"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA447"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA457"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA459"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6722"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6726"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6727"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM415"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM420"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM421"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM425"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM426"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM6431"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM6433"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM6435"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM6437"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM6441"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM6443"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM6446"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DM357"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM6467"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRI300"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTCI6482"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTCI6486"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTCI6487"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTCI6488"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTCI6484"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTCI6496"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTCI6497"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CTCI6498"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6454"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6455"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C2430"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C3430"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6701"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6201"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6202"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6203"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6203B"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6204"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6205"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA406"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA402"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA404"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA414"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDRA416"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CF761990"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.OMAP2431"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.OMAP2530"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.OMAP2531"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.OMAP3425"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.OMAP3525"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.OMAP3530"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DA805"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DA807"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DA808"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DA810"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DA828"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DA830"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6472"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6474"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6747"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6745"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.OMAPL137"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.OMAPL138"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6457"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DA840"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320DA850"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6742"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6746"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320C6748"
-                used="false"
-                uses="">
-        </module>
-        <module name="ti.catalog.c6000.TMS320CDM740"
-                used="false"
-                uses="">
-        </module>
-    </package>
-    <package name="ti.platforms.evm3530" version="1, 0, 0" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/">
-        <module name="ti.platforms.evm3530.Platform"
-                used="true"
-                uses="">
-            <feature name="BOARD" type="xdc.platform.IPlatform.Board" value="%7Bid%3A%200%2C%20boardName%3A%20evm3530%2C%20boardFamily%3A%20evm3530%2C%20boardRevision%3A%20null%7D"><struct id="ti.platforms.evm3530.Platform/BOARD">
-  <field name="id">0</field>
-  <field name="boardName">evm3530</field>
-  <field name="boardFamily">evm3530</field>
-  <field name="boardRevision">null</field>
-</struct>
-            </feature>
-            <feature name="DSP" type="xdc.platform.IExeContext.Cpu" value="%7Bid%3A%200%2C%20catalogName%3A%20ti.catalog.c6000%2C%20deviceName%3A%20OMAP3530%2C%20revision%3A%20%2C%20clockRate%3A%200x14a%7D"><struct id="ti.platforms.evm3530.Platform/DSP">
-  <field name="id">0</field>
-  <field name="catalogName">ti.catalog.c6000</field>
-  <field name="deviceName">OMAP3530</field>
-  <field name="revision"/>
-  <field name="clockRate">0x14a</field>
-</struct>
-            </feature>
-            <feature name="GPP" type="xdc.platform.IExeContext.Cpu" value="%7Bid%3A%201%2C%20catalogName%3A%20ti.catalog.arm%2C%20deviceName%3A%20OMAP3530%2C%20revision%3A%20%2C%20clockRate%3A%200x14a%7D"><struct id="ti.platforms.evm3530.Platform/GPP">
-  <field name="id">1</field>
-  <field name="catalogName">ti.catalog.arm</field>
-  <field name="deviceName">OMAP3530</field>
-  <field name="revision"/>
-  <field name="clockRate">0x14a</field>
-</struct>
-            </feature>
-        </module>
-    </package>
-    <package name="c6accelw_config" version="" repository="/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/">
-    </package>
-</imports>
-</configuration>
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.dep c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.dep
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.dep	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.dep	1969-12-31 18:00:00.000000000 -0600
@@ -1,128 +0,0 @@
-#
-# The following is generated by utils.genDep for package/cfg/c6accelw_xv5T
-#
-package/cfg/c6accelw_xv5T.c package/cfg/c6accelw_xv5T.h package/cfg/c6accelw_xv5T.xdl:package.xs package/cfg/c6accelw_xv5T.cfg /usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw.cfg /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/include/utils.tci /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/CortexM3.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/IOMAP2x3x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/IOMAP3xxx.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/ITMS320DA8xx.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320C1030.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320C5912.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM355.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM510.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM6446.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM6467.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM740.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320DM357.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320DM365.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS470R10.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS570PSF762.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/package.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IAntara.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IDaVinci.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IHimalaya.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IOMAP2x3x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IOMAP3xxx.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C642x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C64_128K.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C64_1M.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C64_256K.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C64_512K.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C6x0x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C6x1x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CDM6467.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CDRA44x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CDRA45x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CDRx40x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI6484.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI6486.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI648x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI6496.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI6497.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320DA8xx.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320C6421.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320C6428.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320C6452.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320C6454.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CDM6431.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CDM647.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CDM648.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CDM740.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CF761990.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CTNETV2685.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/c6x.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/package.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/platforms/evm3530/Platform.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/IPackage.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/cfg/Main.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/cfg/Program.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/cfg/package.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/om2.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/package.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/platform/ExeContext.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/platform/IPlatform.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/platform/Utils.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/platform/package.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/Model.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/OFReader.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/Program.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/StateReader.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/StructureDecoder.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/ViewXml.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Assert.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Defaults.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Diags.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Error.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Gate.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/GateNull.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/HeapMin.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/HeapStd.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/IGateProvider.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Log.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/LoggerBuf.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/LoggerSys.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Memory.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Startup.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/SysMin.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/System.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Text.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Timestamp.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/package.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/Clock.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/Trace.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/template.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xdc.tci /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xmlgen.xs /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xmlgen2.xs 
-
-/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw.cfg:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/include/utils.tci:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/CortexM3.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/IOMAP2x3x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/IOMAP3xxx.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/ITMS320DA8xx.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320C1030.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320C5912.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM355.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM510.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM6446.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM6467.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320CDM740.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320DM357.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS320DM365.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS470R10.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/TMS570PSF762.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/arm/package.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IAntara.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IDaVinci.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IHimalaya.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IOMAP2x3x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/IOMAP3xxx.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C642x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C64_128K.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C64_1M.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C64_256K.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C64_512K.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C6x0x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320C6x1x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CDM6467.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CDRA44x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CDRA45x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CDRx40x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI6484.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI6486.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI648x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI6496.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320CTCI6497.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/ITMS320DA8xx.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320C6421.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320C6428.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320C6452.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320C6454.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CDM6431.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CDM647.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CDM648.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CDM740.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CF761990.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/TMS320CTNETV2685.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/c6x.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/catalog/c6000/package.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/platforms/evm3530/Platform.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/IPackage.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/cfg/Main.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/cfg/Program.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/cfg/package.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/om2.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/package.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/platform/ExeContext.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/platform/IPlatform.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/platform/Utils.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/platform/package.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/Model.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/OFReader.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/Program.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/StateReader.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/StructureDecoder.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/rov/ViewXml.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Assert.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Defaults.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Diags.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Error.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Gate.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/GateNull.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/HeapMin.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/HeapStd.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/IGateProvider.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Log.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/LoggerBuf.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/LoggerSys.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Memory.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Startup.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/SysMin.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/System.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Text.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/Timestamp.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/runtime/package.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/Clock.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/Trace.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/template.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xdc.tci:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xmlgen.xs:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xmlgen2.xs:
-
-
-define EXEC.c6accelw.xv5T
-
-@$(ECHO) ti.platforms.evm3530 platform package cannot execute c6accelw.xv5T on Linux
-@$(ECHO) Check for updates to this package at:
-@$(ECHO) https://www-a.ti.com/downloads/sds_support/targetcontent/rtsc/index.html
-	:
-endef
-
-#
-# The following is generated by java
-#
-
-c6accelw.xv5T: package/cfg/c6accelw_xv5T.ov5T /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/rtsv5T/lib/gnu.targets.arm.rtsv5T.av5T 
-
-package/cfg/c6accelw_xv5T.c: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/cfg/Program.xdt /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/linkcmd.xdt /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/linkcmd.xdt 
-package/cfg/c6accelw_xv5T.c package/cfg/c6accelw_xv5T.xdl: .interfaces 
-
-#
-# rule-less goals for files outside this package
-# (these goals force a re-build if these files are
-# moved or deleted)
-#
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/rtsv5T/lib/gnu.targets.arm.rtsv5T.av5T:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/cfg/Program.xdt:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/linkcmd.xdt:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/linkcmd.xdt:
-
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.h c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.h
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.h	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,17 +0,0 @@
-/*
- *  Do not modify this file; it is automatically 
- *  generated and any modifications will be overwritten.
- *
- * @(#) xdc-t50
- */
-
-#include <xdc/std.h>
-
-extern int xdc_runtime_Startup__EXECFXN__C;
-
-extern int xdc_runtime_Startup__RESETFXN__C;
-
-extern int xdc_runtime_Startup_exec__E;
-
-extern int xdc_runtime_Startup_reset__I;
-
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.mak c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.mak
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.mak	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.mak	1969-12-31 18:00:00.000000000 -0600
@@ -1,39 +0,0 @@
-#
-#  Do not edit this file.  This file is generated from 
-#  package.bld.  Any modifications to this file will be 
-#  overwritten whenever makefiles are re-generated.
-#
-#  target compatibility key = gnu.targets.arm.GCArmv5T{1,0,4.2,3
-#
-ifneq (clean,$(MAKECMDGOALS))
--include package/cfg/c6accelw_xv5T.ov5T.dep
-endif
-
-package/cfg/c6accelw_xv5T.ov5T: | .interfaces
-package/cfg/c6accelw_xv5T.ov5T: package/cfg/c6accelw_xv5T.c package/cfg/c6accelw_xv5T.mak
-	@$(RM) $@.dep
-	$(RM) $@
-	@$(MSG) clv5T $< ...
-	$(gnu.targets.arm.GCArmv5T.rootDir)/bin/arm-none-linux-gnueabi-gcc -c -MD -MF $@.dep -x c  -fPIC -Wunused -march=armv5t -Dfar=   -Dxdc_cfg__header__='c6accelw_config/package/cfg/c6accelw_xv5T.h'  -Dxdc_target_name__=GCArmv5T -Dxdc_target_types__=gnu/targets/arm/std.h -Dxdc_bld__profile_release -Dxdc_bld__vers_1_0_4_2_3 -O2  $(XDCINCS)  -o $@ $<
-	-@$(FIXDEP) $@.dep $@.dep
-	
-package/cfg/c6accelw_xv5T.ov5T:LD_LIBRARY_PATH=
-
-package/cfg/c6accelw_xv5T.sv5T: | .interfaces
-package/cfg/c6accelw_xv5T.sv5T: package/cfg/c6accelw_xv5T.c package/cfg/c6accelw_xv5T.mak
-	@$(RM) $@.dep
-	$(RM) $@
-	@$(MSG) clv5T -S $< ...
-	$(gnu.targets.arm.GCArmv5T.rootDir)/bin/arm-none-linux-gnueabi-gcc -c -MD -MF $@.dep -x c -S -fPIC -Wunused -march=armv5t -Dfar=   -Dxdc_cfg__header__='c6accelw_config/package/cfg/c6accelw_xv5T.h'  -Dxdc_target_name__=GCArmv5T -Dxdc_target_types__=gnu/targets/arm/std.h -Dxdc_bld__profile_release -Dxdc_bld__vers_1_0_4_2_3 -O2  $(XDCINCS)  -o $@ $<
-	-@$(FIXDEP) $@.dep $@.dep
-	
-package/cfg/c6accelw_xv5T.sv5T:LD_LIBRARY_PATH=
-
-clean,v5T ::
-	-$(RM) package/cfg/c6accelw_xv5T.ov5T
-	-$(RM) package/cfg/c6accelw_xv5T.sv5T
-
-c6accelw.xv5T: package/cfg/c6accelw_xv5T.ov5T package/cfg/c6accelw_xv5T.mak
-
-clean::
-	-$(RM) package/cfg/c6accelw_xv5T.mak
Binary files c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.ov5T and c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.ov5T differ
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.ov5T.dep c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.ov5T.dep
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.ov5T.dep	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.ov5T.dep	1969-12-31 18:00:00.000000000 -0600
@@ -1,8 +0,0 @@
-package/cfg/c6accelw_xv5T.ov5T: package/cfg/c6accelw_xv5T.c   /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/std.h   /home/a0272049/arm-2008q1/bin/../lib/gcc/arm-none-linux-gnueabi/4.2.3/include/stdarg.h   /home/a0272049/arm-2008q1/bin/../lib/gcc/arm-none-linux-gnueabi/4.2.3/include/stddef.h   /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/std.h   /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/GCArmv5T.h   /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/std.h
-package/cfg/c6accelw_xv5T.c:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/std.h:
-/home/a0272049/arm-2008q1/bin/../lib/gcc/arm-none-linux-gnueabi/4.2.3/include/stdarg.h:
-/home/a0272049/arm-2008q1/bin/../lib/gcc/arm-none-linux-gnueabi/4.2.3/include/stddef.h:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/std.h:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/GCArmv5T.h:
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/std.h:
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.rov.xs c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.rov.xs
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.rov.xs	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.rov.xs	1969-12-31 18:00:00.000000000 -0600
@@ -1,395 +0,0 @@
-__o = null
-__obj = [
-    this,  // #0 
-    {},    // #1 
-    {},    // #2 
-    {},    // #3 
-    {},    // #4 
-    {},    // #5 
-    {},    // #6 
-    {},    // #7 gnu.targets.arm.GCArmv5T
-    {},    // #8 gnu.targets.arm.GCArmv5T/ar
-    {},    // #9 gnu.targets.arm.GCArmv5T/arOpts
-    {},    // #10 gnu.targets.arm.GCArmv5T/asm
-    {},    // #11 gnu.targets.arm.GCArmv5T/asmOpts
-    {},    // #12 gnu.targets.arm.GCArmv5T/cc
-    {},    // #13 gnu.targets.arm.GCArmv5T/ccOpts
-    {},    // #14 gnu.targets.arm.GCArmv5T/compatibleSuffixes
-    {},    // #15 gnu.targets.arm.GCArmv5T/debugGen
-    {},    // #16 gnu.targets.arm.GCArmv5T/extensions
-    {},    // #17 gnu.targets.arm.GCArmv5T/extensions/'.C'
-    {},    // #18 gnu.targets.arm.GCArmv5T/extensions/'.asm'
-    {},    // #19 gnu.targets.arm.GCArmv5T/extensions/'.c'
-    {},    // #20 gnu.targets.arm.GCArmv5T/extensions/'.cc'
-    {},    // #21 gnu.targets.arm.GCArmv5T/extensions/'.cpp'
-    {},    // #22 gnu.targets.arm.GCArmv5T/extensions/'.cxx'
-    {},    // #23 gnu.targets.arm.GCArmv5T/lnk
-    {},    // #24 gnu.targets.arm.GCArmv5T/lnkOpts
-    {},    // #25 gnu.targets.arm.GCArmv5T/model
-    {},    // #26 gnu.targets.arm.GCArmv5T/platforms
-    {},    // #27 gnu.targets.arm.GCArmv5T/profiles
-    {},    // #28 gnu.targets.arm.GCArmv5T/profiles/'coverage'
-    {},    // #29 gnu.targets.arm.GCArmv5T/profiles/'coverage'/compileOpts
-    {},    // #30 gnu.targets.arm.GCArmv5T/profiles/'coverage'/filters
-    {},    // #31 gnu.targets.arm.GCArmv5T/profiles/'debug'
-    {},    // #32 gnu.targets.arm.GCArmv5T/profiles/'debug'/compileOpts
-    {},    // #33 gnu.targets.arm.GCArmv5T/profiles/'debug'/filters
-    {},    // #34 gnu.targets.arm.GCArmv5T/profiles/'profile'
-    {},    // #35 gnu.targets.arm.GCArmv5T/profiles/'profile'/compileOpts
-    {},    // #36 gnu.targets.arm.GCArmv5T/profiles/'profile'/filters
-    {},    // #37 gnu.targets.arm.GCArmv5T/profiles/'release'
-    {},    // #38 gnu.targets.arm.GCArmv5T/profiles/'release'/compileOpts
-    {},    // #39 gnu.targets.arm.GCArmv5T/profiles/'release'/filters
-    {},    // #40 gnu.targets.arm.GCArmv5T/sectMap
-    {},    // #41 gnu.targets.arm.GCArmv5T/stdTypes
-    {},    // #42 gnu.targets.arm.GCArmv5T/stdTypes/t_Char
-    {},    // #43 gnu.targets.arm.GCArmv5T/stdTypes/t_Double
-    {},    // #44 gnu.targets.arm.GCArmv5T/stdTypes/t_Float
-    {},    // #45 gnu.targets.arm.GCArmv5T/stdTypes/t_Fxn
-    {},    // #46 gnu.targets.arm.GCArmv5T/stdTypes/t_IArg
-    {},    // #47 gnu.targets.arm.GCArmv5T/stdTypes/t_Int
-    {},    // #48 gnu.targets.arm.GCArmv5T/stdTypes/t_Int16
-    {},    // #49 gnu.targets.arm.GCArmv5T/stdTypes/t_Int32
-    {},    // #50 gnu.targets.arm.GCArmv5T/stdTypes/t_Int40
-    {},    // #51 gnu.targets.arm.GCArmv5T/stdTypes/t_Int64
-    {},    // #52 gnu.targets.arm.GCArmv5T/stdTypes/t_Int8
-    {},    // #53 gnu.targets.arm.GCArmv5T/stdTypes/t_LDouble
-    {},    // #54 gnu.targets.arm.GCArmv5T/stdTypes/t_LLong
-    {},    // #55 gnu.targets.arm.GCArmv5T/stdTypes/t_Long
-    {},    // #56 gnu.targets.arm.GCArmv5T/stdTypes/t_Ptr
-    {},    // #57 gnu.targets.arm.GCArmv5T/stdTypes/t_Short
-    {},    // #58 gnu.targets.arm.GCArmv5T/versionMap
-    {},    // #59 
-]
-
-__o = __obj[0]  
-    __o['$modules'] = __obj[1.0]
-    __o['build'] = __obj[2.0]
-
-__o = __obj[1]  
-
-__o = __obj[2]  
-    __o['cfgArgs'] = null
-    __o['cfgArgsEncoded'] = true
-    __o['cfgHome'] = String(java.net.URLDecoder.decode('c6accelw_config', 'UTF-8'))
-    __o['cfgScript'] = String(java.net.URLDecoder.decode('%2Fusr%2Fdevel%2Fa0272049%2Fdvsdk_3_00_02_44%2Fc6accel%2Fsoc%2Fc6accelw%2Fc6accelw.cfg', 'UTF-8'))
-    __o['profile'] = String(java.net.URLDecoder.decode('release', 'UTF-8'))
-    __o['releases'] = __obj[3.0]
-    __o['target'] = __obj[7.0]
-    __o['test'] = __obj[59.0]
-
-__o = __obj[3]  
-    __o['0'] = __obj[4.0]
-
-__o = __obj[4]  
-    __o['attrs'] = __obj[5.0]
-    __o['name'] = String(java.net.URLDecoder.decode('c6accelw_config', 'UTF-8'))
-    __o['otherFiles'] = __obj[6.0]
-
-__o = __obj[5]  
-    __o['label'] = String(java.net.URLDecoder.decode('default', 'UTF-8'))
-    __o['prefix'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-
-__o = __obj[6]  
-
-__o = __obj[7]  // gnu.targets.arm.GCArmv5T
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T', 'UTF-8'))
-    __o['CYGWIN'] = false
-    __o['GCCTARG'] = String(java.net.URLDecoder.decode('arm-none-linux-gnueabi', 'UTF-8'))
-    __o['GCCVERS'] = String(java.net.URLDecoder.decode('4.2.3', 'UTF-8'))
-    __o['LONGNAME'] = String(java.net.URLDecoder.decode('bin%2Farm-none-linux-gnueabi-gcc', 'UTF-8'))
-    __o['alignDirectiveSupported'] = false
-    __o['ar'] = __obj[8.0]
-    __o['arOpts'] = __obj[9.0]
-    __o['asm'] = __obj[10.0]
-    __o['asmOpts'] = __obj[11.0]
-    __o['bitsPerChar'] = 8
-    __o['cc'] = __obj[12.0]
-    __o['ccOpts'] = __obj[13.0]
-    __o['compatibleSuffixes'] = __obj[14.0]
-    __o['debugGen'] = __obj[15.0]
-    __o['dllExt'] = String(java.net.URLDecoder.decode('.so', 'UTF-8'))
-    __o['extensions'] = __obj[16.0]
-    __o['includeOpts'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-    __o['isa'] = String(java.net.URLDecoder.decode('v5T', 'UTF-8'))
-    __o['lnk'] = __obj[23.0]
-    __o['lnkOpts'] = __obj[24.0]
-    __o['model'] = __obj[25.0]
-    __o['name'] = String(java.net.URLDecoder.decode('GCArmv5T', 'UTF-8'))
-    __o['noStdLinkScript'] = false
-    __o['os'] = String(java.net.URLDecoder.decode('Linux', 'UTF-8'))
-    __o['platform'] = String(java.net.URLDecoder.decode('ti.platforms.evm3530', 'UTF-8'))
-    __o['platforms'] = __obj[26.0]
-    __o['profiles'] = __obj[27.0]
-    __o['rootDir'] = String(java.net.URLDecoder.decode('%2Fhome%2Fa0272049%2Farm-2008q1', 'UTF-8'))
-    __o['rts'] = String(java.net.URLDecoder.decode('gnu.targets.arm.rtsv5T', 'UTF-8'))
-    __o['sectMap'] = __obj[40.0]
-    __o['stdInclude'] = String(java.net.URLDecoder.decode('gnu%2Ftargets%2Farm%2Fstd.h', 'UTF-8'))
-    __o['stdTypes'] = __obj[41.0]
-    __o['suffix'] = String(java.net.URLDecoder.decode('v5T', 'UTF-8'))
-    __o['version'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%7B1%2C0%2C4.2%2C3', 'UTF-8'))
-    __o['versionMap'] = __obj[58.0]
-
-__o = __obj[8]  // gnu.targets.arm.GCArmv5T/ar
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Far', 'UTF-8'))
-    __o['cmd'] = String(java.net.URLDecoder.decode('%24%28rootDir%29%2F%24%28GCCTARG%29%2Fbin%2Far', 'UTF-8'))
-    __o['opts'] = String(java.net.URLDecoder.decode('cr', 'UTF-8'))
-
-__o = __obj[9]  // gnu.targets.arm.GCArmv5T/arOpts
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FarOpts', 'UTF-8'))
-    __o['prefix'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-    __o['suffix'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-
-__o = __obj[10]  // gnu.targets.arm.GCArmv5T/asm
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fasm', 'UTF-8'))
-    __o['cmd'] = String(java.net.URLDecoder.decode('%24%28rootDir%29%2F%24%28LONGNAME%29+-c+-x+assembler', 'UTF-8'))
-    __o['opts'] = String(java.net.URLDecoder.decode('-march%3Darmv5t', 'UTF-8'))
-
-__o = __obj[11]  // gnu.targets.arm.GCArmv5T/asmOpts
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FasmOpts', 'UTF-8'))
-    __o['prefix'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-    __o['suffix'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-
-__o = __obj[12]  // gnu.targets.arm.GCArmv5T/cc
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fcc', 'UTF-8'))
-    __o['cmd'] = String(java.net.URLDecoder.decode('%24%28rootDir%29%2F%24%28LONGNAME%29+-c+-MD+-MF+%24%40.dep', 'UTF-8'))
-    __o['opts'] = String(java.net.URLDecoder.decode('-march%3Darmv5t', 'UTF-8'))
-
-__o = __obj[13]  // gnu.targets.arm.GCArmv5T/ccOpts
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FccOpts', 'UTF-8'))
-    __o['prefix'] = String(java.net.URLDecoder.decode('-fPIC+-Wunused', 'UTF-8'))
-    __o['suffix'] = String(java.net.URLDecoder.decode('-Dfar%3D+', 'UTF-8'))
-
-__o = __obj[14]  // gnu.targets.arm.GCArmv5T/compatibleSuffixes
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FcompatibleSuffixes', 'UTF-8'))
-    __o['0'] = String(java.net.URLDecoder.decode('470MV', 'UTF-8'))
-    __o['1'] = String(java.net.URLDecoder.decode('v5t', 'UTF-8'))
-
-__o = __obj[15]  // gnu.targets.arm.GCArmv5T/debugGen
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FdebugGen', 'UTF-8'))
-
-__o = __obj[16]  // gnu.targets.arm.GCArmv5T/extensions
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fextensions', 'UTF-8'))
-    __o['.C'] = __obj[17.0]
-    __o['.asm'] = __obj[18.0]
-    __o['.c'] = __obj[19.0]
-    __o['.cc'] = __obj[20.0]
-    __o['.cpp'] = __obj[21.0]
-    __o['.cxx'] = __obj[22.0]
-
-__o = __obj[17]  // gnu.targets.arm.GCArmv5T/extensions/'.C'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fextensions%2F%27.C%27', 'UTF-8'))
-    __o['suf'] = String(java.net.URLDecoder.decode('.C', 'UTF-8'))
-    __o['typ'] = String(java.net.URLDecoder.decode('cpp', 'UTF-8'))
-
-__o = __obj[18]  // gnu.targets.arm.GCArmv5T/extensions/'.asm'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fextensions%2F%27.asm%27', 'UTF-8'))
-    __o['suf'] = String(java.net.URLDecoder.decode('.asm', 'UTF-8'))
-    __o['typ'] = String(java.net.URLDecoder.decode('asm', 'UTF-8'))
-
-__o = __obj[19]  // gnu.targets.arm.GCArmv5T/extensions/'.c'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fextensions%2F%27.c%27', 'UTF-8'))
-    __o['suf'] = String(java.net.URLDecoder.decode('.c', 'UTF-8'))
-    __o['typ'] = String(java.net.URLDecoder.decode('c', 'UTF-8'))
-
-__o = __obj[20]  // gnu.targets.arm.GCArmv5T/extensions/'.cc'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fextensions%2F%27.cc%27', 'UTF-8'))
-    __o['suf'] = String(java.net.URLDecoder.decode('.cc', 'UTF-8'))
-    __o['typ'] = String(java.net.URLDecoder.decode('cpp', 'UTF-8'))
-
-__o = __obj[21]  // gnu.targets.arm.GCArmv5T/extensions/'.cpp'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fextensions%2F%27.cpp%27', 'UTF-8'))
-    __o['suf'] = String(java.net.URLDecoder.decode('.cpp', 'UTF-8'))
-    __o['typ'] = String(java.net.URLDecoder.decode('cpp', 'UTF-8'))
-
-__o = __obj[22]  // gnu.targets.arm.GCArmv5T/extensions/'.cxx'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fextensions%2F%27.cxx%27', 'UTF-8'))
-    __o['suf'] = String(java.net.URLDecoder.decode('.cxx', 'UTF-8'))
-    __o['typ'] = String(java.net.URLDecoder.decode('cpp', 'UTF-8'))
-
-__o = __obj[23]  // gnu.targets.arm.GCArmv5T/lnk
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Flnk', 'UTF-8'))
-    __o['cmd'] = String(java.net.URLDecoder.decode('%24%28rootDir%29%2F%24%28LONGNAME%29', 'UTF-8'))
-    __o['opts'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-
-__o = __obj[24]  // gnu.targets.arm.GCArmv5T/lnkOpts
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FlnkOpts', 'UTF-8'))
-    __o['prefix'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-    __o['suffix'] = String(java.net.URLDecoder.decode('-lstdc%2B%2B+-L%24%28rootDir%29%2F%24%28GCCTARG%29%2Flib', 'UTF-8'))
-
-__o = __obj[25]  // gnu.targets.arm.GCArmv5T/model
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fmodel', 'UTF-8'))
-    __o['endian'] = String(java.net.URLDecoder.decode('little', 'UTF-8'))
-
-__o = __obj[26]  // gnu.targets.arm.GCArmv5T/platforms
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fplatforms', 'UTF-8'))
-    __o['0'] = String(java.net.URLDecoder.decode('ti.platforms.evm3530', 'UTF-8'))
-
-__o = __obj[27]  // gnu.targets.arm.GCArmv5T/profiles
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles', 'UTF-8'))
-    __o['coverage'] = __obj[28.0]
-    __o['debug'] = __obj[31.0]
-    __o['profile'] = __obj[34.0]
-    __o['release'] = __obj[37.0]
-
-__o = __obj[28]  // gnu.targets.arm.GCArmv5T/profiles/'coverage'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27coverage%27', 'UTF-8'))
-    __o['compileOpts'] = __obj[29.0]
-    __o['filters'] = __obj[30.0]
-    __o['linkOpts'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-
-__o = __obj[29]  // gnu.targets.arm.GCArmv5T/profiles/'coverage'/compileOpts
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27coverage%27%2FcompileOpts', 'UTF-8'))
-    __o['copts'] = String(java.net.URLDecoder.decode('-fprofile-arcs+-ftest-coverage', 'UTF-8'))
-
-__o = __obj[30]  // gnu.targets.arm.GCArmv5T/profiles/'coverage'/filters
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27coverage%27%2Ffilters', 'UTF-8'))
-
-__o = __obj[31]  // gnu.targets.arm.GCArmv5T/profiles/'debug'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27debug%27', 'UTF-8'))
-    __o['compileOpts'] = __obj[32.0]
-    __o['filters'] = __obj[33.0]
-    __o['linkOpts'] = String(java.net.URLDecoder.decode('-g', 'UTF-8'))
-
-__o = __obj[32]  // gnu.targets.arm.GCArmv5T/profiles/'debug'/compileOpts
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27debug%27%2FcompileOpts', 'UTF-8'))
-    __o['copts'] = String(java.net.URLDecoder.decode('-g', 'UTF-8'))
-    __o['defs'] = String(java.net.URLDecoder.decode('-D_DEBUG_%3D1', 'UTF-8'))
-
-__o = __obj[33]  // gnu.targets.arm.GCArmv5T/profiles/'debug'/filters
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27debug%27%2Ffilters', 'UTF-8'))
-
-__o = __obj[34]  // gnu.targets.arm.GCArmv5T/profiles/'profile'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27profile%27', 'UTF-8'))
-    __o['compileOpts'] = __obj[35.0]
-    __o['filters'] = __obj[36.0]
-    __o['linkOpts'] = String(java.net.URLDecoder.decode('-pg', 'UTF-8'))
-
-__o = __obj[35]  // gnu.targets.arm.GCArmv5T/profiles/'profile'/compileOpts
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27profile%27%2FcompileOpts', 'UTF-8'))
-    __o['copts'] = String(java.net.URLDecoder.decode('-g+-pg', 'UTF-8'))
-
-__o = __obj[36]  // gnu.targets.arm.GCArmv5T/profiles/'profile'/filters
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27profile%27%2Ffilters', 'UTF-8'))
-
-__o = __obj[37]  // gnu.targets.arm.GCArmv5T/profiles/'release'
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27release%27', 'UTF-8'))
-    __o['compileOpts'] = __obj[38.0]
-    __o['filters'] = __obj[39.0]
-    __o['linkOpts'] = String(java.net.URLDecoder.decode('', 'UTF-8'))
-
-__o = __obj[38]  // gnu.targets.arm.GCArmv5T/profiles/'release'/compileOpts
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27release%27%2FcompileOpts', 'UTF-8'))
-    __o['copts'] = String(java.net.URLDecoder.decode('-O2', 'UTF-8'))
-
-__o = __obj[39]  // gnu.targets.arm.GCArmv5T/profiles/'release'/filters
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2Fprofiles%2F%27release%27%2Ffilters', 'UTF-8'))
-
-__o = __obj[40]  // gnu.targets.arm.GCArmv5T/sectMap
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FsectMap', 'UTF-8'))
-
-__o = __obj[41]  // gnu.targets.arm.GCArmv5T/stdTypes
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes', 'UTF-8'))
-    __o['t_Char'] = __obj[42.0]
-    __o['t_Double'] = __obj[43.0]
-    __o['t_Float'] = __obj[44.0]
-    __o['t_Fxn'] = __obj[45.0]
-    __o['t_IArg'] = __obj[46.0]
-    __o['t_Int'] = __obj[47.0]
-    __o['t_Int16'] = __obj[48.0]
-    __o['t_Int32'] = __obj[49.0]
-    __o['t_Int40'] = __obj[50.0]
-    __o['t_Int64'] = __obj[51.0]
-    __o['t_Int8'] = __obj[52.0]
-    __o['t_LDouble'] = __obj[53.0]
-    __o['t_LLong'] = __obj[54.0]
-    __o['t_Long'] = __obj[55.0]
-    __o['t_Ptr'] = __obj[56.0]
-    __o['t_Short'] = __obj[57.0]
-
-__o = __obj[42]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Char
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Char', 'UTF-8'))
-    __o['align'] = 1
-    __o['size'] = 1
-
-__o = __obj[43]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Double
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Double', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 8
-
-__o = __obj[44]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Float
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Float', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 4
-
-__o = __obj[45]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Fxn
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Fxn', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 4
-
-__o = __obj[46]  // gnu.targets.arm.GCArmv5T/stdTypes/t_IArg
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_IArg', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 4
-
-__o = __obj[47]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Int
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Int', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 4
-
-__o = __obj[48]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Int16
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Int16', 'UTF-8'))
-    __o['align'] = 2
-    __o['size'] = 2
-
-__o = __obj[49]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Int32
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Int32', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 4
-
-__o = __obj[50]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Int40
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Int40', 'UTF-8'))
-
-__o = __obj[51]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Int64
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Int64', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 8
-
-__o = __obj[52]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Int8
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Int8', 'UTF-8'))
-    __o['align'] = 1
-    __o['size'] = 1
-
-__o = __obj[53]  // gnu.targets.arm.GCArmv5T/stdTypes/t_LDouble
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_LDouble', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 8
-
-__o = __obj[54]  // gnu.targets.arm.GCArmv5T/stdTypes/t_LLong
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_LLong', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 8
-
-__o = __obj[55]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Long
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Long', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 4
-
-__o = __obj[56]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Ptr
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Ptr', 'UTF-8'))
-    __o['align'] = 4
-    __o['size'] = 4
-
-__o = __obj[57]  // gnu.targets.arm.GCArmv5T/stdTypes/t_Short
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FstdTypes%2Ft_Short', 'UTF-8'))
-    __o['align'] = 2
-    __o['size'] = 2
-
-__o = __obj[58]  // gnu.targets.arm.GCArmv5T/versionMap
-    __o['$name'] = String(java.net.URLDecoder.decode('gnu.targets.arm.GCArmv5T%2FversionMap', 'UTF-8'))
-    __o['gcc3.2'] = String(java.net.URLDecoder.decode('1%2C0%2C3.2%2C0', 'UTF-8'))
-
-__o = __obj[59]  
-
-delete __o
-delete __obj
\ No newline at end of file
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.rta.xml c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.rta.xml
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.rta.xml	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.rta.xml	1969-12-31 18:00:00.000000000 -0600
@@ -1,11 +0,0 @@
-<xdc.runtime.Types.RtaDecoderData>
-  <targetName>gnu.targets.arm.GCArmv5T</targetName>
-  <binaryParser>undefined</binaryParser>
-  <endian>little</endian>
-  <bitsPerChar>8</bitsPerChar>
-  <argSize>4</argSize>
-  <eventSize>48</eventSize>
-  <loggers-length>0</loggers-length>
-  <modMap-length>0</modMap-length>
-  <evtMap-length>0</evtMap-length>
-</xdc.runtime.Types.RtaDecoderData>
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.xdc.inc c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.xdc.inc
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.xdc.inc	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.xdc.inc	1969-12-31 18:00:00.000000000 -0600
@@ -1,2 +0,0 @@
-package.xs
-package/cfg/c6accelw_xv5T.cfg
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.xdl c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.xdl
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.xdl	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.xdl	1969-12-31 18:00:00.000000000 -0600
@@ -1,8 +0,0 @@
-/* this file was generated by linkcmd.xdt from the gnu.targets.arm
- * package
- */
-INPUT(
-    /usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw_config/package/cfg/c6accelw_xv5T.ov5T
-    /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/rtsv5T/lib/gnu.targets.arm.rtsv5T.av5T
-)
-
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.bld.xml c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.bld.xml
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.bld.xml	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.bld.xml	1969-12-31 18:00:00.000000000 -0600
@@ -1,71 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  This file conforms to the DTD xdc/bld/build.dtd -->
-<package name="c6accelw_config" version="" producerId="undefined">
-    <units>
-    </units>
-    <sources>
-        <srcFile name="package/cfg/c6accelw_xv5T.c"/>
-    </sources>
-    <configurations>
-        <srcFile name="/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw.cfg"/>
-    </configurations>
-    <makefiles>
-        <srcFile name="package.mak" src="package.bld"/>
-        <srcFile name="package/package.xdc.dep" src="package.xdc"/>
-        <srcFile name="package/cfg/c6accelw_xv5T.mak" src="package.bld"/>
-        <srcFile name="package/cfg/c6accelw_xv5T.ov5T.dep" src="package/cfg/c6accelw_xv5T.c"/>
-        <srcFile name="package/cfg/c6accelw_xv5T.dep" src="package/cfg/c6accelw_xv5T.cfg"/>
-        <srcFile name="package/rel/c6accelw_config.tar.dep" src="package/rel/c6accelw_config.xdc.inc"/>
-    </makefiles>
-    <targets>
-        <target name="gnu.targets.arm.GCArmv5T"
-            version="gnu.targets.arm.GCArmv5T{1,0,4.2,3"
-            platform="ti.platforms.evm3530"
-            isa="v5T"
-            suffix="v5T"
-            rootDir="/home/a0272049/arm-2008q1"
-            os="Linux"
-            rts="gnu.targets.arm.rtsv5T">
-            <model endian="little"
-                codeModel="undefined"
-                dataModel="undefined"/>
-        </target>
-    </targets>
-    <libraries>
-    </libraries>
-    <executables>
-    <executable name="c6accelw"
-        pname="c6accelw.xv5T"
-        target="gnu.targets.arm.GCArmv5T"
-        platform="ti.platforms.evm3530"
-        profile="release"
-        xCfgScript="package/cfg/c6accelw_xv5T.cfg"
-        xCfgPrefix="package/cfg/c6accelw_xv5T"
-        cfgScript="/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/c6accelw/c6accelw.cfg"
-        cfgArgs="null"
-        />
-    </executables>
-    <tests>
-    <test exeName="c6accelw.xv5T"
-        args=""
-        groupName="c6accelw.xv5T"
-        refOutput="undefined"
-        refExitCode="0"
-        execArgs=""
-        />
-    </tests>
-    <releases relDir="package/rel/">
-    <release name="c6accelw_config"
-        pname="c6accelw_config.tar"
-        label="default"
-    >
-        <file name="package/build.cfg"/>
-        <file name="package/package.ext.xml"/>
-        <file name="package/package.xdc.inc"/>
-        <file name="package/package.bld.xml"/>
-        <file name="package/package.rel.dot"/>
-    </release>
-    </releases>
-    <repositories>
-    </repositories>
-</package>
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package_c6accelw_config.c c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package_c6accelw_config.c
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package_c6accelw_config.c	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package_c6accelw_config.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,21 +0,0 @@
-/*
- *  Do not modify this file; it is automatically 
- *  generated and any modifications will be overwritten.
- *
- * @(#) xdc-t50
- */
-
-#include <xdc/std.h>
-
-__FAR__ char c6accelw_config__dummy__;
-
-#define __xdc_PKGVERS null
-#define __xdc_PKGNAME c6accelw_config
-#define __xdc_PKGPREFIX c6accelw_config_
-
-#ifdef __xdc_bld_pkg_c__
-#define __stringify(a) #a
-#define __local_include(a) __stringify(a)
-#include __local_include(__xdc_bld_pkg_c__)
-#endif
-
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.defs.h c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.defs.h
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.defs.h	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.defs.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,13 +0,0 @@
-/*
- *  Do not modify this file; it is automatically 
- *  generated and any modifications will be overwritten.
- *
- * @(#) xdc-t50
- */
-
-#ifndef c6accelw_config__
-#define c6accelw_config__
-
-
-
-#endif /* c6accelw_config__ */ 
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.doc.xml c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.doc.xml
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.doc.xml	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.doc.xml	1969-12-31 18:00:00.000000000 -0600
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<package kind='package' name='c6accelw_config' nodoc='1' root='../' summary='Package+generated+by+xdc.tools.configuro'>
-    <line tab='0' content='%3Cspan+class%3D%22xdoc-kw1%22%3Epackage%3C%2Fspan%3E+%3Cgo%3E%3Cspan+class%3D%22xdoc-id%22%3Ec6accelw_config%3C%2Fspan%3E%3C%2Fgo%3E+%7B'/>
-    <line tab='0' content='%7D'/>
-</package>
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.xdc.dep c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.xdc.dep
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.xdc.dep	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.xdc.dep	1969-12-31 18:00:00.000000000 -0600
@@ -1,61 +0,0 @@
-clean::
-	$(RM) package/c6accelw_config.sch
-	$(RM) package/.vers_g150
-	$(RM) package/.vers_r160
-	$(RM) package/.vers_b150
-	$(RM) package/.vers_c150
-	$(RM) package/.xdc-t50
-	$(RM) package/c6accelw_config.java
-	$(RM) package/c6accelw_config.class
-	$(RM) package/package_c6accelw_config.c
-	$(RM) package/package.defs.h
-	$(RM) package/package.doc.xml
-	$(RM) package/c6accelw_config.ccs
-
-.interfaces: package/c6accelw_config.sch package/.vers_g150 package/.vers_r160 package/.vers_b150 package/.vers_c150 package/.xdc-t50 package/c6accelw_config.java package/c6accelw_config.class package/package_c6accelw_config.c package/package.defs.h package/package.doc.xml package/c6accelw_config.ccs 
-package/package.xdc.inc: package/.vers_g150
-package/.vers_g150:
-package/package.xdc.inc: package/.vers_r160
-package/.vers_r160:
-package/package.xdc.inc: package/.vers_b150
-package/.vers_b150:
-package/package.xdc.inc: package/.vers_c150
-package/.vers_c150:
-
-.interfaces: 
-
-# schema include file dependencies
-package.xs:
-package/package.xdc.inc: package.xs
-
-# schema update dependencies
-package/package.xdc.inc: xdc/IPackage.xdc
-xdc/IPackage.xdc:
-vpath xdc/IPackage.xdc $(XPKGVPATH)
-
-ifneq (clean,$(MAKECMDGOALS))
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/java/package.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/java/package.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/antlr.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/antlr.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/jsr173_api.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/jsr173_api.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/ecj.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/ecj.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/spec/java/package.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/spec/java/package.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/js.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/js.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/intern/cmd/java/package.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/intern/cmd/java/package.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/tar.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/tar.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/intern/xsr/java/package.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/intern/xsr/java/package.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/intern/gen/java/package.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/intern/gen/java/package.jar
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/xbean.jar:
-package/package.xdc.inc: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/shelf/java/xbean.jar
-endif
-# goals for files generated during schema generation but unspecified by schema's pattern rule
-
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.xdc.inc c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.xdc.inc
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/package.xdc.inc	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/package.xdc.inc	1969-12-31 18:00:00.000000000 -0600
@@ -1,14 +0,0 @@
-package.xdc
-package.xs
-package/c6accelw_config.sch
-package/.vers_g150
-package/.vers_r160
-package/.vers_b150
-package/.vers_c150
-package/.xdc-t50
-package/c6accelw_config.java
-package/c6accelw_config.class
-package/package_c6accelw_config.c
-package/package.defs.h
-package/package.doc.xml
-package/c6accelw_config.ccs
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/rel/c6accelw_config.xdc.inc c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/rel/c6accelw_config.xdc.inc
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package/rel/c6accelw_config.xdc.inc	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package/rel/c6accelw_config.xdc.inc	1969-12-31 18:00:00.000000000 -0600
@@ -1,5 +0,0 @@
-package/build.cfg
-package/package.ext.xml
-package/package.xdc.inc
-package/package.bld.xml
-package/package.rel.dot
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package.mak c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package.mak
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/package.mak	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/package.mak	1969-12-31 18:00:00.000000000 -0600
@@ -1,237 +0,0 @@
-#
-#  Do not edit this file.  This file is generated from 
-#  package.bld.  Any modifications to this file will be 
-#  overwritten whenever makefiles are re-generated.
-#
-
-unexport MAKEFILE_LIST
-override PKGDIR = c6accelw_config
-XDCINCS = -I. -I$(strip $(subst ;, -I,$(subst $(space),\$(space),$(XPKGPATH))))
-XDCCFGDIR = package/cfg/
-
-#
-# The following dependencies ensure package.mak is rebuilt
-# in the event that some included BOM script changes.
-#
-ifneq (clean,$(MAKECMDGOALS))
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Library.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Library.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/template.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/template.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/Linux86.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/Linux86.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/ITarget.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/ITarget.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/package.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/package.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/tools/configuro/template/compiler.opt.xdt:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/tools/configuro/template/compiler.opt.xdt
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/om2.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/om2.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/tools/configuro/template/custom.mak.exe.xdt:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/tools/configuro/template/custom.mak.exe.xdt
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/targets/ITarget.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/targets/ITarget.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xmlgen2.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xmlgen2.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/targets/package.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/targets/package.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xmlgen.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xmlgen.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Executable.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Executable.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/MVArm9.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/MVArm9.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xdc.tci:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/xdc.tci
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/ITarget.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/ITarget.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/UCArm9.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/UCArm9.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/package.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/package.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/GCArmv6.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/GCArmv6.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/Clock.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/Clock.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Utils.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Utils.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/config.bld:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/config.bld
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/GCArmv7A.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/GCArmv7A.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Repository.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Repository.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/_gen.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/_gen.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/io/package.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/io/package.xs
-package.mak: config.bld
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/PackageContents.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/PackageContents.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/BuildEnvironment.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/BuildEnvironment.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/Mingw.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/Mingw.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/targets/MSP430.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/ti/targets/MSP430.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/include/utils.tci:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/include/utils.tci
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/tools/configuro/template/package.xs.xdt:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/tools/configuro/template/package.xs.xdt
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/Trace.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/global/Trace.xs
-package.mak: package.bld
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/IPackage.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/IPackage.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/ITargetFilter.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/ITargetFilter.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/io/File.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/services/io/File.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Script.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/bld/Script.xs
-/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/package.xs:
-package.mak: /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/xdc/package.xs
-endif
-
-gnu.targets.arm.GCArmv5T.rootDir ?= /home/a0272049/arm-2008q1
-gnu.targets.arm.packageBase ?= /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages/gnu/targets/arm/
-.PRECIOUS: $(XDCCFGDIR)/%.ov5T
-.PHONY: all,v5T .dlls,v5T .executables,v5T test,v5T
-all,v5T: .executables,v5T
-.executables,v5T: .libraries,v5T
-.executables,v5T: .dlls,v5T
-.dlls,v5T: .libraries,v5T
-.libraries,v5T: .interfaces
-	@$(RM) $@
-	@$(TOUCH) "$@"
-
-.help::
-	@$(ECHO) xdc test,v5T
-	@$(ECHO) xdc .executables,v5T
-	@$(ECHO) xdc .libraries,v5T
-	@$(ECHO) xdc .dlls,v5T
-
-
-all: .executables 
-.executables: .libraries .dlls
-.libraries: .interfaces
-
-PKGCFGS := $(wildcard package.xs) package/build.cfg
-.interfaces: package/package.xdc.inc package/package.defs.h package.xdc $(PKGCFGS)
-
--include package/package.xdc.dep
-package/%.xdc.inc package/%_c6accelw_config.c package/%.defs.h: %.xdc $(PKGCFGS)
-	@$(MSG) generating interfaces for package c6accelw_config" (because $@ is older than $(firstword $?))" ...
-	$(XSRUN) -f xdc/services/intern/cmd/build.xs $(MK_IDLOPTS) -m package/package.xdc.dep -i package/package.xdc.inc package.xdc
-
-.executables,v5T .executables: c6accelw.xv5T
-
--include package/cfg/c6accelw_xv5T.mak
-ifneq (clean,$(MAKECMDGOALS))
--include package/cfg/c6accelw_xv5T.dep
-endif
-package/cfg/c6accelw_xv5T.ov5T : | package/cfg/c6accelw_xv5T.xdl
-c6accelw.xv5T:
-	$(RM) $@
-	@$(MSG) lnkv5T $@ ...
-	$(gnu.targets.arm.GCArmv5T.rootDir)/bin/arm-none-linux-gnueabi-gcc    -o $@ package/cfg/c6accelw_xv5T.ov5T  package/cfg/c6accelw_xv5T.xdl  -lstdc++ -L$(gnu.targets.arm.GCArmv5T.rootDir)/arm-none-linux-gnueabi/lib
-	
-c6accelw.xv5T:LD_LIBRARY_PATH=
-
-
-ifeq (,$(wildcard .libraries,v5T))
-c6accelw.xv5T package/cfg/c6accelw_xv5T.c: .libraries,v5T
-endif
-
-package/cfg/c6accelw_xv5T.c package/cfg/c6accelw_xv5T.h package/cfg/c6accelw_xv5T.xdl: override _PROG_NAME := c6accelw.xv5T
-package/cfg/c6accelw_xv5T.c: package/cfg/c6accelw_xv5T.cfg
-c6accelw.test test,v5T test: c6accelw.xv5T.test
-
-c6accelw.xv5T.test:: c6accelw.xv5T
-ifeq (,$(_TESTLEVEL))
-	@$(MAKE) -R -r --no-print-directory -f $(XDCROOT)/packages/xdc/bld/xdc.mak _TESTLEVEL=1 c6accelw.xv5T.test
-else
-	@$(MSG) running $<  ...
-	$(call EXEC.c6accelw.xv5T, ) 
-endif
-
-
-clean:: clean,v5T
-	-$(RM) package/cfg/c6accelw_xv5T.cfg
-	-$(RM) package/cfg/c6accelw_xv5T.dep
-	-$(RM) package/cfg/c6accelw_xv5T.c
-	-$(RM) package/cfg/c6accelw_xv5T.xdc.inc
-
-clean,v5T::
-	-$(RM) c6accelw.xv5T
-	-$(RM) .tmp,c6accelw.xv5T,*
-
-%,copy:
-	@$(if $<,,$(MSG) don\'t know how to build $*; exit 1)
-	@$(MSG) cp $< $@
-	$(RM) $@
-	$(CP) $< $@
-c6accelw_xv5T.sv5T,copy : package/cfg/c6accelw_xv5T.sv5T
-c6accelw_xv5T.ov5T,copy : package/cfg/c6accelw_xv5T.ov5T
-
-$(XDCCFGDIR)%.c $(XDCCFGDIR)%.h $(XDCCFGDIR)%.xdl: $(XDCCFGDIR)%.cfg .interfaces $(XDCROOT)/packages/xdc/cfg/Main.xs
-	@$(MSG) "configuring $(_PROG_NAME) from $< ..."
-	$(CONFIG) $(_PROG_XSOPTS) xdc.cfg $(_PROG_NAME) $(XDCCFGDIR)$*.cfg $(XDCCFGDIR)$*
-
-.PHONY: release,c6accelw_config
-c6accelw_config.tar: package/build.cfg
-c6accelw_config.tar: package/package.ext.xml
-c6accelw_config.tar: package/package.xdc.inc
-c6accelw_config.tar: package/package.bld.xml
-c6accelw_config.tar: package/package.rel.dot
-ifneq (clean,$(MAKECMDGOALS))
--include package/rel/c6accelw_config.tar.dep
-endif
-package/rel/c6accelw_config/c6accelw_config/package/package.rel.xml:
-
-c6accelw_config.tar: package/rel/c6accelw_config.xdc.inc package/rel/c6accelw_config/c6accelw_config/package/package.rel.xml
-	@$(MSG) making release file $@ "(because of $(firstword $?))" ...
-	-$(RM) $@
-	$(call MKRELTAR,package/rel/c6accelw_config.xdc.inc,package/rel/c6accelw_config.tar.dep)
-
-
-release release,c6accelw_config: all c6accelw_config.tar
-clean:: .clean
-	-$(RM) c6accelw_config.tar
-	-$(RM) package/rel/c6accelw_config.xdc.inc
-	-$(RM) package/rel/c6accelw_config.tar.dep
-
-clean:: .clean
-	-$(RM) .libraries .libraries,*
-clean:: 
-	-$(RM) .dlls .dlls,*
-#
-# The following clean rule removes user specified
-# generated files or directories.
-#
-
-ifneq (clean,$(MAKECMDGOALS))
-ifeq (,$(wildcard package))
-    $(shell $(MKDIR) package)
-endif
-ifeq (,$(wildcard package/external))
-    $(shell $(MKDIR) package/external)
-endif
-ifeq (,$(wildcard package/lib))
-    $(shell $(MKDIR) package/lib)
-endif
-ifeq (,$(wildcard package/cfg))
-    $(shell $(MKDIR) package/cfg)
-endif
-ifeq (,$(wildcard package/rel))
-    $(shell $(MKDIR) package/rel)
-endif
-ifeq (,$(wildcard package/internal))
-    $(shell $(MKDIR) package/internal)
-endif
-endif
-clean::
-	-$(RMDIR) package
-
-include custom.mak
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/.xdcenv.mak c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/.xdcenv.mak
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw_config/.xdcenv.mak	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw_config/.xdcenv.mak	2010-08-14 17:17:15.000000000 -0500
@@ -1,16 +1,16 @@
 #
 _XDCBUILDCOUNT = 0
 ifneq (,$(findstring path,$(_USEXDCENV_)))
-override XDCPATH = /usr/devel/a0272049/dvsdk_3_00_02_44/codec_engine_2_24/examples;/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/dmai_2_00_01_04/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/framework_components_2_24/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/dsplink_1_61_03/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/xdais_6_24/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/linuxutils_2_24_02/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/codec_engine_2_24/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/local_power_manager_1_24/packages
-override XDCROOT = /usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59
+override XDCPATH = ^;/media/disk/openembedded/opencv-dsp-acceleration/dsp_opencv_c6accel;/media/disk/openembedded/opencv-dsp-acceleration/dsp_opencv_c6accel;/media/disk/openembedded/opencv-dsp-acceleration/dsp_opencv_c6accel/beagle/c6accel_1_00_00_04_async/soc/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/opencv-dsp-acceleration/c6accel_1_00_00_04_async;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-local-power-manager-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/dsplib_v210;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/imglib_v201
+override XDCROOT = /media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree
 override XDCBUILDCFG = ./config.bld
 endif
 ifneq (,$(findstring args,$(_USEXDCENV_)))
-override XDCARGS = "prod"
-override XDCTARGETS = 
+override XDCARGS = 
+override XDCTARGETS = gnu.targets.arm.GCArmv5T ti.targets.C64P
 endif
 #
 ifeq (0,1)
-PKGPATH = /usr/devel/a0272049/dvsdk_3_00_02_44/codec_engine_2_24/examples;/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/dmai_2_00_01_04/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/c6accel/soc/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/framework_components_2_24/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/dsplink_1_61_03/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/xdais_6_24/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/linuxutils_2_24_02/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/codec_engine_2_24/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/local_power_manager_1_24/packages;/usr/devel/a0272049/dvsdk_3_00_02_44/xdctools_3_15_01_59/packages;..
+PKGPATH = ^;/media/disk/openembedded/opencv-dsp-acceleration/dsp_opencv_c6accel;/media/disk/openembedded/opencv-dsp-acceleration/dsp_opencv_c6accel;/media/disk/openembedded/opencv-dsp-acceleration/dsp_opencv_c6accel/beagle/c6accel_1_00_00_04_async/soc/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/opencv-dsp-acceleration/c6accel_1_00_00_04_async;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-local-power-manager-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/dsplib_v210;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/imglib_v201;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree/packages;..
 HOSTOS = Linux
 endif
diff -uNr c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw.h c6accel_1_00_00_04_async/soc/c6accelw/c6accelw.h
--- c6accel_1_00_00_04_async0/soc/c6accelw/c6accelw.h	2010-07-29 09:58:05.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/c6accelw/c6accelw.h	2010-08-14 18:33:48.000000000 -0500
@@ -16,7 +16,10 @@
 
 #include <ti/sdo/ce/Engine.h>
 #include <ti/sdo/ce/universal/universal.h>
-
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #define SUPPORT_ASYNC
 
@@ -284,6 +287,17 @@
                                ,E_CALL_TYPE callType);
 #else 
                               );
+#endif
+
+/* This prototype is added by Pramod */
+ int C6accel_IMG_sobel_3x3_8_16(  C6accel_Handle hC6accel,
+                               const unsigned char *restrict in,   /* Input image data   */
+                               unsigned short       *restrict out,  /* Output image data  */
+                               short cols, short rows              /* Image dimensions   */
+#ifdef SUPPORT_ASYNC
+                               ,E_CALL_TYPE callType);
+#else 
+                              );
 #endif
 
  int C6accel_IMG_sobel_3x3_16(   C6accel_Handle hC6accel,
@@ -980,7 +994,65 @@
                             int        npoints
 );
 
+
+/* This prototype is added by Pramod */
+int C6accel_VLIB_integralImage8(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_pIn,             /* Input data pointer                        */
+                          unsigned short inCols,                        /* number of rows                            */
+			  unsigned short inRows,			/* number of cols                            */
+                          unsigned int * restrict ptr_pLastLine,        /* pointer to cols x 1 buffer for carry over */
+                          unsigned int * restrict ptr_pOut              /* output data pointer                       */
+#ifdef SUPPORT_ASYNC
+                          ,E_CALL_TYPE callType);
+#else 
+);
+#endif
+
+/* This prototype is added by Pramod */
+int C6accel_RGB_To_Y(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_src,       /* Pointer to input image in RGB format */
+                          unsigned char * restrict ptr_dst,       /* Pointer to Greyscale output image    */
+			  unsigned int count			  /* Total number of pixels               */
+#ifdef SUPPORT_ASYNC
+                          ,E_CALL_TYPE callType);
+#else 
+);
+#endif
+
+/* 				This prototype is added by Pramod                                   */
+/* This function call demonstrates chaining of C6accel library call to reduce codec-engine overhead */
+int C6accel_RGB_To_Y_IMG_sobel_3x3_8_16(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_src,       /* Pointer to input image in RGB format */
+                          unsigned char * restrict ptr_dst,       /* Pointer to Greyscale output image    */
+			  unsigned int count,			  /* Total number of pixels               */
+			  const unsigned char *restrict in,   /* Input image data   */
+                          unsigned short       *restrict out,  /* Output image data  */
+                          short cols, short rows              /* Image dimensions   */
 
+#ifdef SUPPORT_ASYNC
+                          		,E_CALL_TYPE callType);
+#else 
+);
+#endif
+
+/* 				This prototype is added by Pramod                                   */
+/* This function call performs various DFT/IDFT functions                                           */
+int C6accel_DSP_dft_f(C6accel_Handle hC6accel,
+                          void * restrict ptr_src,       /* Pointer to input array */
+                          void * restrict ptr_dst,       /* Pointer to output array    */
+			  
+			  int dxtType,				  /* Type of action to take */
+			  int nonZeroRows 			  /* Count of non-zero rows */
+   			  
+#ifdef SUPPORT_ASYNC
+                          		,E_CALL_TYPE callType);
+#else 
+);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
 
 
 #endif
diff -uNr c6accel_1_00_00_04_async0/soc/Makefile c6accel_1_00_00_04_async/soc/Makefile
--- c6accel_1_00_00_04_async0/soc/Makefile	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/Makefile	2010-08-14 17:17:16.000000000 -0500
@@ -8,7 +8,7 @@
 
 XDC = $(XDC_INSTALL_DIR)/xdc
 
-CROSS_COMPILE = $(CSTOOL_PREFIX)
+#CROSS_COMPILE = $(CSTOOL_PREFIX)
 XDCTARGETS = ti.targets.C$(DSP_ISA)
 XDCBUILDCFG=../config.bld
 
@@ -22,7 +22,7 @@
 export CODEGEN_INSTALL_DIR
 export XDCBUILDCFG
 export PLATFORM_XDC
-export CROSS_COMPILE
+#export CROSS_COMPILE
 export XDCTARGETS
 
 .PHONY: c6accelw codec_packages server c6accel_app release_packages clean clean_packages
diff -uNr c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/ce/.xdcenv.mak c6accel_1_00_00_04_async/soc/packages/ti/c6accel/ce/.xdcenv.mak
--- c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/ce/.xdcenv.mak	2010-07-28 05:21:21.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/packages/ti/c6accel/ce/.xdcenv.mak	2010-08-14 17:24:39.000000000 -0500
@@ -1,16 +1,16 @@
 #
 _XDCBUILDCOUNT = 0
 ifneq (,$(findstring path,$(_USEXDCENV_)))
-override XDCPATH = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/soc;packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdais_6_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/fctools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dspbios_5_41_03_17/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/biosutils_1_02_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/linuxutils_2_25_02_08/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/cetools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/edma3lld_01_11_00_03/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codecs-omapl138_1_10_00_01/packages
-override XDCROOT = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdctools_3_16_03_36
-override XDCBUILDCFG = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/config.bld
+override XDCPATH = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/soc;packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/fctools/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/cetools/packages;/packages;/packages
+override XDCROOT = /media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree
+override XDCBUILDCFG = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/config.bld
 endif
 ifneq (,$(findstring args,$(_USEXDCENV_)))
-override XDCARGS = "prod"
-override XDCTARGETS = ti.targets.C674
+override XDCARGS = 
+override XDCTARGETS = ti.targets.C64P
 endif
 #
 ifeq (0,1)
-PKGPATH = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/soc;packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdais_6_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/fctools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dspbios_5_41_03_17/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/biosutils_1_02_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/linuxutils_2_25_02_08/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/cetools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/edma3lld_01_11_00_03/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codecs-omapl138_1_10_00_01/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdctools_3_16_03_36/packages;../../..
+PKGPATH = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/soc;packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/fctools/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/cetools/packages;/packages;/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree/packages;../../..
 HOSTOS = Linux
 endif
diff -uNr c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/iC6Accel_ti.h c6accel_1_00_00_04_async/soc/packages/ti/c6accel/iC6Accel_ti.h
--- c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/iC6Accel_ti.h	2010-07-26 15:52:56.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/packages/ti/c6accel/iC6Accel_ti.h	2010-08-15 23:47:40.000000000 -0500
@@ -13,7 +13,9 @@
 *******************************************************************************/
 /* Include files */
 #include <ti/xdais/xdas.h>
-#include <ti/xdais/dm/iuniversal.h>
+#include <ti/xdais/dm/iuniversal.h>
+
+#include "../../../../dsp/libs/include/cxtypes.h" 
 
 #ifndef ti_sdo_codecs_C6Accel_C6ACCEL_TI_
 #define ti_sdo_codecs_C6Accel_C6ACCEL_TI_
@@ -39,7 +41,8 @@
 *         ** 0x04 : ANALYTICS Library                                                       *       
 *         ** 0x05 : MEDICAL Library                                                         *
 *         ** 0x06 : POWER CONTROL Library                                                   *
-*         ** 0x07 : AUDIO SPEECH Library                                                    *
+*         ** 0x07 : AUDIO SPEECH Library                                                    *
+*         ** 0x08 : VISION Library       (Added by Pramod)                                  *
 *    * 15-0 bits are used to identify the function within the library                       *
 *                                                                                           *
 *********************************************************************************************/
@@ -231,7 +234,10 @@
 #define IMG_CORR_3X3_I8_C8_FRAME_FXN_ID         0x01020061
 #define IMG_YCBCR422SP_TO_YCBCR420PL_FXN_ID     0x01020062
 #define IMG_YCBCR422SP_TO_YCBCR422ILE_FXN_ID    0x01020063
-#define IMG_YCBCR422PL_TO_YCBCR422SP_FXN_ID     0x01020064
+#define IMG_YCBCR422PL_TO_YCBCR422SP_FXN_ID     0x01020064
+
+/* Additional sobel kernel */
+#define IMG_SOBEL_3X3_8_16_FXN_ID         0x01020065  /* Added by Pramod */
 
 /************************************************************************/  
 /*                                                                      */
@@ -349,7 +355,34 @@
 /*     23-16 bits   Function type/Library ID : 0x07 (AUDSPECHLIB)      */  
 /*     15-0 bits are used to identify the function within the library  */        
 /**********************************************************************/
-/* To be added in Future Releases */
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                     */
+/*           VISION Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)               */           
+/*     23-16 bits   Function type/Library ID : 0x08 (VLIB)             */  
+/*     15-0 bits are used to identify the function within the library  */        
+/**********************************************************************/
+#define VLIB_INTEGRALIMAGE_8_FXN_ID       0x01080001  /* Added by Pramod */
+
+/**********************************************************************/  
+/*                                                                    */
+/*     Other Image Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x02 (OTHER)           */           
+/*     23-16 bits   Function type/Library ID : 0x02 (IMGLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define IMG_RGB_TO_Y_FXN_ID  		  0x02020001 /*Added by Pramod */
+
+/**********************************************************************/  
+/*                                                                    */
+/*     Other DSP Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x02 (OTHER)           */           
+/*     23-16 bits   Function type/Library ID : 0x01 (DSPLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define DSP_DFT_F_FXN_ID  		  0x02010001 /*Added by Pramod */
 
 /******************************************************************
 *  Constants to be shared by the codec and the application code   *
@@ -401,7 +434,34 @@
 *                                                                       *
 *************************************************************************/
 #define IUNIVERSAL_EPARAMFAIL IUNIVERSAL_EFAIL-5
-#define IUNIVERSAL_EFXNIDFAIL IUNIVERSAL_EFAIL-6
+#define IUNIVERSAL_EFXNIDFAIL IUNIVERSAL_EFAIL-6
+
+/************************************************************************
+* Defines Matrix type and number of channels for OpenCV Matrix.         *
+* Also defines method to extract type and cnannels of matrix of image   *
+*									*
+*************************************************************************/
+#define CN_MAX     64
+#define CN_SHIFT   3
+#define DEPTH_MAX  (1 << CN_SHIFT)
+#define MAT_CN_MASK          ((CN_MAX - 1) << CN_SHIFT)
+#define MAT_CN(flags)        ((((flags) & MAT_CN_MASK) >> CN_SHIFT) + 1)
+#define MAT_TYPE_MASK        (DEPTH_MAX*CN_MAX - 1)
+#define MAT_TYPE(flags)      ((flags) & MAT_TYPE_MASK)
+
+/************************************************************************
+* Defines different DFT Types for OpenCV                                *
+* Also defines method to extract type and cnannels of matrix of image   *
+*									*
+*************************************************************************/
+#define DXT_FORWARD  0
+#define DXT_INVERSE  1
+#define DXT_SCALE    2 /* divide result by size of array */
+#define DXT_INV_SCALE (CV_DXT_INVERSE + CV_DXT_SCALE)
+#define DXT_INVERSE_SCALE CV_DXT_INV_SCALE
+#define DXT_ROWS     4 /* transform each row individually */
+#define DXT_MUL_CONJ 8 /* conjugate the second argument of cvMulSpectrums */
+#define DXT_INVERSE_ROWS 16
     
 /************************* Common input structures ********************************************
 *  Fxn_struct:
@@ -410,7 +470,8 @@
 *  Every function in the API call will be contained in a seperate 
 *  fxn_struct. Multiple function calls are made using a single API call 
 *  by passing an array of Fxn_stuct in the extended Input Argument structure (IC6Accel_InArgs) 
-************************************************************************************************/
+************************************************************************************************/
+
 typedef struct{
                 int FxnID;
                 int  Param_ptr_offset;                       // This is the offset of the param structure within overall inArgs
@@ -958,7 +1019,15 @@
                                       unsigned int outdata_OutArrID1; 
                                       int Col;
                                       int Row;
-                                     }IMG_sobel_3x3_8_Params;
+                                     }IMG_sobel_3x3_8_Params;
+/* This struct is added by Pramod */
+/* Function call : void IMG_sobel_3x3_8_16(const unsigned char *in_data, unsigned short *out_data, short cols, short rows)*/
+typedef struct IMG_sobel_3x3_8_16_Params{
+                                      unsigned int indata_InArrID1;
+                                      unsigned int outdata_OutArrID1; 
+                                      int Col;
+                                      int Row;
+                                     }IMG_sobel_3x3_8_16_Params;
 
 /* Function call : void IMG_sobel_3x3_16s (const short *restrict in, const short *restrict out, short cols,
                                            short rows)*/
@@ -1907,8 +1976,66 @@
                             unsigned int z_InArrID1;
                             unsigned int OutArrID1;
                             unsigned int   n;
-                           }sqrtsp_Params;
-
+                           }sqrtsp_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Vision Library functions                    */
+/*                     Added by Pramod                                               */
+/*************************************************************************************/
+
+/* Function Call: int VLIB_integralImage8(unsigned char* restrict pIn,unsigned short  inCols,unsigned short  inRows,unsigned int* restrict pLastLine,   
+															unsigned int* restrict pOut)*/
+typedef struct VLIB_integralImage8_Params{
+                                         unsigned int pIn_InArrID1;         /* Input Image inCols x inRows */
+                                         unsigned short  inCols;            /* Number of inCols */
+					 unsigned short  inRows;            /* Number of inRowss */
+                                         unsigned int pLastLine_InArrID2;   /* 32-bit carry-over buffer */
+                                         unsigned int pOut_OutArrID1;       /* 32-bit output buffer */
+                                         }VLIB_integralImage8_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Other IMG Library functions                */
+/*                 Functionality Added by Pramod                                     */
+/*		   Kernel Provided by Gagan					     */
+/*************************************************************************************/
+
+/* Function Call: int IMG_RGB_To_Y(unsigned char* restrict src, unsigned char * restrict dst, unsigned int count)*/
+
+typedef struct IMG_RGB_To_Y_Params{
+				  unsigned int src_InArrID1;              /* Input RGB image         */
+				  unsigned int dst_OutArrID1;             /* Output greyscale image  */
+				  unsigned int count;			  /* Total Pixels	     */
+				  }IMG_RGB_To_Y_Params;
+
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Other DSP Library functions                */
+/*                 Functionality Added by Pramod                                     */
+/*		   								     */
+/*************************************************************************************/
+
+/* Function Call: int C6accel_DSP_dft_f(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_src,       
+                          unsigned char * restrict ptr_dst,       
+			  int cols, int rows,                     
+			  int srcMatFlag,		         
+			  int dstMatFlag,			  
+			  int dxtType,				 
+			  int nonZeroRows, 			  
+			  unsigned char *restrict pWorkingBuf,    
+                          unsigned char *restrict pWorkingBuf2)                         */
+
+typedef struct DSP_dft_f_Params{
+				  unsigned int src_InArrID1;              /* Pointer to input image */
+				  unsigned int dst_OutArrID1;             /* Pointer to Greyscale output image    */
+				  int dxtType;				  /* Type of action to take */ 
+				  int nonZeroRows; 			  /* Count of non-zero rows */
+				  IplImage src;
+				  IplImage dst;
+				  }DSP_dft_f_Params;
+
+			  
+			  
 /******************************************************************************
  *  ======== C6ACCEL_TI_IC6ACCEL ========
  *  Our implementation of the IUNIVERSAL interface
diff -uNr c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/iC6Accel_ti.h~ c6accel_1_00_00_04_async/soc/packages/ti/c6accel/iC6Accel_ti.h~
--- c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/iC6Accel_ti.h~	1969-12-31 18:00:00.000000000 -0600
+++ c6accel_1_00_00_04_async/soc/packages/ti/c6accel/iC6Accel_ti.h~	2010-08-15 02:30:57.000000000 -0500
@@ -0,0 +1,2061 @@
+/*******************************************************************************
+**+--------------------------------------------------------------------------+**
+ *                                                                            **
+ * Copyright (c) 2010, Texas Instruments Incorporated                         **
+ * All rights reserved.                                                       **
+ *                                                                            **
+**+--------------------------------------------------------------------------+**/
+/*******************************************************************************
+ *  ======== iC6Accel_ti.h ========                                           **
+ *   Application-Codec interface header file                                  **
+ *   Defines Function IDs, Input arguments and parameter structures           **
+ *   for kernels in C6Accel                                                   **
+*******************************************************************************/
+/* Include files */
+#include <ti/xdais/xdas.h>
+#include <ti/xdais/dm/iuniversal.h>
+
+#include "../../../../dsp/libs/include/cxtypes.h" 
+
+#include "../../../../dsp/libs/include/cxerror.h"
+
+#include "../../../../dsp/libs/include/cxcore.h"
+#include "../../../../dsp/libs/include/cvver.h"
+
+
+#ifndef ti_sdo_codecs_C6Accel_C6ACCEL_TI_
+#define ti_sdo_codecs_C6Accel_C6ACCEL_TI_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Codec engine allows passing 16 inbut and output buffers
+limiting the number of function call in C6Accel to 16 in each universal
+process call*/ 
+#define   MAX_FXN_CALLS 16
+
+/********************************************************************************************
+*    Function IDs for library functions                                                     *
+*                                                                                           *
+*    Format of the function Id uses                                                         *
+*    * 31-24 bits are used to identify the vendor (Default vendor TI with vendor code:0x01) *
+*    * 23-16 bits are used to identify the type of function                                 * 
+*         ** 0x01 : DSP library                                                             *
+*         ** 0x02 : IMAGE Library                                                           *
+*         ** 0x03 : MATH Library                                                            *
+*         ** 0x04 : ANALYTICS Library                                                       *       
+*         ** 0x05 : MEDICAL Library                                                         *
+*         ** 0x06 : POWER CONTROL Library                                                   *
+*         ** 0x07 : AUDIO SPEECH Library                                                    *
+*         ** 0x08 : VISION Library       (Added by Pramod)                                  *
+*    * 15-0 bits are used to identify the function within the library                       *
+*                                                                                           *
+*********************************************************************************************/
+/* Common Null ID */
+#define NULL_INDEX                        0x00000000
+
+/****************************************************************************/  
+/*                                                                    */
+/*           DSP Library functions                                    */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)              */           
+/*     23-16 bits   Function type/Library ID : 0x01 (DSPLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define DSP_FFT16x16_FXN_ID               0x01010000
+#define DSP_IFFT16x16_FXN_ID              0x01010001
+#define DSP_MAT_MUL_FXN_ID                0x01010002
+#define DSP_FIR_GEN_FXN_ID                0x01010003
+#define DSP_AUTOCOR_FXN_ID                0x01010004
+#define DSP_FIRLMS2_FXN_ID                0x01010005
+#define DSP_FFT16x16_IMRE_FXN_ID          0x01010006
+#define DSP_FFT16x16R_FXN_ID              0x01010007
+#define DSP_FFT16x32_FXN_ID               0x01010008
+#define DSP_FFT32x32_FXN_ID               0x01010009
+#define DSP_FFT32x32S_FXN_ID              0x0101000A
+#define DSP_IFFT16x16_IMRE_FXN_ID         0x0101000B
+#define DSP_IFFT16x32_FXN_ID              0x0101000C
+#define DSP_IFFT32x32_FXN_ID              0x0101000D
+#define DSP_FIR_CPLX_FXN_ID               0x0101000E
+#define DSP_FIR_CPLX_HM4X4_FXN_ID         0x0101000F
+#define DSP_FIR_GEN_HM17_RA8X8_FXN_ID     0x01010010
+#define DSP_FIR_R4_FXN_ID                 0x01010011
+#define DSP_FIR_R8_FXN_ID                 0x01010012
+#define DSP_FIR_R8_HM16_RM8A8X8_FXN_ID    0x01010013
+#define DSP_FIR_SYM_FXN_ID                0x01010014
+#define DSP_IIR_FXN_ID                    0x01010015
+#define DSP_IIR_LAT_FXN_ID                0x01010016
+#define DSP_DOTP_SQR_FXN_ID               0x01010017
+#define DSP_DOTPROD_FXN_ID                0x01010018
+#define DSP_MAXVAL_FXN_ID                 0x01010019
+#define DSP_MAXIDX_FXN_ID                 0x0101001A
+#define DSP_MINVAL_FXN_ID                 0x0101001B
+#define DSP_MUL32_FXN_ID                  0x0101001C
+#define DSP_NEG32_FXN_ID                  0x0101001D
+#define DSP_RECIP16_FXN_ID                0x0101001E
+#define DSP_VECSUMSQ_FXN_ID               0x0101001F
+#define DSP_W_VEC_FXN_ID                  0x01010020
+#define DSP_MAT_TRANS_FXN_ID              0x01010021
+#define DSP_BEXP_FXN_ID                   0x01010022
+#define DSP_BLK_ESWAP16_FXN_ID            0x01010023
+#define DSP_BLK_ESWAP32_FXN_ID            0x01010024
+#define DSP_BLK_ESWAP64_FXN_ID            0x01010025
+#define DSP_BLK_MOVE_FXN_ID               0x01010026
+#define DSP_FLTOQ15_FXN_ID                0x01010027
+#define DSP_MINERROR_FXN_ID               0x01010028
+#define DSP_Q15tOFL_FXN_ID                0x01010029
+
+
+/* Floating point DSPLIB kernels */
+#define DSPF_SP_FFTSPXSP_FXN_ID           0x01010400
+#define DSPF_SP_IFFTSPXSP_FXN_ID          0x01010401
+#define DSPF_SP_DOTPROD_FXN_ID            0x01010402
+#define DSPF_SP_AUTOCOR_FXN_ID            0x01010403
+#define DSPF_SP_FIR_GEN_FXN_ID            0x01010404
+#define DSPF_SP_FIR_CPLX_FXN_ID           0x01010405
+#define DSPF_SP_MAT_MUL_FXN_ID            0x01010406
+#define DSPF_SP_MAT_TRANS_FXN_ID          0x01010407
+#define DSPF_SP_IIR_FXN_ID                0x01010408
+#define DSPF_SP_CONV_FXN_ID               0x01010409
+#define DSPF_SP_VECMUL_FXN_ID             0x0101040A
+#define DSPF_SP_VECRECIP_FXN_ID           0x0101040B
+#define DSPF_SP_VECSUM_SQ_FXN_ID          0x0101040C
+#define DSPF_SP_W_VEC_FXN_ID              0x0101040D
+#define DSPF_SP_BIQUAD_FXN_ID             0x0101040E
+#define DSPF_SP_MAT_MUL_CPLX_FXN_ID       0x0101040F
+
+/**********************************************************************/  
+/*                                                                    */
+/*           Image Library functions                                  */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)              */           
+/*     23-16 bits   Function type/Library ID : 0x02 (IMGLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define IMG_BOUNDARY_8_FXN_ID             0x01020000
+#define IMG_BOUNDARY_16S_FXN_ID           0x01020001
+#define IMG_CLIPPING_16S_FXN_ID           0x01020002
+#define IMG_YC_DEMUX_BE16_16_FXN_ID       0x01020003
+#define IMG_YC_DEMUX_LE16_16_FXN_ID       0x01020004
+#define IMG_DILATE_BIN_FXN_ID             0x01020005
+#define IMG_ERODE_BIN_FXN_ID              0x01020006
+#define IMG_ERRDIF_BIN_8_FXN_ID           0x01020007
+#define IMG_ERRDIF_BIN_16_FXN_ID          0x01020008
+#define IMG_HISTOGRAM_8_FXN_ID            0x01020009
+#define IMG_HISTOGRAM_16_FXN_ID           0x0102000A
+#define IMG_MEDIAN_3X3_8_FXN_ID           0x0102000B
+#define IMG_PERIMETER_8_FXN_ID            0x0102000C
+#define IMG_PERIMETER_16_FXN_ID           0x0102000D
+#define IMG_PIX_EXPAND_FXN_ID             0x0102000E
+#define IMG_PIX_SAT_FXN_ID                0x0102000F
+#define IMG_SOBEL_3X3_8_FXN_ID            0x01020010
+#define IMG_SOBEL_3X3_16S_FXN_ID          0x01020011
+#define IMG_SOBEL_3X3_16_FXN_ID           0x01020012
+#define IMG_SOBEL_5X5_16S_FXN_ID          0x01020013
+#define IMG_SOBEL_7X7_16S_FXN_ID          0x01020014
+#define IMG_THR_GT2MAX_8_FXN_ID           0x01020015
+#define IMG_THR_GT2MAX_16_FXN_ID          0x01020016
+#define IMG_THR_GT2THR_8_FXN_ID           0x01020017
+#define IMG_THR_GT2THR_16_FXN_ID          0x01020018
+#define IMG_THR_LE2MIN_8_FXN_ID           0x01020019
+#define IMG_THR_LE2MIN_16_FXN_ID          0x0102001A
+#define IMG_THR_LE2THR_8_FXN_ID           0x0102001B
+#define IMG_THR_LE2THR_16_FXN_ID          0x0102001C
+#define IMG_YCBCR422P_RGB565_FXN_ID       0x0102001D
+#define IMG_CONV_3X3_I8_C8S_FXN_ID        0x0102001E
+#define IMG_CONV_3X3_I16S_C16S_FXN_ID     0x0102001F
+#define IMG_CONV_3X3_I16_C16S_FXN_ID      0x01020020
+#define IMG_CONV_5X5_I8_C8S_FXN_ID        0x01020021
+#define IMG_CONV_5X5_I16S_C16S_FXN_ID     0x01020022
+#define IMG_CONV_5X5_I8_C16S_FXN_ID       0x01020023
+#define IMG_CONV_7X7_I8_C8S_FXN_ID        0x01020024
+#define IMG_CONV_7X7_I16S_C16S_FXN_ID     0x01020025
+#define IMG_CONV_7X7_I8_C16S_FXN_ID       0x01020026
+#define IMG_CONV_11X11_I8_C8S_FXN_ID      0x01020027
+#define IMG_CONV_11X11_I16S_C16S_FXN_ID   0x01020028
+#define IMG_CORR_3X3_I8_C16S_FXN_ID       0x01020029
+#define IMG_CORR_3X3_I16S_C16S_FXN_ID     0x0102002A
+#define IMG_CORR_3X3_I8_C8_FXN_ID         0x0102002B
+#define IMG_CORR_3X3_I16_C16S_FXN_ID      0x0102002C
+#define IMG_CORR_5X5_I16S_C16S_FXN_ID     0x0102002D
+#define IMG_CORR_11X11_I16S_C16S_FXN_ID   0x0102002E
+#define IMG_CORR_11X11_I8_C16S_FXN_ID     0x0102002F
+#define IMG_CORR_GEN_I16S_C16S_FXN_ID     0x01020030
+#define IMG_CORR_GEN_IQ_FXN_ID            0x01020031
+#define IMG_MEDIAN_3X3_16S_FXN_ID         0x01020032
+#define IMG_MEDIAN_3X3_16_FXN_ID          0x01020033
+#define IMG_YC_DEMUX_BE16_8_FXN_ID        0x01020034
+#define IMG_YC_DEMUX_LE8_C_FXN_ID         0x01020035
+#define IMG_FDCT_8X8_FXN_ID               0x01020036
+#define IMG_IDCT_8X8_12Q4_FXN_ID          0x01020037
+#define IMG_MAD_8X8_FXN_ID                0x01020038
+#define IMG_MAD_16X16_FXN_ID              0x01020039
+#define IMG_MPEG2_VLD_INTRA_FXN_ID        0x0102003A
+#define IMG_MPEG2_VLD_INTER_FXN_ID        0x0102003B
+#define IMG_QUANTIZE_FXN_ID               0x0102003C
+#define IMG_SAD_8X8_FXN_ID                0x0102003D
+#define IMG_SAD_16X16_FXN_ID              0x0102003E
+#define IMG_WAVE_HORZ_FXN_ID              0x0102003F
+#define IMG_WAVE_VERT_FXN_ID              0x01020040
+
+/*Low level IMGLIB functions*/
+#define IMG_MULS_16S_FXN_ID               0x01020041
+#define IMG_MULS_8_FXN_ID                 0x01020042
+#define IMG_ADDS_16S_FXN_ID               0x01020043
+#define IMG_ADDS_8_FXN_ID                 0x01020044
+#define IMG_SUBS_16S_FXN_ID               0x01020045
+#define IMG_SUBS_8_FXN_ID                 0x01020046
+#define IMG_NOT_16_FXN_ID                 0x01020047
+#define IMG_NOT_8_FXN_ID                  0x01020048
+#define IMG_ANDS_16_FXN_ID                0x01020049
+#define IMG_ANDS_8_FXN_ID                 0x0102004A
+#define IMG_ORS_16_FXN_ID                 0x0102004B
+#define IMG_ORS_8_FXN_ID                  0x0102004C
+#define IMG_AND_16_FXN_ID                 0x0102004D 
+#define IMG_AND_8_FXN_ID                  0x0102004E
+#define IMG_OR_16_FXN_ID                  0x0102004F 
+#define IMG_OR_8_FXN_ID                   0x01020050
+#define IMG_MUL_16S_FXN_ID                0x01020051
+#define IMG_MUL_8_FXN_ID                  0x01020052
+#define IMG_ADD_16S_FXN_ID                0x01020053
+#define IMG_ADD_8_FXN_ID                  0x01020054
+#define IMG_SUB_16S_FXN_ID                0x01020055
+#define IMG_SUB_8_FXN_ID                  0x01020056
+
+/*Additional IMGLIB KERNELS*/
+#define IMG_YUV420PL_RGB565_FXN_ID        0x01020057
+#define IMG_YCBCR422PL16_RGB565_FXN_ID    0x01020058
+#define IMG_YUV420PL16_RGB565_FXN_ID      0x01020059
+
+
+/* Additional Frame based IMG kernels for better performance */
+#define IMG_MEDIAN_3X3_8_FRAME_FXN_ID     0x0102005A
+#define IMG_MEDIAN_3X3_16S_FRAME_FXN_ID   0x0102005B
+#define IMG_MEDIAN_3X3_16_FRAME_FXN_ID    0x0102005C
+
+/* Optimized version of existing IMG lib kernels */
+#define IMG_CONV_3X3_I8_C8S_FRAME_FXN_ID        0x0102005D
+#define IMG_CONV_3X3_I16S_C16S_FRAME_FXN_ID     0x0102005E
+#define IMG_CORR_3X3_I8_C16S_FRAME_FXN_ID       0x0102005F
+#define IMG_CORR_3X3_I16S_C16S_FRAME_FXN_ID     0x01020060
+#define IMG_CORR_3X3_I8_C8_FRAME_FXN_ID         0x01020061
+#define IMG_YCBCR422SP_TO_YCBCR420PL_FXN_ID     0x01020062
+#define IMG_YCBCR422SP_TO_YCBCR422ILE_FXN_ID    0x01020063
+#define IMG_YCBCR422PL_TO_YCBCR422SP_FXN_ID     0x01020064
+
+/* Additional sobel kernel */
+#define IMG_SOBEL_3X3_8_16_FXN_ID         0x01020065  /* Added by Pramod */
+
+/************************************************************************/  
+/*                                                                      */
+/*           MATH Library functions                                     */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)                */           
+/*     23-16 bits   Function type/Library ID : 0x03 (IQMATHLIB)         */  
+/*     15-0 bits are used to identify the function within the library   */        
+/************************************************************************/
+#define MATH_IQNMPY_FXN_ID                0x01030000
+#define MATH_IQNSQRT_FXN_ID               0x01030001
+#define MATH_IQNSIN_FXN_ID                0x01030002
+#define MATH_IQNCOS_FXN_ID                0x01030003
+#define MATH_IQNDIV_FXN_ID                0x01030004
+#define MATH_IQNATAN2_FXN_ID              0x01030005
+#define MATH_IQNEXP_FXN_ID                0x01030006
+#define MATH_IQNLOG_FXN_ID                0x01030007
+#define MATH_IQNRMPY_FXN_ID               0x01030008
+#define MATH_IQNRSMPY_FXN_ID              0x01030009
+#define MATH_IQNASIN_FXN_ID               0x0103000A
+#define MATH_IQNACOS_FXN_ID               0x0103000B
+#define MATH_IQNSINPU_FXN_ID              0x0103000C
+#define MATH_IQNCOSPU_FXN_ID              0x0103000D
+#define MATH_IQNATAN2PU_FXN_ID            0x0103000E
+#define MATH_IQNMPYIQX_FXN_ID             0x0103000F
+#define MATH_IQNMPYI32INT_FXN_ID          0x01030010
+#define MATH_IQNMPYI32FRAC_FXN_ID         0x01030011
+#define MATH_IQNABS_FXN_ID                0x01030012
+#define MATH_IQNTOF_FXN_ID                0x01030013
+#define MATH_IQTOIQN_FXN_ID               0x01030014
+#define MATH_IQNPOW_FXN_ID                0x01030015
+#define MATH_IQNISQRT_FXN_ID              0x01030016
+#define MATH_IQNMAG_FXN_ID                0x01030017
+
+/* FASTRTS LIB kernels for C64x devices */
+#define MATH_ADDSP_FXN_ID                 0x01030018
+#define MATH_SUBSP_FXN_ID                 0x01030019
+#define MATH_MPYSP_FXN_ID                 0x0103001A
+#define MATH_DIVSP_FXN_ID                 0x0103001B
+#define MATH_RECIPSP_FXN_ID               0x0103001C
+#define MATH_INTSP_FXN_ID                 0x0103001D
+#define MATH_SPINT_FXN_ID                 0x0103001E
+#define MATH_SPUINT_FXN_ID                0x0103001F
+#define MATH_SQRTSP_FXN_ID                0x01030020
+#define MATH_UINTSP_FXN_ID                0x01030021
+
+/*Format conversion kernels in IQMATH lib*/
+#define MATH_FTOIQN_FXN_ID                0x01030022
+#define MATH_IQN_FXN_ID                   0x01030023
+#define MATH_IQXTOIQY_FXN_ID              0x01030024
+#define MATH_IQNINT_FXN_ID                0x01030025
+#define MATH_IQNFRAC_FXN_ID               0x01030026
+
+/* Fast RTS functions from 674x math library */
+#define MATH_ATANDP_FXN_ID                0x01030200
+#define MATH_ATANSP_FXN_ID                0x01030201
+#define MATH_ATAN2DP_FXN_ID               0x01030202
+#define MATH_ATAN2SP_FXN_ID               0x01030203
+#define MATH_COSDP_FXN_ID                 0x01030204
+#define MATH_COSSP_FXN_ID                 0x01030205
+#define MATH_DIVDP_FXN_ID                 0x01030206
+#define MATH_EXPDP_FXN_ID                 0x01030207
+#define MATH_EXPSP_FXN_ID                 0x01030208
+#define MATH_EXP2DP_FXN_ID                0x01030209
+#define MATH_EXP2SP_FXN_ID                0x0103020A
+#define MATH_EXP10DP_FXN_ID               0x0103020B
+#define MATH_EXP10SP_FXN_ID               0x0103020C
+#define MATH_LOGDP_FXN_ID                 0x0103020D
+#define MATH_LOGSP_FXN_ID                 0x0103020E
+#define MATH_LOG2DP_FXN_ID                0x0103021F
+#define MATH_LOG2SP_FXN_ID                0x01030220
+#define MATH_LOG10DP_FXN_ID               0x01030211
+#define MATH_LOG10SP_FXN_ID               0x01030212
+#define MATH_POWDP_FXN_ID                 0x01030213
+#define MATH_POWSP_FXN_ID                 0x01030214
+#define MATH_RECIPF_FXN_ID                0x01030215
+#define MATH_RECIPDP_FXN_ID               0x01030216
+#define MATH_RSQRTDP_FXN_ID               0x01030217
+#define MATH_RSQRTSP_FXN_ID               0x01030218
+#define MATH_SINDP_FXN_ID                 0x01030219
+#define MATH_SINSP_FXN_ID                 0x0103021A
+#define MATH_SQRTDP_FXN_ID                0x0103021B
+#define MATH_SQRT_FXN_ID                  0x0103021C
+
+/**********************************************************************/  
+/*                                                                    */
+/*           ANALYTICS Library functions                              */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)              */           
+/*     23-16 bits   Function type/Library ID : 0x04 (ANALYTICSLIB)    */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                    */
+/*           MEDICAL Library functions                              */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)              */           
+/*     23-16 bits   Function type/Library ID : 0x05 (MEDICALLIB)    */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                     */
+/*           POWER CONTROL Library functions                           */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)               */           
+/*     23-16 bits   Function type/Library ID : 0x06 (PWRCNTRLLIB)      */  
+/*     15-0 bits are used to identify the function within the library  */        
+/**********************************************************************/
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                     */
+/*           AUDIO SPEECH Library functions                            */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)               */           
+/*     23-16 bits   Function type/Library ID : 0x07 (AUDSPECHLIB)      */  
+/*     15-0 bits are used to identify the function within the library  */        
+/**********************************************************************/
+/* To be added in Future Releases */
+
+/**********************************************************************/  
+/*                                                                     */
+/*           VISION Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x01 (TI)               */           
+/*     23-16 bits   Function type/Library ID : 0x08 (VLIB)             */  
+/*     15-0 bits are used to identify the function within the library  */        
+/**********************************************************************/
+#define VLIB_INTEGRALIMAGE_8_FXN_ID       0x01080001  /* Added by Pramod */
+
+/**********************************************************************/  
+/*                                                                    */
+/*     Other Image Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x02 (OTHER)           */           
+/*     23-16 bits   Function type/Library ID : 0x02 (IMGLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define IMG_RGB_TO_Y_FXN_ID  		  0x02020001 /*Added by Pramod */
+
+/**********************************************************************/  
+/*                                                                    */
+/*     Other DSP Library functions (Added by Pramod)                */
+/*     31-24 bits   Vendor ID                : 0x02 (OTHER)           */           
+/*     23-16 bits   Function type/Library ID : 0x01 (DSPLIB)          */  
+/*     15-0 bits are used to identify the function within the library */        
+/**********************************************************************/
+#define DSP_DFT_F_FXN_ID  		  0x02010001 /*Added by Pramod */
+
+/******************************************************************
+*  Constants to be shared by the codec and the application code   *
+*******************************************************************/
+/* Input buffer ID */
+ #define INBUF0  0
+ #define INBUF1  1
+ #define INBUF2  2
+ #define INBUF3  3
+ #define INBUF4  4
+ #define INBUF5  5
+ #define INBUF6  6
+ #define INBUF7  7
+ #define INBUF8  8
+ #define INBUF9  9
+ #define INBUF10 10
+ #define INBUF11 11
+ #define INBUF12 12
+ #define INBUF13 13
+ #define INBUF14 14
+ #define INBUF15 15
+
+
+/* Output buffer ID  */
+ #define OUTBUF0  0
+ #define OUTBUF1  1
+ #define OUTBUF2  2
+ #define OUTBUF3  3
+ #define OUTBUF4  4
+ #define OUTBUF5  5
+ #define OUTBUF6  6
+ #define OUTBUF7  7
+ #define OUTBUF8  8
+ #define OUTBUF9  9
+ #define OUTBUF10 10
+ #define OUTBUF11 11
+ #define OUTBUF12 12
+ #define OUTBUF13 13
+ #define OUTBUF14 14
+ #define OUTBUF15 15
+
+/************************************************************************ 
+* Error check extention is introduced in return type of the Universal   *
+* Process call by defining the following error msg                      *
+* Error codes                                                           *
+*                                                                       *
+*   *  IUNIVERSAL_EPARAMFAIL : Error in parameters passed               *
+*   *  IUNIVERSAL_EFXNIDFAIL : Error on Function ID or NULL ID passed   *
+*                                                                       *
+*************************************************************************/
+#define IUNIVERSAL_EPARAMFAIL IUNIVERSAL_EFAIL-5
+#define IUNIVERSAL_EFXNIDFAIL IUNIVERSAL_EFAIL-6
+
+/************************************************************************
+* Defines Matrix type and number of channels for OpenCV Matrix.         *
+* Also defines method to extract type and cnannels of matrix of image   *
+*									*
+*************************************************************************/
+#define CN_MAX     64
+#define CN_SHIFT   3
+#define DEPTH_MAX  (1 << CN_SHIFT)
+#define MAT_CN_MASK          ((CN_MAX - 1) << CN_SHIFT)
+#define MAT_CN(flags)        ((((flags) & MAT_CN_MASK) >> CN_SHIFT) + 1)
+#define MAT_TYPE_MASK        (DEPTH_MAX*CN_MAX - 1)
+#define MAT_TYPE(flags)      ((flags) & MAT_TYPE_MASK)
+
+/************************************************************************
+* Defines different DFT Types for OpenCV                                *
+* Also defines method to extract type and cnannels of matrix of image   *
+*									*
+*************************************************************************/
+#define DXT_FORWARD  0
+#define DXT_INVERSE  1
+#define DXT_SCALE    2 /* divide result by size of array */
+#define DXT_INV_SCALE (CV_DXT_INVERSE + CV_DXT_SCALE)
+#define DXT_INVERSE_SCALE CV_DXT_INV_SCALE
+#define DXT_ROWS     4 /* transform each row individually */
+#define DXT_MUL_CONJ 8 /* conjugate the second argument of cvMulSpectrums */
+#define DXT_INVERSE_ROWS 16
+    
+/************************* Common input structures ********************************************
+*  Fxn_struct:
+*  Fxn_struct is a structure used to pass the function Id and
+*  the parameters to the function being called in the API call.
+*  Every function in the API call will be contained in a seperate 
+*  fxn_struct. Multiple function calls are made using a single API call 
+*  by passing an array of Fxn_stuct in the extended Input Argument structure (IC6Accel_InArgs) 
+************************************************************************************************/
+
+typedef struct{
+                int FxnID;
+                int  Param_ptr_offset;                       // This is the offset of the param structure within overall inArgs
+               }Fxn_struct;
+
+
+/**********************Extended Input Structure IC6Accel_InArgs****************************************
+* IC6xPP_InArgs is an extended input argumet structure that follows the 
+ structure format as defined in InBufs and OutBufs. It carries with it,
+ the number of function calls defined in the API call and the an Array of Fxn_structs (defined abover)
+ to carry the parameters attributed to the corresponding function call
+*******************************************************************************************************/
+typedef struct {
+                int size;
+                int Num_fxns;
+                Fxn_struct fxn[MAX_FXN_CALLS];
+} IC6Accel_InArgs ;
+
+
+/************************Parameter structure for the DSP Library functions*******************************
+*    
+*  * All input and output arrays/buffers are passed using inBufs abd outBufs in the Iuniversal framework
+*  * Parameter structures carry inBufs IDs and outBuf IDs of parameter arrays and the scalar parameters  
+*  
+*  Naming Convention for Array IDs: [Format:  Prefix_ArrayID]
+*                 
+*                Prefix: parameter name as specified in library documentation
+*                ArrayID#:      InArrID : Input array ID
+*                               OutArrID: Output arrayID
+*                                 # : Order Number in set of arrays in the parameter set 
+*********************************************************************************************************/                            
+
+/* Function Call: void DSP_fft16x16(short * restrict w, int nx, short * restrict x, short * restrict y)*/
+typedef struct DSP_fft16x16_Params{
+                                    unsigned int w_InArrID1;    /* twiddle factor */
+                                    int  nx;                    /* Number of points*/
+                                    unsigned int x_InArrID2;    /* Input signal*/
+                                    unsigned int y_OutArrID1;   /* FFT output */
+                                   }DSP_fft16x16_Params;
+
+/* Function call: void DSP_ifft16x16(short *w, int nx, short *x, short *y)                              */
+typedef struct DSP_ifft16x16_Params{
+                                     unsigned int w_InArrID1;    /* twiddle factor */
+                                     int  nx;                    /* Number of points*/
+                                     unsigned int x_InArrID2;    /* Input signal*/
+                                     unsigned int y_OutArrID1;   /* IFFT output */
+                                   }DSP_ifft16x16_Params;
+
+/* Function call : void DSP_mat_mul(short * restrict x, int r1, int c1, short * restrict y, int c2, short
+* restrict r, int qs)                                                                                   */
+typedef struct DSP_mat_mul_Params{ 
+                                   unsigned int x_InArrID1;
+                                   int  r1;
+                                   int  c1;
+                                   unsigned int y_InArrID2;
+                                   int  c2;
+                                   unsigned int r_OutArrID1;
+                                   int  qs;
+                                  }DSP_mat_mul_Params;
+
+/* Function call : DSP_fir_gen (short * restrict x, short * restrict h, short * restrict r, int nh,int nr)*/
+typedef struct DSP_fir_gen_Params{ 
+                                   unsigned int x_InArrID1;
+                                   unsigned int h_InArrID2;
+                                   unsigned int r_OutArrID1;
+                                   int  nh;
+                                   int  nr;
+                                  }DSP_fir_gen_Params;
+
+/*Function call : DSP_autocor(short * restrict r, short * restrict x, int nx, int nr)*/
+typedef struct DSP_autocor_Params{ 
+                                   unsigned int r_OutArrID1;
+                                   unsigned int x_InArrID1;
+                                   int  nx;
+                                   int  nr;
+                                  }DSP_autocor_Params;
+
+/*Function call : DSP_firlms2(short *h, short *x, short b, int nh)*/
+typedef struct DSP_firlms2_Params{ 
+                                   unsigned int  h_InArrID1;
+                                   unsigned int  x_InArrID2;
+                                   short b;
+                                   int   nh;
+                                   unsigned int  OutArrID1;
+                                  }DSP_firlms2_Params;
+
+/*Function call : void DSP_fft16x16_imre(short *w, int nx, short *x, short *y)  */
+typedef struct DSP_fft16x16_imre_Params{
+                                         unsigned int w_InArrID1;    /* twiddle factor */
+                                         int  nx;                    /* Number of points*/
+                                         unsigned int x_InArrID2;    /* Input signal*/
+                                         unsigned int y_OutArrID1;   /* FFT output */
+                                       }DSP_fft16x16_imre_Params;
+
+/* Function call : void DSP_fft16x16r(int nx, short *x, short *w, unsigned char *brev, short *y, 
+                                                                           int offset, int n_max)*/
+typedef struct DSP_fft16x16r_Params{
+                                     int  nx;
+                                     unsigned int x_InArrID1;
+                                     unsigned int w_InArrID2;
+                                     unsigned int OutArrID1;
+                                     int  radix;
+                                     int  offset;
+                                     int  nmax;
+                                    }DSP_fft16x16r_Params;
+
+/* Function call : void DSP_fft16x32(short *w, int nx, int *x, int *y)*/
+typedef struct DSP_fft16x32_Params{
+                                    unsigned int w_InArrID1;
+                                    int  nx;
+                                    unsigned int x_InArrID2;
+                                    unsigned int y_OutArrID1;
+                                   }DSP_fft16x32_Params;
+
+/* Function call : DSP_fft32x32(short *w, int nx, short *x, short *y) */
+typedef struct DSP_fft32x32_Params{
+                                    unsigned int w_InArrID1;
+                                    int  nx;
+                                    unsigned int x_InArrID2;
+                                    unsigned int y_OutArrID1;
+                                   }DSP_fft32x32_Params;
+
+/* Function call : void DSP_fft32x32s(int *w, int nx, int *x, int *y)*/
+typedef struct DSP_fft32x32s_Params{
+                                     unsigned int w_InArrID1;
+                                     int  nx;
+                                     unsigned int x_InArrID2;
+                                     unsigned int y_OutArrID1;
+                                    }DSP_fft32x32s_Params;
+
+/* Function call : void DSP_ifft16x16_imre(short * restrict w, int nx, short * restrict x, short * restrict y)*/
+typedef struct DSP_ifft16x16_imre_Params{
+                                         unsigned int w_InArrID1; /* twiddle factor */
+                                         int  nx;                 /* Number of points*/
+                                         unsigned int x_InArrID2; /* Input signal*/
+                                         unsigned int Y_OutArrID1;/* FFT output */
+                                        }DSP_ifft16x16_imre_Params;
+
+/* Function call : void DSP_ifft16x32(short * restrict w, int nx, int * restrict x, int * restrict y)*/
+typedef struct DSP_ifft16x32_Params{
+                                     unsigned int w_InArrID1;
+                                     int  nx;
+                                     unsigned int x_InArrID2;
+                                     unsigned int y_OutArrID1;
+                                    }DSP_ifft16x32_Params;
+
+/* Function call : DSP_ifft32x32(short *w, int nx, short *x, short *y) */
+typedef struct DSP_ifft32x32_Params{
+                                     unsigned int w_InArrID1;
+                                     int  nx;
+                                     unsigned int x_InArrID2;
+                                     unsigned int y_OutArrID1;
+                                    }DSP_ifft32x32_Params;
+
+/* Function call : void DSP_fir_cplx (short * restrict x, short * restrict h, short * restrict r, int nh, int nr)*/
+typedef struct DSP_fir_cplx_Params{
+                                    unsigned int x_InArrID1;
+                                    unsigned int h_InArrID2;
+                                    unsigned int r_OutArrID1;
+                                    int  nh;
+                                    int  nr;
+                                   }DSP_fir_cplx_Params;
+
+/* Function call : DSP_fir_cplx _hM4X4(short * restrict x, short * restrict h, short * restrict r, int nh, int nr) */
+typedef struct DSP_fir_cplx_hM4X4_Params{
+                                          unsigned int x_InArrID1;
+                                          unsigned int h_InArrID2;
+                                          unsigned int r_OutArrID1;
+                                          int  nh;
+                                          int  nr;
+                                         }DSP_fir_cplx_hM4X4_Params;
+
+/* Function call : void DSP_fir_gen_hM17_rA8X8 (short * restrict x, short * restrict h, short * restrict r,
+                                                                                        int nh, int nr)*/
+typedef struct DSP_fir_gen_hM17_rA8X8_Params{
+                                              unsigned int InArrID1;
+                                              unsigned int InArrID2;
+                                              unsigned int OutArrID1;
+                                              int nh;
+                                              int nr;
+                                             }DSP_fir_gen_hM17_rA8X8_Params;
+
+/* Function call : void DSP_fir_r4 (short * restrict x, short * restrict h, short * restrict r, int nh,
+                                                                                               int nr)*/
+typedef struct DSP_fir_r4_Params{
+                                  unsigned int x_InArrID1;
+                                  unsigned int h_InArrID2;
+                                  unsigned int r_OutArrID1;
+                                  int  nh;
+                                  int  nr;
+                                 }DSP_fir_r4_Params;
+
+/* Function call : void DSP_fir_r8 (short * restrict x, short * h, short * restrict r, int nh, int nr)*/
+typedef struct DSP_fir_r8_Params{
+                                  unsigned int x_InArrID1;
+                                  unsigned int h_InArrID2;
+                                  unsigned int r_OutArrID1;
+                                  int  nh;
+                                  int  nr;
+                                 }DSP_fir_r8_Params;
+
+/* Function call : void DSP_fir_r8_hM16_rM8A8X8 (short * restrict x, short * h, short * restrict r,
+                                                                                 int nh, int nr)*/
+typedef struct DSP_fir_r8_hM16_rM8A8X8_Params{
+                                               unsigned int InArrID1;
+                                               unsigned int InArrID2;
+                                               unsigned int OutArrID1;
+                                               int  nh;
+                                               int  nr;
+                                              }DSP_fir_r8_hM16_rM8A8X8_Params;
+
+/* Function call : void DSP_fir_sym (short * restrict x, short * restrict h, short * restrict r, int nh,
+                                                                                        int nr, int s)*/
+typedef struct DSP_fir_sym_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int InArrID2;
+                                   unsigned int OutArrID1;
+                                   int  nh;
+                                   int  nr;
+                                   int  s;
+                                  }DSP_fir_sym_Params;
+
+/* Function call : short DSP_iir(short x, short * restrict h, int nh, short * restrict b) */
+/* function modified to work on multiple samples of input*/
+typedef struct DSP_iir_Params{
+                                unsigned int  x_InArrID1;
+                                unsigned int  h_InArrID2;
+                                int   nh;
+                                unsigned int  b_InArrID3;
+                                unsigned int  Ret_OutArrID1;
+                                int   n;
+                               }DSP_iir_Params;
+
+/* Function call : DSP_iir_lat(short * restrict x, int nx, short * restrict k, int nk, int * restrict b,
+                              short * restrict r)*/
+typedef struct DSP_iir_lat_Params{
+                                   unsigned int InArrID1;
+                                   int  nx;
+                                   unsigned int InArrID2;
+                                   int  nk;
+                                   unsigned int InArrID3;
+                                   unsigned int OutArrID1;
+                                  }DSP_iir_lat_Params;
+
+/* Function call : int DSP_dotp_sqr(int G, short * restrict x, short * restrict y, int * restrict r, int nx)*/
+typedef struct DSP_dotp_sqr_Params{
+                                    int  G;
+                                    unsigned int x_InArrID1;
+                                    unsigned int y_InArrID2;
+                                    unsigned int r_OutArrID1;
+                                    int  nx;
+                                    unsigned int Ret_outArrID2;
+                                   }DSP_dotp_sqr_Params;
+
+/* Function call : int DSP_dotprod(short * restrict x, short * restrict y, int nx)*/
+typedef struct DSP_dotprod_Params{
+                                    unsigned int x_InArrID1;
+                                    unsigned int y_InArrID2;
+                                    int  nx;
+                                    unsigned int Ret_outArrID1;
+                                   }DSP_dotprod_Params;
+
+/* Function call : short DSP_maxval (short *x, int nx)*/
+typedef struct DSP_maxval_Params{
+                                  unsigned int x_InArrID1;
+                                  int nx;
+                                  unsigned int OutArrID1;
+                                 }DSP_maxval_Params;
+
+/* Function call : int DSP_maxidx (short *x, int nx)*/
+typedef struct DSP_maxidx_Params{
+                                  unsigned int InArrID1;
+                                  int nx;
+                                  unsigned int OutArrID1;
+                                 }DSP_maxidx_Params;
+
+/* Function call : short DSP_minval (short *x, int nx)*/
+typedef struct DSP_minval_Params{
+                                  unsigned int InArrID1;
+                                  int nx;
+                                  unsigned int OutArrID1;
+                                 }DSP_minval_Params;
+
+/* Function call : void DSP_mul32(int * restrict x, int * restrict y, int * restrict r, short nx)*/
+typedef struct DSP_mul32_Params{
+                                 unsigned int InArrID1;
+                                 int nx;
+                                 unsigned int OutArrID1;
+                                }DSP_mul32_Params;
+
+/* Function call : void DSP_neg32(int * restrict x, int * restrict r, short nx)*/
+typedef struct DSP_neg32_Params{
+                                 unsigned int InArrID1;
+                                 int nx;
+                                 unsigned int OutArrID1;
+                                }DSP_neg32_Params;
+
+/* Function call : void DSP_recip16(short * restrict x, short * restrict rfrac, short * restrict rexp,
+                                    short nx)*/
+typedef struct DSP_recip16_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int InArrID2;
+                                   unsigned int OutArrID1;
+                                   short nx;                                     
+                                  }DSP_recip16_Params;
+
+/* Function call : int DSP_vecsumsq (short *x, int nx)*/
+typedef struct DSP_vecsumsq_Params{
+                                    unsigned int InArrID1;
+                                    int nx;
+                                    unsigned int OutArrID1;
+                                   }DSP_vecsumsq_Params;
+
+/* Function call : void DSP_w_vec(short * restrict x, short * restrict y, short m, short * restrict r,
+                                  short nr)*/
+typedef struct DSP_w_vec_Params{
+                                 unsigned int  x_InArrID1;
+                                 unsigned int  y_InArrID2;
+                                 short m;
+                                 unsigned int  r_OutArrID1;
+                                 int   nr;
+                                }DSP_w_vec_Params;
+
+/* Function call : void DSP_mat_trans(short * restrict x, short rows, short columns, short * restrict r)*/
+typedef struct DSP_mat_trans_Params{
+                                     unsigned int  x_InArrID1;
+                                     short r1;
+                                     short c1;
+                                     unsigned int  OutArrID1;
+                                    }DSP_mat_trans_Params;
+
+/* Function call : short DSP_bexp(const int *x, short nx)*/
+typedef struct DSP_bexp_Params{
+                                unsigned int x_InArrID1;
+                                short nx;
+                                unsigned int OutArrID1;
+                               }DSP_bexp_Params;
+
+/* Function call : void blk_eswap16(void * restrict x, void * restrict r, int nx)*/
+typedef struct blk_eswap16_Params{
+                                   unsigned int x_InArrID1;
+                                   unsigned int r_OutArrID1;
+                                   int  nx;
+                                  }blk_eswap16_Params;
+
+/* Function call : void blk_eswap32(void * restrict x, void * restrict r, int nx)*/
+typedef struct blk_eswap32_Params{
+                                    unsigned int InArrID1;
+                                    unsigned int OutArrID1;
+                                    int  nx;
+                                   }blk_eswap32_Params;
+
+/* Function call : void blk_eswap64(void * restrict x, void * restrict r, int nx)*/
+typedef struct blk_eswap64_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int OutArrID1;
+                                   int  nx;
+                                  }blk_eswap64_Params;
+
+/* Function call : void DSP_blk_move(short * restrict x, short * restrict r, int nx)*/
+typedef struct DSP_blk_move_Params{
+                                    unsigned int InArrID1;
+                                    unsigned int OutArrID1;
+                                    int  nx;
+                                   }DSP_blk_move_Params;
+
+/* Function call : void DSP_fltoq15(float * restrict x, short * restrict r, short nx)*/
+typedef struct DSP_fltoq15_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int OutArrID1;
+                                   int  nx;
+                                  }DSP_fltoq15_Params;
+
+/* Function call : int minerror (short * restrict GSP0_TABLE, short * restrict errCoefs, int * restrict max_index)*/
+typedef struct minerror_Params{
+                                unsigned int GSP0TABLE_InArrID1;
+                                unsigned int errCoefs_InArrID2;
+                                int  max_index;
+                                unsigned int OutArrID1;
+                               }minerror_Params;
+
+/* Function call : void DSP_q15tofl(short * restrict x, float * restrict r, short nx)*/
+typedef struct DSP_q15tofl_Params{
+                                   unsigned int InArrID1;
+                                   unsigned int OutArrID1;
+                                   int nx;
+                                  }DSP_q15tofl_Params;
+
+/*************************************************************************************/
+/* Floating point DSP library for C67+ devices                                       */
+/*************************************************************************************/
+
+/*Function call: void DSPF_sp_autocor(float *restrict r, float *restrict x, const int nx, const int nr) */
+typedef struct DSPF_sp_autocor_Params{ 
+                                       unsigned int r_OutArrID1;
+                                       unsigned int x_InArrID1;
+                                       int  nx;
+                                       int  nr;
+                                       }DSPF_sp_autocor_Params;
+
+/*Function call: void DSPF_sp_biquad(float *restrict x, float *b, float *a, float *delay, float *restrict y, const int n) */
+typedef struct DSPF_sp_biquad_Params{
+                                        unsigned int x_InArrID1;
+                                        unsigned int b_InArrID2;
+                                        unsigned int a_InArrID3;
+                                        unsigned int delay_InArrID4;
+                                        unsigned int y_OutArrID1;
+                                        int n;
+                                      }DSPF_sp_biquad_Params;
+
+/*Function call: void DSPF_sp_convol(const float *x, const float *h, float *restrict y, const short nh, const short ny)*/
+typedef struct DSPF_sp_convol_Params{
+                                     unsigned int x_InArrID1;
+                                     unsigned int h_InArrID2;
+                                     unsigned int y_OutArrID1;
+                                     short nh;
+                                     short ny;
+                                    }DSPF_sp_convol_Params;
+
+/*Function call: float DSPF_sp_dotprod(const float * x, const float * y, const int n)*/
+typedef struct DSPF_sp_dotprod_Params{
+                                      unsigned int x_InArrID1;
+                                      unsigned int y_InArrID2;
+                                      int n;
+                                      unsigned int RetOut_OutArrID1;
+                                    }DSPF_sp_dotprod_Params;
+
+/*Function call: void DSPF_sp_fftSPxSP(int N, float *ptr_x, float *ptr_w, float *ptr_y, unsigned char *brev, int n_min, int offset, int n_max)*/
+typedef struct DSPF_sp_fftSPxSP_Params{
+                                       int N;
+                                       unsigned int x_InArrID1;
+                                       unsigned int w_InArrID2;
+                                       unsigned int y_OutArrID1;
+                                       unsigned int brev_InArrID3;
+                                       int n_min;
+                                       int offset;
+                                       int n_max;
+                                      }DSPF_sp_fftSPxSP_Params;
+  
+/*Function call: void DSPF_sp_fir_cplx(const float * x, const float * h, float * restrict y, int nh, int ny)*/
+typedef struct DSPF_sp_fir_cplx_Params{
+                                       unsigned int x_InArrID1;
+                                       unsigned int h_InArrID2;
+                                       unsigned int y_OutArrID1;
+                                       int nh;
+                                       int ny;
+                                      }DSPF_sp_fir_cplx_Params;
+
+/*Function call: void DSPF_sp_fir_gen(const float * restrict x, const float * restrict h, float * restrict y, int nh, int ny)*/
+typedef struct DSPF_sp_fir_gen_Params{
+                                      unsigned int x_InArrID1;
+                                      unsigned int h_InArrID2;
+                                      unsigned int y_OutArrID1;
+                                      int nh;
+                                      int ny;
+                                      }DSPF_sp_fir_gen_Params;
+
+/*Function call: void DSPF_sp_ifftSPxSP(int N, float *ptr_x, float *ptr_w, float *ptr_y, unsigned char *brev, int n_min, int offset, int n_max)*/
+typedef struct DSPF_sp_ifftSPxSP_Params{
+                                       int N;
+                                       unsigned int x_InArrID1;
+                                       unsigned int w_InArrID2;
+                                       unsigned int y_OutArrID1;
+                                       unsigned int brev_InArrID3;
+                                       int n_min;
+                                       int offset;
+                                       int n_max;
+                                       }DSPF_sp_ifftSPxSP_Params;
+
+/*Function call: void DSPF_sp_iir(float *restrict y1, const float * x, float *restrict y2, const float * hb, const float * ha, int n)*/
+typedef struct DSPF_sp_iir_Params{
+                                  unsigned int y1_OutArrID1;
+                                  unsigned int x_InArrID1;
+                                  unsigned int y2_OutArrID2;
+                                  unsigned int hb_InArrID2;
+                                  unsigned int ha_InArrID3;
+                                  int n;
+                                  }DSPF_sp_iir_Params;
+
+/*Function call: void DSPF_sp_mat_mul(float *x1, const int r1, const int c1, float *x2, const int c2, float *restrict y)*/
+typedef struct DSPF_sp_mat_mul_Params{
+                                      unsigned int x1_InArrID1;
+                                      int  r1;
+                                      int  c1;
+                                      unsigned int x2_InArrID2;
+                                      int  c2;
+                                      unsigned int y_OutArrID1;
+                                     }DSPF_sp_mat_mul_Params;
+
+/*Function call: void DSPF_sp_mat_mul_cplx(float *x1, const int r1, const int c1, float *x2, const int c2, float *restrict y)*/
+typedef struct DSPF_sp_mat_mul_cplx_Params{
+                                      unsigned int x1_InArrID1;
+                                      int  r1;
+                                      int  c1;
+                                      unsigned int x2_InArrID2;
+                                      int  c2;
+                                      unsigned int y_OutArrID1;
+                                     }DSPF_sp_mat_mul_cplx_Params;
+
+/*Function call: void DSPF_sp_mat_trans(const float *restrict x, const int rows, const int cols, float *restrict y)*/
+typedef struct DSPF_sp_mat_trans_Params{
+                                        unsigned int  x_InArrID1;
+                                        short rows;
+                                        short cols;
+                                        unsigned int  y_OutArrID1;
+                                       } DSPF_sp_mat_trans_Params;
+
+/*Function call: void DSPF_sp_vecmul(const float * x1, const float * x2, float *restrict y, const int n)*/
+typedef struct DSPF_sp_vecmul_Params{
+                                     unsigned int  x1_InArrID1;
+                                     unsigned int  x2_InArrID2;
+                                     unsigned int  y_OutArrID1;
+                                     int n;
+                                     }DSPF_sp_vecmul_Params;
+
+/*Function call: void DSPF_sp_vecrecip(const float * x, float *restrict y, const int n)*/
+typedef struct DSPF_sp_vecrecip_Params{
+                                       unsigned int  x_InArrID1;
+                                       unsigned int  y_OutArrID1;
+                                       int n;
+                                      }DSPF_sp_vecrecip_Params;
+
+/*Function call: float DSPF_sp_vecsum_sq(const float * x, const int n)*/
+typedef struct DSPF_sp_vecsum_sq_Params{
+                                        unsigned int  x_InArrID1;
+                                        int n;
+                                        unsigned int  OutRet_OutArrID1;
+                                        }DSPF_sp_vecsum_sq_Params;
+
+/*Function call: void DSPF_sp_w_vec(const float *x1, const float *x2, const float m, float *restrict y, const int n)*/
+typedef struct DSPF_sp_w_vec_Params{
+                                     unsigned int  x1_InArrID1;
+                                     unsigned int  x2_InArrID2;
+                                     float m;
+                                     unsigned int  y_OutArrID1;
+                                     int n;
+                                    }DSPF_sp_w_vec_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Image Library functions                    */
+/*************************************************************************************/
+/* Function call : void IMG_sobel_3x3_8(const unsigned char *in_data, unsigned char *out_data, short cols, short rows)*/
+typedef struct IMG_sobel_3x3_8_Params{
+                                      unsigned int indata_InArrID1;
+                                      unsigned int outdata_OutArrID1; 
+                                      int Col;
+                                      int Row;
+                                     }IMG_sobel_3x3_8_Params;
+/* This struct is added by Pramod */
+/* Function call : void IMG_sobel_3x3_8_16(const unsigned char *in_data, unsigned short *out_data, short cols, short rows)*/
+typedef struct IMG_sobel_3x3_8_16_Params{
+                                      unsigned int indata_InArrID1;
+                                      unsigned int outdata_OutArrID1; 
+                                      int Col;
+                                      int Row;
+                                     }IMG_sobel_3x3_8_16_Params;
+
+/* Function call : void IMG_sobel_3x3_16s (const short *restrict in, const short *restrict out, short cols,
+                                           short rows)*/
+typedef struct IMG_sobel_3x3_16_Params{
+                                       unsigned int indata_InArrID1;
+                                       unsigned int outdata_OutArrID1; 
+                                       short Col;
+                                       short Row;
+                                     }IMG_sobel_3x3_16_Params;
+
+/* Function call : IMG_histogram_8 (const unsigned char * restrict in_data, int n, short accumulate,
+unsigned short * restrict t_hist, unsigned short * restrict hist)*/
+typedef struct IMG_histogram_8_Params{
+                                      unsigned int  indata_InArrID1;
+                                      int   n;
+                                      short accumulate;
+                                      unsigned int  t_hist_OutArrID1;
+                                      unsigned int  hist_OutArrID2; 
+                                     }IMG_histogram_8_Params;
+
+/* Function call : void IMG_histogram_16(unsigned short *restrict in, short *restrict hist, short *restrict
+t_hist, int n, int accumulate, int img_bits)*/
+typedef struct IMG_histogram_16_Params{
+                                       unsigned int  in_InArrID1;
+                                       int   n;
+                                       short accumulate;
+                                       unsigned int  t_hist_OutArrID1;
+                                       unsigned int  hist_OutArrID2;
+                                       int   img_bits; 
+                                      }IMG_histogram_16_Params;
+
+/* Function call : void IMG_median_3x3_8(const unsigned char * restrict in_data, int cols, unsigned char *restrict out_data)*/
+                                         
+typedef struct IMG_median_3x3_8_Params{
+                                       unsigned int InArrID1;
+                                       int  Col;
+                                       unsigned int OutArrID1; 
+                                      }IMG_median_3x3_8_Params;
+
+/* Function call : void IMG_median_3x3_16 (const short *restrict i_data, int n, short *restrict o_data)*/
+typedef struct IMG_median_3x3_16_Params{
+                                        unsigned int idata_InArrID1;
+                                        int  nwidth;
+                                        unsigned int odata_OutArrID1; 
+                                      }IMG_median_3x3_16_Params;
+
+/* Function call : void IMG_median_3x3_16s (const short *restrict i_data, int n, short *restrict o_data)*/
+typedef struct IMG_median_3x3_16s_Params{
+                                         unsigned int idata_InArrID1;
+                                         int  nwidth;
+                                         unsigned int odata_OutArrID1; 
+                                      }IMG_median_3x3_16s_Params;
+
+/* Additional functions that allow raw and columns to be specified */
+typedef struct IMG_median_3x3_8_Frame_Params{
+                                       unsigned int InArrID1;
+                                       int  Row;
+                                       int  Col;
+                                       unsigned int OutArrID1;
+                                      }IMG_median_3x3_8_Frame_Params;
+
+/* Function call : void IMG_median_3x3_16 (const short *restrict i_data, int n, short *restrict o_data)*/
+typedef struct IMG_median_3x3_16_Frame_Params{
+                                        unsigned int idata_InArrID1;
+                                        int  Row;
+                                        int  nwidth;
+                                        unsigned int odata_OutArrID1;
+                                      }IMG_median_3x3_16_Frame_Params;
+
+/* Function call : void IMG_median_3x3_16s (const short *restrict i_data, int n, short *restrict o_data)*/
+typedef struct IMG_median_3x3_16s_Frame_Params{
+                                         unsigned int idata_InArrID1;
+                                         int  Row;
+                                         int  nwidth;
+                                         unsigned int odata_OutArrID1;
+                                      }IMG_median_3x3_16s_Frame_Params;
+
+
+/* Function call : IMG_ycbcr422p_rgb565(const short * restrict coeff, const unsigned char * restrict
+                                        y_data, const unsigned char * restrict cb_data, 
+                                        const unsigned char * restrict cr_data,
+                                        unsigned short * restrict rgb_data, unsigned num_pixels)*/
+typedef struct IMG_ycbcr422pl_to_rgb565_Params{
+                                               unsigned int     coeff_InArrID1;
+                                               unsigned int     y_data_InArrID2;
+                                               unsigned int     cb_data_InArrID3;
+                                               unsigned int     cr_data_InArrID4;
+                                               unsigned int     rgb_data_OutArrID1;
+                                               unsigned num_pixels;
+                                              }IMG_ycbcr422pl_to_rgb565_Params;
+
+
+/* Function call : IMG_yuv420pl_to_rgb565(const short *coeff,int Height, int Width, unsigned char *pbuf_y,
+                               unsigned char *pbuf_cb,unsigned char *pbuf_cr,unsigned short *pbuf_rgb)*/
+typedef struct IMG_yuv420pl_to_rgb565_Params{
+                                             unsigned int     coeff_InArrID1;
+                                             int      Height;
+                                             int      Width;
+                                             unsigned int     y_data_InArrID2;
+                                             unsigned int     cb_data_InArrID3;
+                                             unsigned int     cr_data_InArrID4;
+                                             unsigned int     rgb_data_OutArrID1;
+                                            }IMG_yuv420pl_to_rgb565_Params;
+
+
+typedef struct IMG_yuv420pl16_to_rgb565_Params{
+                                               unsigned int     coeff_InArrID1;
+                                               int      Height;
+                                               int      Width;
+                                               unsigned int     y_data_InArrID2;
+                                               unsigned int     cb_data_InArrID3;
+                                               unsigned int     cr_data_InArrID4;
+                                               unsigned int     rgb_data_OutArrID1;
+                                              }IMG_yuv420pl16_to_rgb565_Params;
+
+/* Function call : IMG_ycbcr422pl16_rgb565(const short * restrict coeff, const unsigned char * restrict
+                                        y_data, const unsigned char * restrict cb_data, 
+                                        const unsigned char * restrict cr_data,
+                                        unsigned short * restrict rgb_data, unsigned num_pixels)*/
+typedef struct IMG_ycbcr422pl16_to_rgb565_Params{
+                                                 unsigned int     coeff_InArrID1;
+                                                 int      Height;
+                                                 int      Width;
+                                                 unsigned int     y_data_InArrID2;
+                                                 unsigned int     cb_data_InArrID3;
+                                                 unsigned int     cr_data_InArrID4;
+                                                 unsigned int     rgb_data_OutArrID1;
+                                                 unsigned num_pixels;
+                                                }IMG_ycbcr422pl16_to_rgb565_Params;
+
+/* Function call : IMG_conv_33_i8_c8s(const unsigned char * restrict in_data, unsigned char *
+restrict out_data, int cols, const char * restrict mask, int shift)*/
+typedef struct IMG_conv_3x3_i8_c8s_Params{
+                                           unsigned int in_data_InArrID1;
+                                           unsigned int out_data_OutArrID1;
+                                           int  cols;
+                                           unsigned int mask_InArrID2;
+                                           int  shift;
+                                          }IMG_conv_3x3_i8_c8s_Params;
+
+/* Function call : void IMG_conv_3x3_i16s_c16s (const short *restrict imgin_ptr, short *restrict
+imgout_ptr, short width, short pitch, const short *restrict mask_ptr, short shift)*/
+typedef struct IMG_conv_3x3_i16s_c16s_Params{
+                                             unsigned int in_data_InArrID1;
+                                             unsigned int out_data_OutArrID1;
+                                             short width;
+                                             short pitch;
+                                             unsigned int mask_InArrID2;
+                                             short shift;
+                                            }IMG_conv_3x3_i16s_c16s_Params;
+
+/* Function call : IMG_conv_33_i8_c8s(const unsigned char * restrict in_data, unsigned char *
+restrict out_data, int cols, const char * restrict mask, int shift)*/
+typedef struct IMG_conv_3x3_i8_c8s_Frame_Params{
+                                           unsigned int in_data_InArrID1;
+                                           unsigned int out_data_OutArrID1;
+                                           int  rows;
+                                           int  cols;
+                                           unsigned int mask_InArrID2;
+                                           int  shift;
+                                          }IMG_conv_3x3_i8_c8s_Frame_Params;
+
+/* Function call : void IMG_conv_3x3_i16s_c16s (const short *restrict imgin_ptr, short *restrict
+imgout_ptr, short width, short pitch, const short *restrict mask_ptr, short shift)*/
+typedef struct IMG_conv_3x3_i16s_c16s_Frame_Params{
+                                             unsigned int in_data_InArrID1;
+                                             unsigned int out_data_OutArrID1;
+                                             short rows;
+                                             short width;
+                                             short pitch;
+                                             unsigned int mask_InArrID2;
+                                             short shift;
+                                            }IMG_conv_3x3_i16s_c16s_Frame_Params;
+
+
+/* Function call :IMG_corr_3x3_i8_c8(const unsigned char *inptr, int *restrict outptr, int n_out, int
+x_dim, const unsigned char *mask, const short shift, int round)*/
+typedef struct IMG_corr_3x3_i8_c8_Params{
+                                          unsigned int in_InArrID1;
+                                          unsigned int out_OutArrID1;
+                                          int n_out;
+                                          int x_dim;
+                                          unsigned int mask_InArrID2;
+                                          short shift;
+                                          int round;
+                                         }IMG_corr_3x3_i8_c8_Params;
+
+/* Function call : IMG_corr_3x3_i16_c16s (const short *restrict imgin_ptr, int *restrict imgout_ptr,
+short width, short pitch, const short *restrict mask_ptr, short shift, int round)*/
+typedef struct IMG_corr_3x3_i16s_c16s_Params{
+                                              unsigned int   imgin_InArrID1;
+                                              unsigned int   imgout_OutArrID1;
+                                              short  width;
+                                              short  pitch;
+                                              unsigned int   mask_InArrID2;
+                                              short  shift;
+                                              int  round;
+                                             }IMG_corr_3x3_i16s_c16s_Params;
+
+/* Function call : void IMG_corr_3x3_i8_c16s (const unsigned char *restrict imgin_ptr, int *restrict
+                  imgout_ptr, short width, short pitch, const short *restrict mask_ptr, int round)*/
+typedef struct IMG_corr_3x3_i8_c16s_Params{
+                                            unsigned int   imgin_InArrID1;
+                                            unsigned int   imgout_OutArrID1;
+                                            short  width;
+                                            short  pitch;
+                                            unsigned int   mask_InArrID2;
+                                          }IMG_corr_3x3_i8_c16s_Params;
+
+/* Function call :IMG_corr_3x3_i8_c8(const unsigned char *inptr, int *restrict outptr, int n_out, int
+x_dim, const unsigned char *mask, const short shift, int round)*/
+typedef struct IMG_corr_3x3_i8_c8_Frame_Params{
+                                          unsigned int in_InArrID1;
+                                          unsigned int out_OutArrID1;
+                                          int n_out;
+                                          int rows;
+                                          int x_dim;
+                                          unsigned int mask_InArrID2;
+                                          short shift;
+                                          int round;
+                                         }IMG_corr_3x3_i8_c8_Frame_Params;
+
+/* Function call : IMG_corr_3x3_i16_c16s (const short *restrict imgin_ptr, int *restrict imgout_ptr,
+short width, short pitch, const short *restrict mask_ptr, short shift, int round)*/
+typedef struct IMG_corr_3x3_i16s_c16s_Frame_Params{
+                                              unsigned int   imgin_InArrID1;
+                                              unsigned int   imgout_OutArrID1;
+                                              short  rows;
+                                              short  width;
+                                              short  pitch;
+                                              unsigned int   mask_InArrID2;
+                                              short  shift;
+                                              int  round;
+                                             }IMG_corr_3x3_i16s_c16s_Frame_Params;
+
+/* Function call : void IMG_corr_3x3_i8_c16s (const unsigned char *restrict imgin_ptr, int *restrict
+                  imgout_ptr, short width, short pitch, const short *restrict mask_ptr, int round)*/
+typedef struct IMG_corr_3x3_i8_c16s_Frame_Params{
+                                            unsigned int   imgin_InArrID1;
+                                            unsigned int   imgout_OutArrID1;
+                                            short  rows;
+                                            short  width;
+                                            short  pitch;
+                                            unsigned int   mask_InArrID2;
+                                          }IMG_corr_3x3_i8_c16s_Frame_Params;
+
+/* Function call : IMG_fdct_8x8(short *fdct_data, unsigned num_fdcts)*/
+typedef struct IMG_fdct_8x8_Params{
+                                    unsigned int     in_InArrID1;
+                                    unsigned num_fdcts;
+                                   }IMG_fdct_8x8_Params;
+
+/* Function call : void IMG_mulS_8(short * restrict imgR,int * restrict imgW,short constData,int count )*/
+typedef struct IMG_mulS_8_Params{
+                                   unsigned int imgR_InArrID1;
+                                   unsigned int imgW_OutArrID1;
+                                   char constData;
+                                   int  count;
+                                  }IMG_mulS_8_Params;
+
+/* Function call : void IMG_mulS_16s(short * restrict imgR,int * restrict imgW, short constData, int count )*/
+typedef struct IMG_mulS_16s_Params{
+                                   unsigned int imgR_InArrID1;
+                                   unsigned int imgW_OutArrID1;
+                                   short constData;
+                                   int  count;
+                                  }IMG_mulS_16s_Params;
+
+/* Function call : void IMG_addS_8(char * restrict imgR, char * restrict imgW, char constData,int count ) */ 
+typedef struct IMG_addS_8_Params{
+                                  unsigned int imgR_InArrID1;
+                                  unsigned int imgW_OutArrID1;
+                                  char constData;
+                                  int  count;
+                                 }IMG_addS_8_Params;
+
+/* Function call : void IMG_addS_16s(short * restrict imgR,short * restrict imgW, short constData, int count) */              
+typedef struct IMG_addS_16s_Params{
+                                   unsigned int  imgR_InArrID1;
+                                   unsigned int  imgW_OutArrID1;
+                                   short constData;
+                                   int   count;
+                                  }IMG_addS_16s_Params;
+
+/* Function call : void IMG_subS_8(char * restrict imgR,char * restrict imgW, char constData,int count )*/
+typedef struct IMG_subS_8_Params{
+                                  unsigned int imgR_InArrID1;
+                                  unsigned int imgW_OutArrID1;
+                                  char constData;
+                                  int  count;
+                                 }IMG_subS_8_Params;
+
+/* Function call : void IMG_subS_16s(short * restrict imgR, short * restrict imgW, short constData,int count)*/           
+typedef struct IMG_subS_16s_Params{
+                                   unsigned int  imgR_InArrID1;
+                                   unsigned int  imgW_OutArrID1;
+                                   short constData;
+                                   int   count;
+                                  }IMG_subS_16s_Params;
+
+/* Function call : void IMG_yc_demux_le16_16 (int n, const unsigned short * yc, short *restrict y, short
+*restrict cr, short *restrict cb)*/
+typedef struct IMG_yc_demux_le16_16_Params{
+                                           int n;
+                                           unsigned int yc_InArrID1;
+                                           unsigned int y_OutArrID1;
+                                           unsigned int cr_OutArrID2;
+                                           unsigned int cb_OutArrID3; 
+                                          }IMG_yc_demux_le16_16_Params;
+
+/* Function call :  void yc_demux_le8_c(int n, const unsigned char *restrict yc,unsigned char *restrict y, 
+                                       unsigned char *restrict cr, unsigned char *restrict cb     )*/
+typedef struct IMG_yc_demux_le8_c_Params{
+                                           int n;
+                                           unsigned int yc_InArrID1;
+                                           unsigned int y_OutArrID1;
+                                           unsigned int cr_OutArrID2;
+                                           unsigned int cb_OutArrID3; 
+                                          }IMG_yc_demux_le8_c_Params;
+
+/* Function call : void IMG_dilate_bin(const unsigned char * restrict in_data, unsigned char * restrict
+out_data, const char * restrict mask, int cols) */
+typedef struct IMG_dilate_bin_Params{
+                                      unsigned int InArrID1;
+                                      unsigned int OutArrID1;
+                                      unsigned int InArrID2; 
+                                      int  Col;
+                                     }IMG_dilate_bin_Params;
+
+/* Function call : void IMG_erode_bin(const unsigned char * restrict in_data, unsigned char * restrict
+out_data, const char * restrict mask, int cols)*/
+typedef struct IMG_erode_bin_Params{
+                                      unsigned int InArrID1;
+                                      unsigned int OutArrID1;
+                                      unsigned int InArrID2; 
+                                      int  Col;
+                                     }IMG_erode_bin_Params;
+
+/* Function call : void IMG_pix_sat(int n, const short * restrict in_data, unsigned char * restrict out_data) */
+typedef struct IMG_pix_sat_Params{
+                                  int  Col;
+                                  unsigned int InArrID1;
+                                  unsigned int OutArrID1; 
+                                 }IMG_pix_sat_Params;
+
+/* void ycbcr422sp_to_ycbcr420pl(
+    const unsigned char * y_src,    
+    const unsigned char * cbcr_src, 
+    unsigned char * restrict y_dst,
+    unsigned char * restrict cb_dst,
+    unsigned char * restrict cr_dst,
+    unsigned int num_lines, 
+    unsigned int width,
+    unsigned int src_pitch, 
+    unsigned int dst_y_pitch,
+    unsigned int dst_cbcr_pitch
+)
+*/
+typedef struct IMG_ycbcr422sp_to_ycbcr420pl_Params{
+                                            unsigned int y_src_InArrID1;
+                                            unsigned int cbcr_src_InArrID2;
+                                            unsigned int y_dst_OutArrID1;
+                                            unsigned int cb_dst_OutArrID2;
+                                            unsigned int cr_dst_OutArrID3;
+                                            unsigned int num_lines; 
+                                            unsigned int width;
+                                            unsigned int src_pitch; 
+                                            unsigned int dst_y_pitch;
+                                            unsigned int dst_cbcr_pitch;
+                                            }IMG_ycbcr422sp_to_ycbcr420pl_Params;
+                                             
+/* void ycbcr422pl_to_ycbcr422sp 
+(
+    const unsigned char * y_dst,    
+    const unsigned char * cbcr_dst, 
+    unsigned char * restrict y_src,
+    unsigned char * restrict cb_src,
+    unsigned char * restrict cr_src,
+    unsigned int num_lines, 
+    unsigned int width,
+    unsigned int dst_pitch, 
+    unsigned int src_y_pitch,
+    unsigned int src_cbcr_pitch
+)*/
+typedef struct IMG_ycbcr422pl_to_ycbcr422sp_Params{
+                                            unsigned int y_dst_OutArrID1;
+                                            unsigned int cbcr_dst_OutArrID2;
+                                            unsigned int y_src_InArrID1;
+                                            unsigned int cb_src_InArrID2;
+                                            unsigned int cr_src_InArrID3;
+                                            unsigned int num_lines; 
+                                            unsigned int width;
+                                            unsigned int dst_pitch; 
+                                            unsigned int src_y_pitch;
+                                            unsigned int src_cbcr_pitch;
+                                            }IMG_ycbcr422pl_to_ycbcr422sp_Params;
+
+/* void ycbcr422sp_to_ycbcr422ile 
+(
+    const unsigned char * y_src,    
+    const unsigned char * cbcr_src, 
+    unsigned char * restrict ycbcr_dst,
+    unsigned int num_lines, 
+    unsigned int width,
+    unsigned int src_pitch, 
+    unsigned int dst_ycbcr_pitch
+) */
+typedef struct IMG_ycbcr422sp_to_ycbcr422ile_Params{
+                                            unsigned int y_src_InArrID1;
+                                            unsigned int cbcr_src_InArrID2;
+                                            unsigned int ycbcr_dst_OutArrID1;
+                                            unsigned int num_lines; 
+                                            unsigned int width;
+                                            unsigned int src_pitch;
+                                            unsigned int dst_ycbcr_pitch;
+                                            }IMG_ycbcr422sp_to_ycbcr422ile_Params;
+
+/* ***********************************************************************************/
+/* Parameter structure and pointer to the structure for the IQ math Library functions*/
+/*************************************************************************************/
+//#if DEVICE_TYPE == DEVICE_FIXED
+
+/* Function call : I32_IQ _IQNmpy(I32_IQ f1, I32_IQ f2, U32_IQ q_format);*/
+typedef struct IQNmpy_Params{
+                              unsigned int   InArrID1;
+                              unsigned int   InArrID2;
+                              unsigned int qfmt;
+                              unsigned int   OutArrID1;
+                              unsigned int   n;
+                             }IQNmpy_Params;
+
+/* Function call : I32_IQ _IQNrmpy(I32_IQ x, I32_IQ y, Uword32 qfmt); */
+typedef struct IQNrmpy_Params{
+                              unsigned int InArrID1;
+                              unsigned int InArrID2;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNrmpy_Params;
+
+/* Function call : I32_IQ _IQNrsmpy(I32_IQ x, I32_IQ y, U32_IQ qfmt); */
+typedef struct IQNrsmpy_Params{ 
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int qfmt;
+                               unsigned int OutArrID1;
+                               unsigned int   n;
+                              }IQNrsmpy_Params;
+
+/* Function call : I32_IQ _IQNmpyI32int(I32_IQ x, I32_IQ y, U32_IQ qfmt);*/
+typedef struct IQNmpyI32int_Params{
+                                    unsigned int  InArrID1;
+                                    unsigned int     InArrID2;
+                                    unsigned int  qfmt;
+                                    unsigned int  OutArrID1;
+                                    unsigned int   n;
+                                   }IQNmpyI32int_Params;
+
+/* Function call : I32_IQ _IQNmpyI32frac(I32_IQ x, I32_IQ y, U32_IQ qfmt);*/
+typedef struct IQNmpyI32frac_Params{
+                                    unsigned int  InArrID1;
+                                    unsigned int     InArrID2;
+                                    unsigned int  qfmt;
+                                    unsigned int  OutArrID1;
+                                    unsigned int   n;
+                                   }IQNmpyI32frac_Params;
+
+/* Function call : I32_IQ  _IQNmpyIQx(I32_IQ in1, I32_IQ qfmt1,I32_IQ in2, I32_IQ qfmt2, U32_IQ qfmt);*/
+typedef struct IQNmpyIQX_Params{
+                                unsigned int   InArrID1;
+                                int            qfmt1;
+                                unsigned int   InArrID2;
+                                int            qfmt2;
+                                unsigned int   qfmt;
+                                unsigned int   OutArrID1;
+                                unsigned int   n;
+                               }IQNmpyIQX_Params;
+
+/* Function call : I32_IQ _IQNdiv(I32_IQ num, I32_IQ den, Uword32 qfmt);*/
+typedef struct IQNdiv_Params{
+                              unsigned int  num_InArrID1;
+                              unsigned int  den_InArrID2;
+                              unsigned int  qfmt;
+                              unsigned int  OutArrID1;
+                              unsigned int  n;
+                             }IQNdiv_Params;
+
+/* Function call : I32_IQ _IQNmag(I32_IQ x, I32_IQ y, U32_IQ qfmt);*/
+typedef struct IQNmag_Params{
+                              unsigned int  InArrID1;
+                              unsigned int  InArrID2;
+                              unsigned int  qfmt;
+                              unsigned int  OutArrID1;
+                              unsigned int    n;
+                             }IQNmag_Params;
+
+/* Function call : I32_IQ _IQNsqrt(I32_IQ x, U32_IQ qfmt);*/
+typedef struct IQNsqrt_Params{
+                              unsigned int   InArrID1;
+                              unsigned int   qfmt;
+                              unsigned int   OutArrID1;
+                              unsigned int     n;
+                             }IQNsqrt_Params;
+
+/* Function call : I32_IQ _IQNisqrt(I32_IQ x, U32_IQ qfmt); */
+typedef struct IQNisqrt_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int n;
+                             }IQNisqrt_Params;
+
+/* Function call : I32_IQ _IQNsin(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNsin_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int n;
+                             }IQNsin_Params;
+
+/* Function call : I32_IQ _IQNasin(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNasin_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int n;
+                             }IQNasin_Params;
+
+/* Function call : I32_IQ _IQNsinPU(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNsinPU_Params{
+                               unsigned int InArrID1;
+                               unsigned int qfmt;
+                               unsigned int OutArrID1;
+                               unsigned int   n;
+                             }IQNsinPU_Params;
+
+/* Function call : I32_IQ _IQNcos(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNcos_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNcos_Params;
+
+/* Function call : I32_IQ _IQNacos(I32_IQ in, U32_IQ qfmt);*/
+typedef struct IQNacos_Params{
+                              unsigned int  InArrID1;
+                              unsigned int  qfmt;
+                              unsigned int  OutArrID1;
+                              unsigned int    n;
+                             }IQNacos_Params;
+
+/* Function call : I32_IQ _IQNcosPU(I32_IQ in, U32_IQ qfmt); */
+typedef struct IQNcosPU_Params{
+                               unsigned int InArrID1;
+                               unsigned int qfmt;
+                               unsigned int OutArrID1;
+                               unsigned int    n;
+                              }IQNcosPU_Params;
+
+/* Function call : I32_IQ _IQNatan2(I32_IQ y, I32_IQ x, U32_IQ qfmt); */
+typedef struct IQNatan2_Params{
+                              unsigned int y_InArrID1;
+                              unsigned int x_InArrID2;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNatan2_Params;
+
+/* Function call : I32_IQ _IQNatan2PU(I32_IQ y, I32_IQ x, U32_IQ qfmt);*/
+typedef struct IQNatan2PU_Params{
+                                 unsigned int y_InArrID1;
+                                 unsigned int x_InArrID2;
+                                 unsigned int qfmt;
+                                 unsigned int OutArrID1;
+                                 unsigned int   n;
+                                }IQNatan2PU_Params;
+
+/* Function call : I32_IQ _IQNexp(I32_IQ a, U32_IQ qfmt); */
+typedef struct IQNexp_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNexp_Params;
+
+/* Function call : I32_IQ _IQNlog(I32_IQ a, U32_IQ qfmt);*/
+typedef struct IQNlog_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNlog_Params;
+
+/* Function call : I32_IQ _IQNlog(I32_IQ a, U32_IQ qfmt);*/
+typedef struct IQNabs_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNabs_Params;
+
+/* Function call : I32_IQ _IQNpow(I32_IQ x, I32_IQ y, U32_IQ qfmt);*/
+typedef struct IQNpow_Params{
+                              unsigned int A_InArrID1;
+                              unsigned int B_InArrID2;
+                              unsigned int qfmt;
+                              int OutArrID1;
+                              unsigned int   n;
+                             }IQNpow_Params;
+
+/* Function call : float _IQNtoF(I32_IQ input, U32_IQ qfmt); */
+typedef struct IQNtoF_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int  OutArrID1;
+                              unsigned int   n;
+                             }IQNtoF_Params;
+
+/* Function call : I32_IQ _FtoIQN(float input, U32_IQ qfmt); */
+typedef struct FtoIQN_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }FtoIQN_Params;
+
+typedef struct IQN_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQN_Params;
+
+typedef struct IQNint_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNint_Params;
+
+typedef struct IQNfrac_Params{
+                              unsigned int InArrID1;
+                              unsigned int qfmt;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }IQNfrac_Params;
+
+typedef struct IQXtoIQY_Params{
+                               unsigned int InArrID1;
+                               int x;
+                               int y;
+                               unsigned int OutArrID1;
+                               unsigned int   n;
+                             }IQXtoIQY_Params;
+
+
+
+/* ***********************************************************************************/
+/* Parameter structure defintiions for the FastRTS library functions                 */
+/* ***********************************************************************************/
+
+/* Function call : float addsp_i(float x, float y) */
+typedef struct addsp_i_Params{
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int OutArrID1;
+                               unsigned int  n;     
+                              }addsp_i_Params;
+
+/* Function call : float subsp_i(float x, float y) */
+typedef struct subsp_i_Params{
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int OutArrID1;
+                               unsigned int  n;     
+                              }subsp_i_Params;
+
+/* Function call : float mpysp_i(float x, float y) */
+typedef struct mpysp_i_Params{
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }mpysp_i_Params;
+
+/* Function call : float recipsp_i(float x)*/
+typedef struct divsp_i_Params{
+                               unsigned int InArrID1;
+                               unsigned int InArrID2;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }divsp_i_Params;
+
+/* Function call : float recipsp_i(float x)*/
+typedef struct recipsp_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }recipsp_i_Params;
+
+/* Function call : float sqrtsp_i(float x)*/
+typedef struct sqrtsp_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }sqrtsp_i_Params;
+
+/* Function call : Float intsp_i(int x)*/
+typedef struct intsp_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }intsp_i_Params;
+
+/* Function call : int intsp_i(float x) */
+typedef struct spint_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int   OutArrID1;
+                               unsigned int  n;   
+                              }spint_i_Params;
+
+/* Function call : float uintsp_i(unsigned int x)*/
+typedef struct uintsp_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;     
+                              }uintsp_i_Params;
+
+/* Function call : Unsigned int spuint_i(float x)*/
+typedef struct spuint_i_Params{
+                               unsigned int x_InArrID1;
+                               unsigned int OutArrID1;
+                               unsigned int n;      
+                              }spuint_i_Params;
+
+/* Function call : double atandp(double z) */
+typedef struct atandp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }atandp_Params;
+
+/* Function call : float atansp(float z);*/
+typedef struct atansp_Params{
+                             unsigned int z_InArrID1;
+                             unsigned int OutArrID1;
+                             unsigned int   n;
+                             }atansp_Params;
+
+/* Function call : double atan2dp( double y, double x );*/
+typedef struct  atan2dp_Params{
+                              unsigned int y_InArrID1;
+                              unsigned int x_InArrID2;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }atan2dp_Params;
+
+/* Function call : float atan2sp( float y, float x );*/
+typedef struct atan2sp_Params{
+                              unsigned int y_InArrID1;
+                              unsigned int x_InArrID2;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }atan2sp_Params;
+
+/* Function call : double cosdp( double z );*/
+typedef struct cosdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }cosdp_Params;
+
+
+/* Function call : float cossp( float z );*/
+typedef struct cossp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }cossp_Params;
+
+
+/* Function call : double exp( double z ) ;*/
+typedef struct expdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }expdp_Params; 
+/* Function call : float expf( float z ) ;*/
+typedef struct expsp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }expsp_Params;
+
+/* Function call : double exp10( double z ) ;*/
+typedef struct exp10dp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }exp10dp_Params;
+
+/* Function call : float exp10sp( float z );*/
+typedef struct exp10sp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }exp10sp_Params;
+
+/* Function call : double exp2dp( double z );*/
+typedef struct exp2dp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }exp2dp_Params;
+
+/* Function call : float exp2sp( float z );*/
+typedef struct exp2sp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }exp2sp_Params;
+
+/* Function call : double logdp( double z );*/
+typedef struct logdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }logdp_Params;
+
+/* Function call : float logsp( float z );*/
+typedef struct logsp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }logsp_Params;
+
+/* Function call : double log10dp( double z );*/
+typedef struct log10dp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }log10dp_Params;
+
+/* Function call : float log10sp( float z );*/
+typedef struct log10sp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }log10sp_Params;
+
+/* Function call : double log2dp( double z );*/
+typedef struct log2dp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }log2dp_Params;
+
+/* Function call : float log2sp( float z ) ;*/
+typedef struct log2sp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }log2sp_Params;
+/* Function call : double powdp(double x double y);*/
+typedef struct  powdp_Params{
+                              unsigned int x_InArrID1;
+                              unsigned int y_InArrID2;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }powdp_Params;
+/* Function call : float powsp(float x, float y);*/
+typedef struct  powsp_Params{
+                              unsigned int x_InArrID1;
+                              unsigned int y_InArrID2;
+                              unsigned int OutArrID1;
+                              unsigned int   n;
+                             }powsp_Params;
+
+/* Function call : double recipdp( double z ); */
+typedef struct recipdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }recipdp_Params;
+
+/* Function call : float recipsp( float z );*/
+typedef struct recipsp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }recipsp_Params;
+
+/* Function call : double rsqrtdp( double z );*/
+typedef struct rsqrtdp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }rsqrtdp_Params;
+
+/* Function call : float rsqrtsp( float z );*/
+typedef struct rsqrtsp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }rsqrtsp_Params;
+
+/* Function call : double sindp( double z);*/
+typedef struct sindp_Params{
+                           unsigned int z_InArrID1;
+                           unsigned int OutArrID1;
+                           unsigned int   n;
+                           }sindp_Params;
+
+/* Function call : float sinsp(float x);*/
+typedef struct sinsp_Params{
+                            unsigned int x_InArrID1;
+                            unsigned int OutArrID1;
+                            unsigned int   n;
+                            }sinsp_Params;
+
+/* Function call : double divdp( double x, double y );*/
+typedef struct divdp_Params{
+                             unsigned int x_InArrID1;
+                             unsigned int y_InArrID2;
+                             unsigned int OutArrID1;
+                             unsigned int   n;
+                             }divdp_Params;
+/* Function call : float divsp( float x, float y );*/
+typedef struct divsp_Params{
+                             unsigned int x_InArrID1;
+                             unsigned int y_InArrID2;
+                             unsigned int OutArrID1;
+                             unsigned int   n;
+                             }divsp_Params;
+                                                         
+/* Function call : double sqrtdp( double z );*/
+typedef struct sqrtdp_Params{
+                             unsigned int z_InArrID1;
+                             unsigned int OutArrID1;
+                             unsigned int   n;
+                             }sqrtdp_Params;
+
+/* Function call : float sqrtsp( float z );*/
+typedef struct sqrtsp_Params{
+                            unsigned int z_InArrID1;
+                            unsigned int OutArrID1;
+                            unsigned int   n;
+                           }sqrtsp_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Vision Library functions                    */
+/*                     Added by Pramod                                               */
+/*************************************************************************************/
+
+/* Function Call: int VLIB_integralImage8(unsigned char* restrict pIn,unsigned short  inCols,unsigned short  inRows,unsigned int* restrict pLastLine,   
+															unsigned int* restrict pOut)*/
+typedef struct VLIB_integralImage8_Params{
+                                         unsigned int pIn_InArrID1;         /* Input Image inCols x inRows */
+                                         unsigned short  inCols;            /* Number of inCols */
+					 unsigned short  inRows;            /* Number of inRowss */
+                                         unsigned int pLastLine_InArrID2;   /* 32-bit carry-over buffer */
+                                         unsigned int pOut_OutArrID1;       /* 32-bit output buffer */
+                                         }VLIB_integralImage8_Params;
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Other IMG Library functions                */
+/*                 Functionality Added by Pramod                                     */
+/*		   Kernel Provided by Gagan					     */
+/*************************************************************************************/
+
+/* Function Call: int IMG_RGB_To_Y(unsigned char* restrict src, unsigned char * restrict dst, unsigned int count)*/
+
+typedef struct IMG_RGB_To_Y_Params{
+				  unsigned int src_InArrID1;              /* Input RGB image         */
+				  unsigned int dst_OutArrID1;             /* Output greyscale image  */
+				  unsigned int count;			  /* Total Pixels	     */
+				  }IMG_RGB_To_Y_Params;
+
+
+/* ***********************************************************************************/
+/* Parameter stucture definitions for the Other DSP Library functions                */
+/*                 Functionality Added by Pramod                                     */
+/*		   								     */
+/*************************************************************************************/
+
+/* Function Call: int C6accel_DSP_dft_f(C6accel_Handle hC6accel,
+                          unsigned char * restrict ptr_src,       
+                          unsigned char * restrict ptr_dst,       
+			  int cols, int rows,                     
+			  int srcMatFlag,		         
+			  int dstMatFlag,			  
+			  int dxtType,				 
+			  int nonZeroRows, 			  
+			  unsigned char *restrict pWorkingBuf,    
+                          unsigned char *restrict pWorkingBuf2)                         */
+
+typedef struct DSP_dft_f_Params{
+				  unsigned int src_InArrID1;              /* Pointer to input image */
+				  unsigned int dst_OutArrID1;             /* Pointer to Greyscale output image    */
+				  int dxtType;				  /* Type of action to take */ 
+				  int nonZeroRows; 			  /* Count of non-zero rows */
+				  IplImage src;
+				  IplImage dst;
+				  }DSP_dft_f_Params;
+
+			  
+			  
+/******************************************************************************
+ *  ======== C6ACCEL_TI_IC6ACCEL ========
+ *  Our implementation of the IUNIVERSAL interface
+ *****************************************************************************/
+extern IUNIVERSAL_Fxns C6ACCEL_TI_IC6ACCEL;
+extern IALG_Fxns C6ACCEL_TI_IALG;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/*
+ *  @(#) ti.C6ACCEL; 1, 0, 0,10; 5-7-2010 17:59:00; 
+ */
+
+
Binary files c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/lib/C6Accel.a64P and c6accel_1_00_00_04_async/soc/packages/ti/c6accel/lib/C6Accel.a64P differ
Binary files c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/lib/C6Accel.l64P and c6accel_1_00_00_04_async/soc/packages/ti/c6accel/lib/C6Accel.l64P differ
diff -uNr c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/.xdcenv.mak c6accel_1_00_00_04_async/soc/packages/ti/c6accel/.xdcenv.mak
--- c6accel_1_00_00_04_async0/soc/packages/ti/c6accel/.xdcenv.mak	2010-07-28 05:21:18.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/packages/ti/c6accel/.xdcenv.mak	2010-08-14 17:24:31.000000000 -0500
@@ -1,16 +1,16 @@
 #
 _XDCBUILDCOUNT = 0
 ifneq (,$(findstring path,$(_USEXDCENV_)))
-override XDCPATH = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/soc;packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdais_6_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/fctools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dspbios_5_41_03_17/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/biosutils_1_02_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/linuxutils_2_25_02_08/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/cetools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/edma3lld_01_11_00_03/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codecs-omapl138_1_10_00_01/packages
-override XDCROOT = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdctools_3_16_03_36
-override XDCBUILDCFG = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/config.bld
+override XDCPATH = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/soc;packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/fctools/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/cetools/packages;/packages;/packages
+override XDCROOT = /media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree
+override XDCBUILDCFG = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/config.bld
 endif
 ifneq (,$(findstring args,$(_USEXDCENV_)))
-override XDCARGS = "prod"
-override XDCTARGETS = ti.targets.C674
+override XDCARGS = 
+override XDCTARGETS = ti.targets.C64P
 endif
 #
 ifeq (0,1)
-PKGPATH = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/soc;packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdais_6_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/fctools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dspbios_5_41_03_17/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/biosutils_1_02_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/linuxutils_2_25_02_08/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/cetools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/edma3lld_01_11_00_03/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codecs-omapl138_1_10_00_01/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdctools_3_16_03_36/packages;../..
+PKGPATH = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/soc;packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/fctools/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/cetools/packages;/packages;/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree/packages;../..
 HOSTOS = Linux
 endif
diff -uNr c6accel_1_00_00_04_async0/soc/packages/ti/c6accel_unitservers/omap3530/.xdcenv.mak c6accel_1_00_00_04_async/soc/packages/ti/c6accel_unitservers/omap3530/.xdcenv.mak
--- c6accel_1_00_00_04_async0/soc/packages/ti/c6accel_unitservers/omap3530/.xdcenv.mak	2010-07-28 06:08:40.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/packages/ti/c6accel_unitservers/omap3530/.xdcenv.mak	2010-08-14 17:24:44.000000000 -0500
@@ -1,16 +1,16 @@
 #
 _XDCBUILDCOUNT = 0
 ifneq (,$(findstring path,$(_USEXDCENV_)))
-override XDCPATH = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/soc;packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdais_6_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/fctools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dspbios_5_41_03_17/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/biosutils_1_02_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/linuxutils_2_25_02_08/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/cetools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/edma3lld_01_11_00_03/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codecs-omapl138_1_10_00_01/packages
-override XDCROOT = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdctools_3_16_03_36
-override XDCBUILDCFG = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/config.bld
+override XDCPATH = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/soc;packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/fctools/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/cetools/packages;/packages;/packages
+override XDCROOT = /media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree
+override XDCBUILDCFG = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/config.bld
 endif
 ifneq (,$(findstring args,$(_USEXDCENV_)))
-override XDCARGS = "prod"
-override XDCTARGETS = ti.targets.C674
+override XDCARGS = 
+override XDCTARGETS = ti.targets.C64P
 endif
 #
 ifeq (0,1)
-PKGPATH = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/soc;packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdais_6_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/fctools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dspbios_5_41_03_17/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/biosutils_1_02_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/linuxutils_2_25_02_08/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/cetools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/edma3lld_01_11_00_03/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codecs-omapl138_1_10_00_01/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdctools_3_16_03_36/packages;../../..
+PKGPATH = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/soc;packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/fctools/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/cetools/packages;/packages;/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree/packages;../../..
 HOSTOS = Linux
 endif
diff -uNr c6accel_1_00_00_04_async0/soc/packages/ti/c6accel_unitservers/omapl138/.xdcenv.mak c6accel_1_00_00_04_async/soc/packages/ti/c6accel_unitservers/omapl138/.xdcenv.mak
--- c6accel_1_00_00_04_async0/soc/packages/ti/c6accel_unitservers/omapl138/.xdcenv.mak	2010-07-28 05:21:24.000000000 -0500
+++ c6accel_1_00_00_04_async/soc/packages/ti/c6accel_unitservers/omapl138/.xdcenv.mak	2010-08-15 02:19:42.000000000 -0500
@@ -1,16 +1,16 @@
 #
 _XDCBUILDCOUNT = 1
 ifneq (,$(findstring path,$(_USEXDCENV_)))
-override XDCPATH = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/soc;packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdais_6_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/fctools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dspbios_5_41_03_17/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/biosutils_1_02_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/linuxutils_2_25_02_08/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/cetools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/edma3lld_01_11_00_03/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codecs-omapl138_1_10_00_01/packages
-override XDCROOT = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdctools_3_16_03_36
-override XDCBUILDCFG = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/config.bld
+override XDCPATH = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/soc;packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/fctools/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/cetools/packages;/packages;/packages
+override XDCROOT = /media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree
+override XDCBUILDCFG = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/config.bld
 endif
 ifneq (,$(findstring args,$(_USEXDCENV_)))
-override XDCARGS = "prod"
-override XDCTARGETS = ti.targets.C674
+override XDCARGS = 
+override XDCTARGETS = ti.targets.C64P
 endif
 #
 ifeq (0,1)
-PKGPATH = /home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/c6accel_1_00_00_04_async/soc;packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdais_6_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/framework-components_2_25_01_05/fctools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dspbios_5_41_03_17/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/biosutils_1_02_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/linuxutils_2_25_02_08/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/dsplink_1_65_00_02;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codec-engine_2_25_02_11/cetools/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/edma3lld_01_11_00_03/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/codecs-omapl138_1_10_00_01/packages;/home/a0741025/dntsvideo_a0741025/dvsdk_4_00_00_06_l138/xdctools_3_16_03_36/packages;../../..
+PKGPATH = /home/jars/Desktop/opencv-dsp-acceleration/dsp_opencv/beagle/c6accel_1_00_00_04_async/soc;packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdais-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-framework-components-tree/fctools/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dspbios-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-biosutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-linuxutils-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-dsplink-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-codec-engine-tree/cetools/packages;/packages;/packages;/media/disk/openembedded/build/tmp-angstrom_2008_1/sysroots/beagleboard-angstrom-linux-gnueabi/usr/share/ti/ti-xdctools-tree/packages;../../..
 HOSTOS = Linux
 endif
